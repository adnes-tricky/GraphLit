import type { Vector2D } from '..';
import type { Point2D } from '../modules/vector2d/core';
import type { EdgeGroupStates, isSummarizedEdges } from '../composables/state';
import type { LayoutActivateParameters } from '../layouts/handler';
import type { BoxSelectionOption } from '../composables/mouse/boxSelection';
import type { PathStates, EdgeObject } from '../models/path';
import type { EdgeStates, EdgeEntry, Line, SummarizedEdgeStates, EdgeGroup } from '../models/edge';
import type { NodeStates } from '../models/node';
import type { MarkerState } from '../composables/marker';
import type { Emitter } from 'mitt';
import type { DefineComponent, Slot, Ref, ComputedRef, ComponentOptionsMixin, VNodeProps, AllowedComponentProps, ComponentCustomProps, ExtractPropTypes, WatchStopHandle, CSSProperties } from 'vue';
import type { Path, Events, Node, Edge, LayerName, Rectangle, NodePositions, LinePosition, EdgePosition, EdgeLabelArea, PositionOrCurve, Nodes,  Edges,  Layouts } from '../common/types';
import { LayerPosition, Point, Sizes } from '../common/types';
import { Reactive } from '../common/common';
import type { Configs, ShapeType, NodeLabelDirectionType, NodeLabelDirectionAutoAdjustmentHandler, LabelBackgroundStyle, EdgeType, EdgeHeadType, StrokeStyle, MarkerUnits, EdgeKeepOrderType, PathEndType, EdgeConfig, LabelStyle, ShapeStyle, NodeConfig, NodeLabelStyle, OppositeNode, PathConfig, PathStrokeStyle, ViewConfig } from '../common/configs';
import { SvgPanZoomInstance, Box } from '../modules/svg-pan-zoom-ex';
import { ExportOptions } from '../utils/svg';
declare enum State {
    INITIAL = 0,
    LOADED = 1,
    UNLOADED = 2
}
declare const _sfc_main: DefineComponent<{
    nodes: {
        type: null;
        required: false;
        default: () => {};
    };
    edges: {
        type: null;
        required: false;
        default: () => {};
    };
    paths: {
        type: null;
        required: false;
        default: () => {};
    };
    layouts: {
        type: null;
        required: false;
        default: () => {};
    };
    zoomLevel: {
        type: NumberConstructor;
        required: false;
        default: number;
    };
    selectedNodes: {
        type: ArrayConstructor;
        required: false;
        default: () => never[];
    };
    selectedEdges: {
        type: ArrayConstructor;
        required: false;
        default: () => never[];
    };
    selectedPaths: {
        type: ArrayConstructor;
        required: false;
        default: () => never[];
    };
    configs: {
        type: null;
        required: false;
        default: () => {};
    };
    layers: {
        type: null;
        required: false;
        default: () => {};
    };
    eventHandlers: {
        type: null;
        required: false;
        default: () => {};
    };
}, {
    SYSTEM_SLOTS: string[];
    State: typeof State;
    props: any;
    emit: {
        (e: "update:zoomLevel", v: number): void;
        (e: "update:selectedNodes", v: string[]): void;
        (e: "update:selectedEdges", v: string[]): void;
        (e: "update:selectedPaths", v: string[]): void;
        (e: "update:layouts", v: Layouts): void;
    };
    slots: Readonly<{
        [name: string]: Slot | undefined;
    }>;
    nodesRef: Ref<Nodes>;
    edgesRef: Ref<Edges>;
    pathsRef: Ref<Record<string, Path>>;
    isInCompatibilityModeForPath: Ref<boolean>;
    emitter: Emitter<Events>;
    configs: Configs<Node, Edge, Path>;
    layerDefs: ComputedRef<Record<LayerPosition, string[]>>;
    isShowGrid: ComputedRef<boolean>;
    isShowBackgroundViewport: ComputedRef<boolean>;
    builtInLayerOrder: ComputedRef<LayerName[]>;
    container: Ref<HTMLDivElement | undefined>;
    svg: Ref<(SVGElement & SVGSVGElement) | undefined>;
    viewport: Ref<SVGGElement | undefined>;
    state: Ref<State>;
    show: ComputedRef<boolean>;
    zoomLevel: Ref<number>;
    svgPanZoom: Ref<SvgPanZoomInstance | undefined>;
    onSvgPanZoomMounted: (callback: () => void) => void;
    onSvgPanZoomUnmounted: (callback: () => void) => void;
    rectSize: {
        width: number;
        height: number;
    };
    resizeObserver: ResizeObserver | undefined;
    applyAbsoluteZoomLevel: (absoluteZoomLevel: number) => void;
    scale: ComputedRef<number>;
    updateBorderBox: (callback: () => void) => void;
    fitToContents: () => void;
    panToCenter: () => void;
    getViewBox: () => Box;
    setViewBox: (box: Box) => void | undefined;
    currentSelectedNodes: Reactive<Set<string>>;
    currentSelectedEdges: Reactive<Set<string>>;
    currentSelectedPaths: Reactive<Set<string>>;
    hoveredNodes: Reactive<Set<string>>;
    hoveredEdges: Reactive<Set<string>>;
    hoveredPaths: Reactive<Set<string>>;
    currentLayouts: Reactive<Layouts>;
    markerState: MarkerState;
    dragging: Ref<boolean>;
    touches: ComputedRef<boolean | ((target: Node) => boolean)>;
    nodeStates: NodeStates;
    edgeStates: EdgeStates;
    pathStates: PathStates;
    isSvgWheelZoomEnabled: ComputedRef<boolean>;
    isBoxSelectionMode: Ref<boolean>;
    selectionBox: Ref<Rectangle>;
    startBoxSelection: (options?: Partial<BoxSelectionOption> | undefined) => void;
    stopBoxSelection: () => void;
    activateParams: () => {
        layouts: Reactive<NodePositions>;
        nodePositions: Ref<NodePositions>;
        nodes: Ref<Nodes>;
        edges: Ref<Edges>;
        configs: {
            readonly view: {
                readonly scalingObjects: boolean;
                readonly panEnabled: boolean;
                readonly zoomEnabled: boolean;
                readonly minZoomLevel: number;
                readonly maxZoomLevel: number;
                readonly doubleClickZoomEnabled: boolean;
                readonly mouseWheelZoomEnabled: boolean;
                readonly boxSelectionEnabled: boolean;
                readonly fit?: boolean | undefined;
                readonly autoPanAndZoomOnLoad: false | "center-content" | "center-zero" | "fit-content";
                readonly autoPanOnResize: boolean;
                readonly layoutHandler: {
                    readonly activate: (parameters: LayoutActivateParameters) => void;
                    readonly deactivate: () => void;
                };
                readonly onSvgPanZoomInitialized?: ((instance: SvgPanZoomInstance) => void) | undefined;
                readonly grid: {
                    readonly visible: boolean;
                    readonly interval: number;
                    readonly thickIncrements: number | false;
                    readonly line: {
                        readonly color: string;
                        readonly width: number;
                        readonly dasharray?: string | number | undefined;
                    };
                    readonly thick: {
                        readonly color: string;
                        readonly width: number;
                        readonly dasharray?: string | number | undefined;
                    };
                };
                readonly selection: {
                    readonly box: {
                        readonly strokeWidth: number;
                        readonly strokeColor?: string | undefined;
                        readonly strokeDasharray?: string | number | undefined;
                        readonly color: string;
                    };
                    readonly detector: (event: KeyboardEvent) => boolean;
                };
                readonly builtInLayerOrder: readonly LayerName[];
            };
            readonly node: {
                readonly normal: {
                    readonly type: ShapeType | ((target: Node) => ShapeType);
                    readonly radius: number | ((target: Node) => number);
                    readonly strokeWidth: number | ((target: Node) => number);
                    readonly strokeColor?: string | ((target: Node) => string | undefined) | undefined;
                    readonly strokeDasharray?: string | number | ((target: Node) => string | number | undefined) | undefined;
                    readonly color: string | ((target: Node) => string);
                    readonly width: number | ((target: Node) => number);
                    readonly height: number | ((target: Node) => number);
                    readonly borderRadius: number | ((target: Node) => number);
                };
                readonly hover?: {
                    readonly type: ShapeType | ((target: Node) => ShapeType);
                    readonly radius: number | ((target: Node) => number);
                    readonly strokeWidth: number | ((target: Node) => number);
                    readonly strokeColor?: string | ((target: Node) => string | undefined) | undefined;
                    readonly strokeDasharray?: string | number | ((target: Node) => string | number | undefined) | undefined;
                    readonly color: string | ((target: Node) => string);
                    readonly width: number | ((target: Node) => number);
                    readonly height: number | ((target: Node) => number);
                    readonly borderRadius: number | ((target: Node) => number);
                } | undefined;
                readonly selected?: {
                    readonly type: ShapeType | ((target: Node) => ShapeType);
                    readonly radius: number | ((target: Node) => number);
                    readonly strokeWidth: number | ((target: Node) => number);
                    readonly strokeColor?: string | ((target: Node) => string | undefined) | undefined;
                    readonly strokeDasharray?: string | number | ((target: Node) => string | number | undefined) | undefined;
                    readonly color: string | ((target: Node) => string);
                    readonly width: number | ((target: Node) => number);
                    readonly height: number | ((target: Node) => number);
                    readonly borderRadius: number | ((target: Node) => number);
                } | undefined;
                readonly draggable: boolean | ((target: Node) => boolean);
                readonly selectable: number | (boolean | ((target: Node) => boolean));
                readonly label: {
                    readonly visible: boolean | ((target: Node) => boolean);
                    readonly margin: number | ((target: Node) => number);
                    readonly direction: NodeLabelDirectionType | ((target: Node) => NodeLabelDirectionType);
                    readonly directionAutoAdjustment: boolean | NodeLabelDirectionAutoAdjustmentHandler | ((target: Node) => boolean | NodeLabelDirectionAutoAdjustmentHandler);
                    readonly text: string | ((target: Node) => string);
                    readonly handleNodeEvents: boolean | ((target: Node) => boolean);
                    readonly fontFamily?: string | ((target: Node) => string | undefined) | undefined;
                    readonly fontSize: number | ((target: Node) => number);
                    readonly color: string | ((target: Node) => string);
                    readonly background?: ((target: Node) => LabelBackgroundStyle | undefined) | {
                        readonly visible: boolean;
                        readonly color?: string | undefined;
                        readonly padding?: number | {
                            readonly vertical: number;
                            readonly horizontal: number;
                        } | undefined;
                        readonly borderRadius?: number | undefined;
                    } | undefined;
                    readonly lineHeight: number | ((target: Node) => number);
                };
                readonly focusring: {
                    readonly visible: boolean;
                    readonly width: number;
                    readonly padding: number;
                    readonly color: string;
                    readonly dasharray?: string | number | undefined;
                };
                readonly zOrder: {
                    readonly enabled: boolean;
                    readonly zIndex: number | ((target: Node) => number);
                    readonly bringToFrontOnHover: boolean;
                    readonly bringToFrontOnSelected: boolean;
                };
                readonly transition?: string | undefined;
            };
            readonly edge: {
                readonly normal: {
                    readonly width: number | ((target: Edge) => number);
                    readonly color: string | ((target: Edge) => string);
                    readonly dasharray?: string | number | ((target: Edge) => string | number | undefined) | undefined;
                    readonly linecap?: "butt" | "round" | "square" | ((target: Edge) => "butt" | "round" | "square" | undefined) | undefined;
                    readonly animate: boolean | ((target: Edge) => boolean);
                    readonly animationSpeed: number | ((target: Edge) => number);
                };
                readonly hover?: {
                    readonly width: number | ((target: Edge) => number);
                    readonly color: string | ((target: Edge) => string);
                    readonly dasharray?: string | number | ((target: Edge) => string | number | undefined) | undefined;
                    readonly linecap?: "butt" | "round" | "square" | ((target: Edge) => "butt" | "round" | "square" | undefined) | undefined;
                    readonly animate: boolean | ((target: Edge) => boolean);
                    readonly animationSpeed: number | ((target: Edge) => number);
                } | undefined;
                readonly selected: {
                    readonly width: number | ((target: Edge) => number);
                    readonly color: string | ((target: Edge) => string);
                    readonly dasharray?: string | number | ((target: Edge) => string | number | undefined) | undefined;
                    readonly linecap?: "butt" | "round" | "square" | ((target: Edge) => "butt" | "round" | "square" | undefined) | undefined;
                    readonly animate: boolean | ((target: Edge) => boolean);
                    readonly animationSpeed: number | ((target: Edge) => number);
                };
                readonly selectable: number | (boolean | ((target: Edge) => boolean));
                readonly gap: number | ((edges: Edges, configs: Configs<Node, Edge, Path>) => number);
                readonly type: EdgeType;
                readonly marker: {
                    readonly source: {
                        readonly type: EdgeHeadType | ((target: [Edge, StrokeStyle]) => EdgeHeadType);
                        readonly width: number | ((target: [Edge, StrokeStyle]) => number);
                        readonly height: number | ((target: [Edge, StrokeStyle]) => number);
                        readonly margin: number | ((target: [Edge, StrokeStyle]) => number);
                        readonly units: MarkerUnits | ((target: [Edge, StrokeStyle]) => MarkerUnits);
                        readonly color: string | ((target: [Edge, StrokeStyle]) => string | null) | null;
                        readonly customId?: string | ((target: [Edge, StrokeStyle]) => string | undefined) | undefined;
                    };
                    readonly target: {
                        readonly type: EdgeHeadType | ((target: [Edge, StrokeStyle]) => EdgeHeadType);
                        readonly width: number | ((target: [Edge, StrokeStyle]) => number);
                        readonly height: number | ((target: [Edge, StrokeStyle]) => number);
                        readonly margin: number | ((target: [Edge, StrokeStyle]) => number);
                        readonly units: MarkerUnits | ((target: [Edge, StrokeStyle]) => MarkerUnits);
                        readonly color: string | ((target: [Edge, StrokeStyle]) => string | null) | null;
                        readonly customId?: string | ((target: [Edge, StrokeStyle]) => string | undefined) | undefined;
                    };
                };
                readonly margin: number | null;
                readonly summarize: boolean | ((edges: Edges, configs: Configs<Node, Edge, Path>) => boolean | null);
                readonly summarized: {
                    readonly label: {
                        readonly fontFamily?: string | ((target: Record<string, Edge>) => string | undefined) | undefined;
                        readonly fontSize: number | ((target: Record<string, Edge>) => number);
                        readonly color: string | ((target: Record<string, Edge>) => string);
                        readonly background?: {
                            readonly visible: boolean;
                            readonly color?: string | undefined;
                            readonly padding?: number | {
                                readonly vertical: number;
                                readonly horizontal: number;
                            } | undefined;
                            readonly borderRadius?: number | undefined;
                        } | ((target: Record<string, Edge>) => LabelBackgroundStyle | undefined) | undefined;
                        readonly lineHeight: number | ((target: Record<string, Edge>) => number);
                    };
                    readonly shape: {
                        readonly type: ShapeType | ((target: Record<string, Edge>) => ShapeType);
                        readonly radius: number | ((target: Record<string, Edge>) => number);
                        readonly strokeWidth: number | ((target: Record<string, Edge>) => number);
                        readonly strokeColor?: string | ((target: Record<string, Edge>) => string | undefined) | undefined;
                        readonly strokeDasharray?: string | number | ((target: Record<string, Edge>) => string | number | undefined) | undefined;
                        readonly color: string | ((target: Record<string, Edge>) => string);
                        readonly width: number | ((target: Record<string, Edge>) => number);
                        readonly height: number | ((target: Record<string, Edge>) => number);
                        readonly borderRadius: number | ((target: Record<string, Edge>) => number);
                    };
                    readonly stroke: {
                        readonly width: number | ((target: Record<string, Edge>) => number);
                        readonly color: string | ((target: Record<string, Edge>) => string);
                        readonly dasharray?: string | number | ((target: Record<string, Edge>) => string | number | undefined) | undefined;
                        readonly linecap?: "butt" | "round" | "square" | ((target: Record<string, Edge>) => "butt" | "round" | "square" | undefined) | undefined;
                        readonly animate: boolean | ((target: Record<string, Edge>) => boolean);
                        readonly animationSpeed: number | ((target: Record<string, Edge>) => number);
                    };
                };
                readonly selfLoop: {
                    readonly radius: number | ((target: Edge) => number);
                    readonly offset: number | ((target: Edge) => number);
                    readonly angle: number | ((target: Edge) => number);
                    readonly isClockwise: boolean | ((target: Edge) => boolean);
                };
                readonly keepOrder: EdgeKeepOrderType;
                readonly label: {
                    readonly margin: number;
                    readonly padding: number;
                    readonly fontFamily?: string | undefined;
                    readonly fontSize: number;
                    readonly color: string;
                    readonly background?: {
                        readonly visible: boolean;
                        readonly color?: string | undefined;
                        readonly padding?: number | {
                            readonly vertical: number;
                            readonly horizontal: number;
                        } | undefined;
                        readonly borderRadius?: number | undefined;
                    } | undefined;
                    readonly lineHeight: number;
                };
                readonly zOrder: {
                    readonly enabled: boolean;
                    readonly zIndex: number | ((target: Edge) => number);
                    readonly bringToFrontOnHover: boolean;
                    readonly bringToFrontOnSelected: boolean;
                };
            };
            readonly path: {
                readonly visible: boolean;
                readonly clickable: boolean | ((target: Path) => boolean);
                readonly hoverable: boolean | ((target: Path) => boolean);
                readonly curveInNode: boolean;
                readonly end: PathEndType;
                readonly margin: number | ((target: Path) => number);
                readonly path: {
                    readonly linejoin: "round" | "miter" | "bevel" | ((target: Path) => "round" | "miter" | "bevel");
                    readonly width: number | ((target: Path) => number);
                    readonly color: string | ((target: Path) => string);
                    readonly dasharray?: string | number | ((target: Path) => string | number | undefined) | undefined;
                    readonly linecap?: "butt" | "round" | "square" | ((target: Path) => "butt" | "round" | "square" | undefined) | undefined;
                    readonly animate: boolean | ((target: Path) => boolean);
                    readonly animationSpeed: number | ((target: Path) => number);
                };
                readonly normal: {
                    readonly linejoin: "round" | "miter" | "bevel" | ((target: Path) => "round" | "miter" | "bevel");
                    readonly width: number | ((target: Path) => number);
                    readonly color: string | ((target: Path) => string);
                    readonly dasharray?: string | number | ((target: Path) => string | number | undefined) | undefined;
                    readonly linecap?: "butt" | "round" | "square" | ((target: Path) => "butt" | "round" | "square" | undefined) | undefined;
                    readonly animate: boolean | ((target: Path) => boolean);
                    readonly animationSpeed: number | ((target: Path) => number);
                };
                readonly hover?: {
                    readonly linejoin: "round" | "miter" | "bevel" | ((target: Path) => "round" | "miter" | "bevel");
                    readonly width: number | ((target: Path) => number);
                    readonly color: string | ((target: Path) => string);
                    readonly dasharray?: string | number | ((target: Path) => string | number | undefined) | undefined;
                    readonly linecap?: "butt" | "round" | "square" | ((target: Path) => "butt" | "round" | "square" | undefined) | undefined;
                    readonly animate: boolean | ((target: Path) => boolean);
                    readonly animationSpeed: number | ((target: Path) => number);
                } | undefined;
                readonly selected: {
                    readonly linejoin: "round" | "miter" | "bevel" | ((target: Path) => "round" | "miter" | "bevel");
                    readonly width: number | ((target: Path) => number);
                    readonly color: string | ((target: Path) => string);
                    readonly dasharray?: string | number | ((target: Path) => string | number | undefined) | undefined;
                    readonly linecap?: "butt" | "round" | "square" | ((target: Path) => "butt" | "round" | "square" | undefined) | undefined;
                    readonly animate: boolean | ((target: Path) => boolean);
                    readonly animationSpeed: number | ((target: Path) => number);
                };
                readonly selectable: number | (boolean | ((target: Path) => boolean));
                readonly zOrder: {
                    readonly enabled: boolean;
                    readonly zIndex: number | ((target: Path) => number);
                    readonly bringToFrontOnHover: boolean;
                    readonly bringToFrontOnSelected: boolean;
                };
                readonly transition?: string | undefined;
            };
        };
        scale: Readonly<Ref<number>>;
        emitter: Emitter<Events>;
        svgPanZoom: SvgPanZoomInstance;
    };
    transitionWhile: (func: () => void | Promise<void>, duration?: number, timingFunction?: string) => void;
    transitionOption: Ref<{
        enabled: boolean;
        duration: number;
        timingFunction: string;
    }>;
    transitionStyles: ComputedRef<CSSProperties>;
    zoomIn: () => void;
    zoomOut: () => void;
    panTo: (point: Point) => void;
    panBy: (point: Point) => void;
    getPan: () => Point;
    getSizes: () => Sizes;
    translateFromDomToSvgCoordinates: (coordinates: Point) => Point;
    translateFromSvgToDomCoordinates: (coordinates: Point) => Point;
    getAsSvg: () => string;
    exportAsSvgText: (options?: Partial<ExportOptions>) => Promise<string>;
    exportAsSvgElement: (options?: Partial<ExportOptions>) => Promise<SVGElement>;
    applyZoomEnabled: (svgPanZoom: SvgPanZoomInstance, enable: boolean, enableDblClick: boolean, enableMouseWheel: boolean) => void;
    isDoubleClickZoomEnabled: (view: ViewConfig) => boolean;
    isMouseWheelZoomEnabled: (view: ViewConfig) => boolean;
    stopEventPropagation: (event: Event) => void;
    VSelectionBox: DefineComponent<{
        box: {
            type: null;
            required: true;
        };
        config: {
            type: null;
            required: true;
        };
    }, {}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
        box: {
            type: null;
            required: true;
        };
        config: {
            type: null;
            required: true;
        };
    }>>, {}>;
    VMarkerHead: DefineComponent<{
        id: {
            type: StringConstructor;
            required: true;
        };
        marker: {
            type: null;
            required: true;
        };
        scale: {
            type: NumberConstructor;
            required: true;
        };
    }, {
        types: Record<"circle" | "angle" | "arrow", any>;
        props: any;
        width: ComputedRef<number>;
        height: ComputedRef<number>;
        refX: ComputedRef<number>;
    }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
        id: {
            type: StringConstructor;
            required: true;
        };
        marker: {
            type: null;
            required: true;
        };
        scale: {
            type: NumberConstructor;
            required: true;
        };
    }>>, {}>;
    VBackgroundGrid: DefineComponent<{}, {
        container: Ref<HTMLDivElement>;
        svgPanZoom: Ref<SvgPanZoomInstance | undefined>;
        zoomLevel: Ref<number>;
        emitter: Emitter<Events>;
        config: ViewConfig;
        basePoint: Ref<{
            x: number;
            y: number;
        }>;
        viewport: Ref<{
            width: number;
            height: number;
        }>;
        thickVerticals: Ref<[number, number, number, number, Record<string, any>][]>;
        thickHorizontals: Ref<[number, number, number, number, Record<string, any>][]>;
        normalVerticals: Ref<[number, number, number, number, Record<string, any>][]>;
        normalHorizontals: Ref<[number, number, number, number, Record<string, any>][]>;
    }, {}, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{}>>, {}>;
    VBackgroundViewport: DefineComponent<{}, {
        viewport: Ref<SVGGElement>;
        background: Ref<SVGGElement | undefined>;
        updateAttributes: (attrs: string[], bgLayer: SVGGElement, vpLayer: SVGGElement) => void;
        observer: MutationObserver;
    }, {}, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{}>>, {}>;
    VEdgesLayer: DefineComponent<{}, {
        slots: Readonly<{
            [name: string]: Slot | undefined;
        }>;
        hasEdgeOverlaySlot: ComputedRef<boolean>;
        VEdgeBackgrounds: DefineComponent<{}, {
            edgeStates: EdgeStates;
            edgeGroupStates: EdgeGroupStates;
            layouts: Layouts;
            VEdgeBackground: DefineComponent<{
                id: {
                    type: StringConstructor;
                    required: true;
                };
                state: {
                    type: null;
                    required: true;
                };
                sourcePos: {
                    type: null;
                    required: false;
                    default: undefined;
                };
                targetPos: {
                    type: null;
                    required: false;
                    default: undefined;
                };
            }, {
                props: any;
                scale: Ref<number>;
                config: EdgeConfig<Edge>;
                handleEdgePointerDownEvent: (edge: string, event: PointerEvent) => void;
                handleEdgePointerOverEvent: (edge: string, event: PointerEvent) => void;
                handleEdgePointerOutEvent: (edge: string, event: PointerEvent) => void;
                handleEdgeClickEvent: (edge: string, event: MouseEvent) => void;
                handleEdgeDoubleClickEvent: (edge: string, event: MouseEvent) => void;
                handleEdgeContextMenu: (edge: string, event: MouseEvent) => void;
                pathD: ComputedRef<string>;
                strokeWidth: ComputedRef<number>;
            }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
                id: {
                    type: StringConstructor;
                    required: true;
                };
                state: {
                    type: null;
                    required: true;
                };
                sourcePos: {
                    type: null;
                    required: false;
                    default: undefined;
                };
                targetPos: {
                    type: null;
                    required: false;
                    default: undefined;
                };
            }>>, {
                sourcePos: any;
                targetPos: any;
            }>;
        }, {}, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{}>>, {}>;
        VEdgeGroups: DefineComponent<{
            hasEdgeOverlaySlot: {
                type: BooleanConstructor;
                required: true;
            };
        }, {
            edgeStates: EdgeStates;
            edgeZOrderedList: ComputedRef<EdgeEntry[]>;
            layouts: Layouts;
            readonly isSummarizedEdges: typeof isSummarizedEdges;
            VEdge: DefineComponent<{
                id: {
                    type: StringConstructor;
                    required: true;
                };
                state: {
                    type: null;
                    required: true;
                };
                sourcePos: {
                    type: null;
                    required: false;
                    default: undefined;
                };
                targetPos: {
                    type: null;
                    required: false;
                    default: undefined;
                };
            }, {
                config: EdgeConfig<Edge>;
                VLine: DefineComponent<{
                    p1: {
                        type: null;
                        required: true;
                    };
                    p2: {
                        type: null;
                        required: true;
                    };
                    config: {
                        type: null;
                        required: true;
                    };
                }, {
                    props: any;
                    scale: Ref<number>;
                    strokeWidth: ComputedRef<number>;
                    strokeDasharray: ComputedRef<string | number | undefined>;
                    animationSpeed: ComputedRef<string | undefined>;
                }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
                    p1: {
                        type: null;
                        required: true;
                    };
                    p2: {
                        type: null;
                        required: true;
                    };
                    config: {
                        type: null;
                        required: true;
                    };
                }>>, {}>;
                VArc: DefineComponent<{
                    p1: {
                        type: null;
                        required: true;
                    };
                    p2: {
                        type: null;
                        required: true;
                    };
                    radius: {
                        type: ArrayConstructor;
                        required: true;
                    };
                    isLargeArc: {
                        type: BooleanConstructor;
                        required: true;
                    };
                    isClockwise: {
                        type: BooleanConstructor;
                        required: true;
                    };
                    config: {
                        type: null;
                        required: true;
                    };
                }, {
                    props: any;
                    scale: Ref<number>;
                    strokeWidth: ComputedRef<number>;
                    strokeDasharray: ComputedRef<string | number | undefined>;
                    animationSpeed: ComputedRef<string | undefined>;
                    pathD: ComputedRef<string>;
                }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
                    p1: {
                        type: null;
                        required: true;
                    };
                    p2: {
                        type: null;
                        required: true;
                    };
                    radius: {
                        type: ArrayConstructor;
                        required: true;
                    };
                    isLargeArc: {
                        type: BooleanConstructor;
                        required: true;
                    };
                    isClockwise: {
                        type: BooleanConstructor;
                        required: true;
                    };
                    config: {
                        type: null;
                        required: true;
                    };
                }>>, {}>;
                VEdgeCurved: DefineComponent<{
                    state: {
                        type: null;
                        required: true;
                    };
                    config: {
                        type: null;
                        required: true;
                    };
                    markerStart: {
                        type: StringConstructor;
                        required: false;
                        default: undefined;
                    };
                    markerEnd: {
                        type: StringConstructor;
                        required: false;
                        default: undefined;
                    };
                }, {
                    props: any;
                    scale: Ref<number>;
                    pathD: ComputedRef<string>;
                    strokeWidth: ComputedRef<number>;
                    strokeDasharray: ComputedRef<string | number | undefined>;
                    animationSpeed: ComputedRef<string | undefined>;
                }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
                    state: {
                        type: null;
                        required: true;
                    };
                    config: {
                        type: null;
                        required: true;
                    };
                    markerStart: {
                        type: StringConstructor;
                        required: false;
                        default: undefined;
                    };
                    markerEnd: {
                        type: StringConstructor;
                        required: false;
                        default: undefined;
                    };
                }>>, {
                    markerStart: string;
                    markerEnd: string;
                }>;
            }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
                id: {
                    type: StringConstructor;
                    required: true;
                };
                state: {
                    type: null;
                    required: true;
                };
                sourcePos: {
                    type: null;
                    required: false;
                    default: undefined;
                };
                targetPos: {
                    type: null;
                    required: false;
                    default: undefined;
                };
            }>>, {
                sourcePos: any;
                targetPos: any;
            }>;
            VEdgeSummarized: DefineComponent<{
                edges: {
                    type: null;
                    required: true;
                };
                layouts: {
                    type: null;
                    required: true;
                };
            }, {
                props: any;
                config: EdgeConfig<Edge>;
                handleEdgesPointerDownEvent: (edges: string[], event: PointerEvent) => void;
                handleEdgesPointerOverEvent: (edges: string[], event: PointerEvent) => void;
                handleEdgesPointerOutEvent: (edges: string[], event: PointerEvent) => void;
                handleEdgesClickEvent: (edges: string[], event: MouseEvent) => void;
                handleEdgesDoubleClickEvent: (edges: string[], event: MouseEvent) => void;
                handleEdgesContextMenu: (edges: string[], event: MouseEvent) => void;
                edgeStates: EdgeStates;
                pos: Ref<{
                    p1: {
                        x: number;
                        y: number;
                    };
                    p2: {
                        x: number;
                        y: number;
                    };
                }>;
                centerPos: Ref<{
                    x: number;
                    y: number;
                }>;
                edgeIds: ComputedRef<string[]>;
                labelConfig: ComputedRef<LabelStyle>;
                shapeConfig: ComputedRef<ShapeStyle>;
                strokeConfig: ComputedRef<StrokeStyle>;
                hovered: ComputedRef<boolean>;
                selectable: ComputedRef<boolean>;
                selected: ComputedRef<boolean>;
                VLine: DefineComponent<{
                    p1: {
                        type: null;
                        required: true;
                    };
                    p2: {
                        type: null;
                        required: true;
                    };
                    config: {
                        type: null;
                        required: true;
                    };
                }, {
                    props: any;
                    scale: Ref<number>;
                    strokeWidth: ComputedRef<number>;
                    strokeDasharray: ComputedRef<string | number | undefined>;
                    animationSpeed: ComputedRef<string | undefined>;
                }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
                    p1: {
                        type: null;
                        required: true;
                    };
                    p2: {
                        type: null;
                        required: true;
                    };
                    config: {
                        type: null;
                        required: true;
                    };
                }>>, {}>;
                VShape: DefineComponent<{
                    baseX: {
                        type: NumberConstructor;
                        required: false;
                        default: number;
                    };
                    baseY: {
                        type: NumberConstructor;
                        required: false;
                        default: number;
                    };
                    config: {
                        type: null;
                        required: true;
                    };
                }, {
                    props: any;
                    scale: Ref<number>;
                    x: Ref<number>;
                    y: Ref<number>;
                    strokeWidth: Ref<number>;
                    strokeColor: Ref<string>;
                    strokeDasharray: Ref<string | number | undefined>;
                    radius: Ref<number>;
                    width: Ref<number>;
                    height: Ref<number>;
                    borderRadius: Ref<number>;
                }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
                    baseX: {
                        type: NumberConstructor;
                        required: false;
                        default: number;
                    };
                    baseY: {
                        type: NumberConstructor;
                        required: false;
                        default: number;
                    };
                    config: {
                        type: null;
                        required: true;
                    };
                }>>, {
                    baseX: number;
                    baseY: number;
                }>;
                VText: DefineComponent<{
                    text: {
                        type: StringConstructor;
                        required: true;
                    };
                    x: {
                        type: NumberConstructor;
                        required: false;
                        default: number;
                    };
                    y: {
                        type: NumberConstructor;
                        required: false;
                        default: number;
                    };
                    dominantBaseline: {
                        type: StringConstructor;
                        required: false;
                        default: string;
                    };
                    config: {
                        type: null;
                        required: true;
                    };
                }, {
                    props: any;
                    attrs: {
                        [x: string]: unknown;
                    };
                    scale: Ref<number>;
                    texts: ComputedRef<string[]>;
                    fontSize: ComputedRef<number>;
                    lineHeight: ComputedRef<number>;
                    topDeltaY: ComputedRef<number>;
                    element: Ref<SVGTextElement | undefined>;
                    transform: Ref<string>;
                    pos: {
                        x: number;
                        y: number;
                        width: number;
                        height: number;
                    };
                    backgroundRectPos: ComputedRef<{
                        x: number;
                        y: number;
                        width: number;
                        height: number;
                    }>;
                    observer: MutationObserver | undefined;
                    updateObserver: () => void;
                    updateBackgroundPosition: (element: SVGTextElement, pos: {
                        x: number;
                        y: number;
                        width: number;
                        height: number;
                    }, transform: Ref<string | undefined>) => void;
                    enableMutationObserver: (element: SVGTextElement, pos: {
                        x: number;
                        y: number;
                        width: number;
                        height: number;
                    }, transform: Ref<string | undefined>) => MutationObserver;
                }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
                    text: {
                        type: StringConstructor;
                        required: true;
                    };
                    x: {
                        type: NumberConstructor;
                        required: false;
                        default: number;
                    };
                    y: {
                        type: NumberConstructor;
                        required: false;
                        default: number;
                    };
                    dominantBaseline: {
                        type: StringConstructor;
                        required: false;
                        default: string;
                    };
                    config: {
                        type: null;
                        required: true;
                    };
                }>>, {
                    x: number;
                    y: number;
                    dominantBaseline: string;
                }>;
            }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
                edges: {
                    type: null;
                    required: true;
                };
                layouts: {
                    type: null;
                    required: true;
                };
            }>>, {}>;
            VEdgeOverlay: DefineComponent<{
                edgeId: {
                    type: StringConstructor;
                    required: false;
                    default: undefined;
                };
                edge: {
                    type: null;
                    required: false;
                    default: undefined;
                };
                edges: {
                    type: null;
                    required: false;
                    default: () => {};
                };
                state: {
                    type: null;
                    required: true;
                };
                isSummarized: {
                    type: BooleanConstructor;
                    required: true;
                };
            }, {
                props: any;
                svg: Ref<SVGElement>;
                scale: Ref<number>;
                edgeConfig: EdgeConfig<Edge>;
                getStrokeConfig: () => StrokeStyle;
                toEdgePosition: (line: LinePosition) => EdgePosition;
                calculateCenterPoint: (state: {
                    id: string;
                    line: Line;
                    selectable: number | boolean;
                    selected: boolean;
                    hovered: boolean;
                    origin: {
                        p1: {
                            x: number;
                            y: number;
                        };
                        p2: {
                            x: number;
                            y: number;
                        };
                    };
                    labelPosition: {
                        p1: {
                            x: number;
                            y: number;
                        };
                        p2: {
                            x: number;
                            y: number;
                        };
                    };
                    position: {
                        p1: {
                            x: number;
                            y: number;
                        };
                        p2: {
                            x: number;
                            y: number;
                        };
                    };
                    curve?: {
                        center: {
                            x: number;
                            y: number;
                            add: (v: Point2D) => Vector2D;
                            subtract: (v: Point2D) => Vector2D;
                            multiply: (v: Point2D) => Vector2D;
                            multiplyScalar: (scalar: number) => Vector2D;
                            divide: (v: Point2D) => Vector2D;
                            dot: (v: Point2D) => number;
                            cross: (v: Point2D) => number;
                            lengthSquared: () => number;
                            length: () => number;
                            distanceSquared: (v: Point2D) => number;
                            distance: (v: Point2D) => number;
                            normalize: () => Vector2D;
                            angle: () => number;
                            angleDegree: () => number;
                            rotate: (angle: number) => Vector2D;
                            isEqualTo: (v: Point2D) => boolean;
                            clone: () => Vector2D;
                            toObject: () => Point2D;
                            toArray: () => [number, number];
                        };
                        theta: number;
                        circle: {
                            center: {
                                x: number;
                                y: number;
                                add: (v: Point2D) => Vector2D;
                                subtract: (v: Point2D) => Vector2D;
                                multiply: (v: Point2D) => Vector2D;
                                multiplyScalar: (scalar: number) => Vector2D;
                                divide: (v: Point2D) => Vector2D;
                                dot: (v: Point2D) => number;
                                cross: (v: Point2D) => number;
                                lengthSquared: () => number;
                                length: () => number;
                                distanceSquared: (v: Point2D) => number;
                                distance: (v: Point2D) => number;
                                normalize: () => Vector2D;
                                angle: () => number;
                                angleDegree: () => number;
                                rotate: (angle: number) => Vector2D;
                                isEqualTo: (v: Point2D) => boolean;
                                clone: () => Vector2D;
                                toObject: () => Point2D;
                                toArray: () => [number, number];
                            };
                            radius: number;
                        };
                        control: {
                            x: number;
                            y: number;
                        }[];
                    } | undefined;
                    loop?: {
                        center: {
                            x: number;
                            y: number;
                            add: (v: Point2D) => Vector2D;
                            subtract: (v: Point2D) => Vector2D;
                            multiply: (v: Point2D) => Vector2D;
                            multiplyScalar: (scalar: number) => Vector2D;
                            divide: (v: Point2D) => Vector2D;
                            dot: (v: Point2D) => number;
                            cross: (v: Point2D) => number;
                            lengthSquared: () => number;
                            length: () => number;
                            distanceSquared: (v: Point2D) => number;
                            distance: (v: Point2D) => number;
                            normalize: () => Vector2D;
                            angle: () => number;
                            angleDegree: () => number;
                            rotate: (angle: number) => Vector2D;
                            isEqualTo: (v: Point2D) => boolean;
                            clone: () => Vector2D;
                            toObject: () => Point2D;
                            toArray: () => [number, number];
                        };
                        radius: [number, number];
                        isLargeArc: boolean;
                        isClockwise: boolean;
                    } | undefined;
                    sourceMarkerId?: string | undefined;
                    targetMarkerId?: string | undefined;
                    zIndex: number;
                    stopWatchHandle: WatchStopHandle;
                }) => Point;
                getPathTotalLength: () => number;
                calculatePointAtLength: (distance: number) => Point;
            }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
                edgeId: {
                    type: StringConstructor;
                    required: false;
                    default: undefined;
                };
                edge: {
                    type: null;
                    required: false;
                    default: undefined;
                };
                edges: {
                    type: null;
                    required: false;
                    default: () => {};
                };
                state: {
                    type: null;
                    required: true;
                };
                isSummarized: {
                    type: BooleanConstructor;
                    required: true;
                };
            }>>, {
                edges: any;
                edge: any;
                edgeId: string;
            }>;
        }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
            hasEdgeOverlaySlot: {
                type: BooleanConstructor;
                required: true;
            };
        }>>, {}>;
    }, {}, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{}>>, {}>;
    VEdgeLabelsLayer: DefineComponent<{
        enableEdgeLabel: {
            type: BooleanConstructor;
            required: true;
            default: boolean;
        };
        enableEdgesLabel: {
            type: BooleanConstructor;
            required: true;
            default: boolean;
        };
    }, {
        VEdgeLabels: DefineComponent<{
            enableEdgeLabel: {
                type: BooleanConstructor;
                required: true;
                default: boolean;
            };
            enableEdgesLabel: {
                type: BooleanConstructor;
                required: true;
                default: boolean;
            };
        }, {
            edgeConfig: EdgeConfig<Edge>;
            edgeStates: EdgeStates;
            edgeGroupStates: EdgeGroupStates;
            summarizedEdgeStates: SummarizedEdgeStates;
            edgeGroups: ComputedRef<{
                individual: Record<string, EdgeGroup>;
                summarized: Record<string, EdgeGroup>;
            }>;
            getRepresentativeEdgeKey: (group: EdgeGroup) => string;
            VEdgeLabelPlace: DefineComponent<{
                edgeId: {
                    type: StringConstructor;
                    required: true;
                };
                edge: {
                    type: null;
                    required: true;
                };
                config: {
                    type: null;
                    required: true;
                };
                state: {
                    type: null;
                    required: true;
                };
            }, {
                props: any;
                scale: Ref<number>;
                area: ComputedRef<EdgeLabelArea>;
            }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
                edgeId: {
                    type: StringConstructor;
                    required: true;
                };
                edge: {
                    type: null;
                    required: true;
                };
                config: {
                    type: null;
                    required: true;
                };
                state: {
                    type: null;
                    required: true;
                };
            }>>, {}>;
            VEdgeLabelsPlace: DefineComponent<{
                edges: {
                    type: null;
                    required: true;
                };
                config: {
                    type: null;
                    required: true;
                };
                state: {
                    type: null;
                    required: true;
                };
                summarizeState: {
                    type: null;
                    required: false;
                };
            }, {
                props: any;
                scale: Ref<number>;
                area: ComputedRef<EdgeLabelArea>;
            }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
                edges: {
                    type: null;
                    required: true;
                };
                config: {
                    type: null;
                    required: true;
                };
                state: {
                    type: null;
                    required: true;
                };
                summarizeState: {
                    type: null;
                    required: false;
                };
            }>>, {}>;
        }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
            enableEdgeLabel: {
                type: BooleanConstructor;
                required: true;
                default: boolean;
            };
            enableEdgesLabel: {
                type: BooleanConstructor;
                required: true;
                default: boolean;
            };
        }>>, {}>;
    }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
        enableEdgeLabel: {
            type: BooleanConstructor;
            required: true;
            default: boolean;
        };
        enableEdgesLabel: {
            type: BooleanConstructor;
            required: true;
            default: boolean;
        };
    }>>, {}>;
    VFocusringLayer: DefineComponent<{}, {
        nodeStates: NodeStates;
        selectedNodes: Reactive<Set<string>>;
        layouts: Layouts;
        VNodeFocusRing: DefineComponent<{
            id: {
                type: StringConstructor;
                required: true;
            };
            state: {
                type: null;
                required: true;
            };
            pos: {
                type: null;
                required: true;
                default: undefined;
            };
        }, {
            props: any;
            x: ComputedRef<number>;
            y: ComputedRef<number>;
            config: NodeConfig<Node>;
            shapeConfig: {
                type: ShapeType;
                radius: number;
                strokeWidth: number;
                strokeColor?: string | undefined;
                strokeDasharray?: string | number | undefined;
                color: string;
                width: number;
                height: number;
                borderRadius: number;
            };
            VShape: DefineComponent<{
                baseX: {
                    type: NumberConstructor;
                    required: false;
                    default: number;
                };
                baseY: {
                    type: NumberConstructor;
                    required: false;
                    default: number;
                };
                config: {
                    type: null;
                    required: true;
                };
            }, {
                props: any;
                scale: Ref<number>;
                x: Ref<number>;
                y: Ref<number>;
                strokeWidth: Ref<number>;
                strokeColor: Ref<string>;
                strokeDasharray: Ref<string | number | undefined>;
                radius: Ref<number>;
                width: Ref<number>;
                height: Ref<number>;
                borderRadius: Ref<number>;
            }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
                baseX: {
                    type: NumberConstructor;
                    required: false;
                    default: number;
                };
                baseY: {
                    type: NumberConstructor;
                    required: false;
                    default: number;
                };
                config: {
                    type: null;
                    required: true;
                };
            }>>, {
                baseX: number;
                baseY: number;
            }>;
        }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
            id: {
                type: StringConstructor;
                required: true;
            };
            state: {
                type: null;
                required: true;
            };
            pos: {
                type: null;
                required: true;
                default: undefined;
            };
        }>>, {
            pos: any;
        }>;
    }, {}, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{}>>, {}>;
    VNodesLayer: DefineComponent<{}, {
        slots: Readonly<{
            [name: string]: Slot | undefined;
        }>;
        hasOverrideNodeSlot: ComputedRef<boolean>;
        nodeZOrderedList: ComputedRef<{
            id: string;
            shape: ShapeStyle;
            staticShape: ShapeStyle;
            label: NodeLabelStyle;
            labelText: string;
            selected: boolean;
            hovered: boolean;
            draggable: boolean;
            selectable: number | boolean;
            zIndex: number;
            oppositeNodeIds: Record<string, string>;
            oppositeNodes: Record<string, OppositeNode>;
        }[]>;
        configs: NodeConfig<Node>;
        layouts: Layouts;
        VNode: DefineComponent<{
            id: {
                type: StringConstructor;
                required: true;
            };
            state: {
                type: null;
                required: true;
            };
            pos: {
                type: null;
                required: false;
                default: undefined;
            };
        }, {
            props: any;
            x: ComputedRef<number>;
            y: ComputedRef<number>;
            scale: Ref<number>;
            handleNodePointerDownEvent: (node: string, event: PointerEvent) => void;
            handleNodePointerOverEvent: (node: string, event: PointerEvent) => void;
            handleNodePointerOutEvent: (node: string, event: PointerEvent) => void;
            handleNodeClickEvent: (node: string, event: MouseEvent) => void;
            handleNodeDoubleClickEvent: (node: string, event: MouseEvent) => void;
            handleNodeContextMenu: (node: string, event: MouseEvent) => void;
            VShape: DefineComponent<{
                baseX: {
                    type: NumberConstructor;
                    required: false;
                    default: number;
                };
                baseY: {
                    type: NumberConstructor;
                    required: false;
                    default: number;
                };
                config: {
                    type: null;
                    required: true;
                };
            }, {
                props: any;
                scale: Ref<number>;
                x: Ref<number>;
                y: Ref<number>;
                strokeWidth: Ref<number>;
                strokeColor: Ref<string>;
                strokeDasharray: Ref<string | number | undefined>;
                radius: Ref<number>;
                width: Ref<number>;
                height: Ref<number>;
                borderRadius: Ref<number>;
            }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
                baseX: {
                    type: NumberConstructor;
                    required: false;
                    default: number;
                };
                baseY: {
                    type: NumberConstructor;
                    required: false;
                    default: number;
                };
                config: {
                    type: null;
                    required: true;
                };
            }>>, {
                baseX: number;
                baseY: number;
            }>;
        }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
            id: {
                type: StringConstructor;
                required: true;
            };
            state: {
                type: null;
                required: true;
            };
            pos: {
                type: null;
                required: false;
                default: undefined;
            };
        }>>, {
            pos: any;
        }>;
    }, {}, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{}>>, {}>;
    VNodeLabelsLayer: DefineComponent<{}, {
        slots: Readonly<{
            [name: string]: Slot | undefined;
        }>;
        hasOverrideNodeLabelSlot: ComputedRef<boolean>;
        nodeZOrderedList: ComputedRef<{
            id: string;
            shape: ShapeStyle;
            staticShape: ShapeStyle;
            label: NodeLabelStyle;
            labelText: string;
            selected: boolean;
            hovered: boolean;
            draggable: boolean;
            selectable: number | boolean;
            zIndex: number;
            oppositeNodeIds: Record<string, string>;
            oppositeNodes: Record<string, OppositeNode>;
        }[]>;
        configs: NodeConfig<Node>;
        layouts: Layouts;
        nodeStates: ComputedRef<{
            id: string;
            shape: ShapeStyle;
            staticShape: ShapeStyle;
            label: NodeLabelStyle;
            labelText: string;
            selected: boolean;
            hovered: boolean;
            draggable: boolean;
            selectable: number | boolean;
            zIndex: number;
            oppositeNodeIds: Record<string, string>;
            oppositeNodes: Record<string, OppositeNode>;
        }[]>;
        onlyHasDisplayLabel: (nodeZOrderedList: {
            id: string;
            shape: ShapeStyle;
            staticShape: ShapeStyle;
            label: NodeLabelStyle;
            labelText: string;
            selected: boolean;
            hovered: boolean;
            draggable: boolean;
            selectable: number | boolean;
            zIndex: number;
            oppositeNodeIds: Record<string, string>;
            oppositeNodes: Record<string, OppositeNode>;
        }[]) => {
            id: string;
            shape: ShapeStyle;
            staticShape: ShapeStyle;
            label: NodeLabelStyle;
            labelText: string;
            selected: boolean;
            hovered: boolean;
            draggable: boolean;
            selectable: number | boolean;
            zIndex: number;
            oppositeNodeIds: Record<string, string>;
            oppositeNodes: Record<string, OppositeNode>;
        }[];
        VNodeLabel: DefineComponent<{
            id: {
                type: StringConstructor;
                required: true;
            };
            state: {
                type: null;
                required: true;
            };
            pos: {
                type: null;
                required: false;
                default: undefined;
            };
        }, {
            props: any;
            configs: NodeConfig<Node>;
            edgeStates: EdgeStates;
            scale: Ref<number>;
            handleNodePointerDownEvent: (node: string, event: PointerEvent) => void;
            handleNodePointerOverEvent: (node: string, event: PointerEvent) => void;
            handleNodePointerOutEvent: (node: string, event: PointerEvent) => void;
            handleNodeClickEvent: (node: string, event: MouseEvent) => void;
            handleNodeDoubleClickEvent: (node: string, event: MouseEvent) => void;
            handleNodeContextMenu: (node: string, event: MouseEvent) => void;
            x: ComputedRef<number>;
            y: ComputedRef<number>;
            labelMargin: ComputedRef<number>;
            labelShiftV: Ref<number>;
            labelShiftH: Ref<number>;
            labelDiagonalShiftV: Ref<number>;
            labelDiagonalShiftH: Ref<number>;
            labelDirection: ComputedRef<NodeLabelDirectionType>;
            textAnchor: ComputedRef<"middle" | "start" | "end">;
            dominantBaseline: ComputedRef<"central" | "text-top" | "hanging">;
            labelX: ComputedRef<number>;
            labelY: ComputedRef<number>;
            eventHandlers: ComputedRef<(id: string) => {
                pointerdown: (e: PointerEvent) => void;
                pointerenter: (e: PointerEvent) => void;
                pointerleave: (e: PointerEvent) => void;
                click: (e: MouseEvent) => void;
                dblclick: (e: MouseEvent) => void;
                contextmenu: (e: MouseEvent) => void;
            } | {
                pointerdown?: undefined;
                pointerenter?: undefined;
                pointerleave?: undefined;
                click?: undefined;
                dblclick?: undefined;
                contextmenu?: undefined;
            }>;
            groupClasses: ComputedRef<{
                "v-ng-node-label": boolean;
                hover: boolean;
                selected: boolean;
            }>;
            labelClasses: ComputedRef<{
                draggable: boolean;
                selectable: number | boolean;
            }>;
            VLabelText: DefineComponent<{
                text: {
                    type: StringConstructor;
                    required: true;
                };
                x: {
                    type: NumberConstructor;
                    required: false;
                    default: number;
                };
                y: {
                    type: NumberConstructor;
                    required: false;
                    default: number;
                };
                dominantBaseline: {
                    type: StringConstructor;
                    required: false;
                    default: string;
                };
                config: {
                    type: null;
                    required: true;
                };
            }, {
                props: any;
                attrs: {
                    [x: string]: unknown;
                };
                scale: Ref<number>;
                texts: ComputedRef<string[]>;
                fontSize: ComputedRef<number>;
                lineHeight: ComputedRef<number>;
                topDeltaY: ComputedRef<number>;
                element: Ref<SVGTextElement | undefined>;
                transform: Ref<string>;
                pos: {
                    x: number;
                    y: number;
                    width: number;
                    height: number;
                };
                backgroundRectPos: ComputedRef<{
                    x: number;
                    y: number;
                    width: number;
                    height: number;
                }>;
                observer: MutationObserver | undefined;
                updateObserver: () => void;
                updateBackgroundPosition: (element: SVGTextElement, pos: {
                    x: number;
                    y: number;
                    width: number;
                    height: number;
                }, transform: Ref<string | undefined>) => void;
                enableMutationObserver: (element: SVGTextElement, pos: {
                    x: number;
                    y: number;
                    width: number;
                    height: number;
                }, transform: Ref<string | undefined>) => MutationObserver;
            }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
                text: {
                    type: StringConstructor;
                    required: true;
                };
                x: {
                    type: NumberConstructor;
                    required: false;
                    default: number;
                };
                y: {
                    type: NumberConstructor;
                    required: false;
                    default: number;
                };
                dominantBaseline: {
                    type: StringConstructor;
                    required: false;
                    default: string;
                };
                config: {
                    type: null;
                    required: true;
                };
            }>>, {
                x: number;
                y: number;
                dominantBaseline: string;
            }>;
        }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
            id: {
                type: StringConstructor;
                required: true;
            };
            state: {
                type: null;
                required: true;
            };
            pos: {
                type: null;
                required: false;
                default: undefined;
            };
        }>>, {
            pos: any;
        }>;
    }, {}, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{}>>, {}>;
    VPathsLayer: DefineComponent<{}, {
        VPaths: DefineComponent<{}, {
            pathZOrderedList: ComputedRef<{
                id: string;
                selected: boolean;
                hovered: boolean;
                selectable: number | boolean;
                zIndex: number;
                clickable: boolean;
                hoverable: boolean;
                path: {
                    [x: string]: any;
                    id?: string | undefined;
                    edges: string[];
                };
                edges: EdgeObject[];
            }[]>;
            pathConfig: PathConfig<Path>;
            handlePathPointerDownEvent: (path: string, event: PointerEvent) => void;
            handlePathPointerOverEvent: (path: string, event: PointerEvent) => void;
            handlePathPointerOutEvent: (path: string, event: PointerEvent) => void;
            handlePathClickEvent: (path: string, event: MouseEvent) => void;
            handlePathDoubleClickEvent: (path: string, event: MouseEvent) => void;
            handlePathContextMenu: (path: string, event: MouseEvent) => void;
            VPath: DefineComponent<{
                path: {
                    type: null;
                    required: true;
                };
            }, {
                props: any;
                nodeStates: NodeStates;
                edgeStates: EdgeStates;
                layouts: Layouts;
                scale: Ref<number>;
                pathConfig: PathConfig<Path>;
                calcPathPoints: (path: {
                    id: string;
                    selected: boolean;
                    hovered: boolean;
                    selectable: number | boolean;
                    zIndex: number;
                    clickable: boolean;
                    hoverable: boolean;
                    path: {
                        [x: string]: any;
                        id?: string | undefined;
                        edges: string[];
                    };
                    edges: EdgeObject[];
                }) => PositionOrCurve[];
                calcPathD: (path: {
                    id: string;
                    selected: boolean;
                    hovered: boolean;
                    selectable: number | boolean;
                    zIndex: number;
                    clickable: boolean;
                    hoverable: boolean;
                    path: {
                        [x: string]: any;
                        id?: string | undefined;
                        edges: string[];
                    };
                    edges: EdgeObject[];
                }) => string;
                config: ComputedRef<PathStrokeStyle>;
                strokeDasharray: ComputedRef<string | number | undefined>;
                animationSpeed: ComputedRef<string | undefined>;
            }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
                path: {
                    type: null;
                    required: true;
                };
            }>>, {}>;
        }, {}, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{}>>, {}>;
    }, {}, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, {}, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{}>>, {}>;
}, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, ("update:zoomLevel" | "update:selectedNodes" | "update:selectedEdges" | "update:selectedPaths" | "update:layouts")[], "update:zoomLevel" | "update:selectedNodes" | "update:selectedEdges" | "update:selectedPaths" | "update:layouts", VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
    nodes: {
        type: null;
        required: false;
        default: () => {};
    };
    edges: {
        type: null;
        required: false;
        default: () => {};
    };
    paths: {
        type: null;
        required: false;
        default: () => {};
    };
    layouts: {
        type: null;
        required: false;
        default: () => {};
    };
    zoomLevel: {
        type: NumberConstructor;
        required: false;
        default: number;
    };
    selectedNodes: {
        type: ArrayConstructor;
        required: false;
        default: () => never[];
    };
    selectedEdges: {
        type: ArrayConstructor;
        required: false;
        default: () => never[];
    };
    selectedPaths: {
        type: ArrayConstructor;
        required: false;
        default: () => never[];
    };
    configs: {
        type: null;
        required: false;
        default: () => {};
    };
    layers: {
        type: null;
        required: false;
        default: () => {};
    };
    eventHandlers: {
        type: null;
        required: false;
        default: () => {};
    };
}>> & {
    "onUpdate:zoomLevel"?: ((...args: any[]) => any) | undefined;
    "onUpdate:selectedNodes"?: ((...args: any[]) => any) | undefined;
    "onUpdate:selectedEdges"?: ((...args: any[]) => any) | undefined;
    "onUpdate:selectedPaths"?: ((...args: any[]) => any) | undefined;
    "onUpdate:layouts"?: ((...args: any[]) => any) | undefined;
}, {
    nodes: any;
    edges: any;
    paths: any;
    layouts: any;
    zoomLevel: number;
    selectedNodes: unknown[];
    selectedEdges: unknown[];
    selectedPaths: unknown[];
    configs: any;
    layers: any;
    eventHandlers: any;
}>;
export default _sfc_main;
