var dr = Object.defineProperty, fr = Object.defineProperties;
var hr = Object.getOwnPropertyDescriptors;
var qn = Object.getOwnPropertySymbols;
var vr = Object.prototype.hasOwnProperty, pr = Object.prototype.propertyIsEnumerable;
var ce = Math.pow, Kn = (e, t, n) => t in e ? dr(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, se = (e, t) => {
  for (var n in t || (t = {}))
    vr.call(t, n) && Kn(e, n, t[n]);
  if (qn)
    for (var n of qn(t))
      pr.call(t, n) && Kn(e, n, t[n]);
  return e;
}, st = (e, t) => fr(e, hr(t));
var Re = (e, t, n) => new Promise((o, i) => {
  var r = (l) => {
    try {
      a(n.next(l));
    } catch (u) {
      i(u);
    }
  }, s = (l) => {
    try {
      a(n.throw(l));
    } catch (u) {
      i(u);
    }
  }, a = (l) => l.done ? o(l.value) : Promise.resolve(l.value).then(r, s);
  a((n = n.apply(e, t)).next());
});
import { isReactive as gr, reactive as Ce, provide as je, inject as Be, watch as G, toRef as Te, watchEffect as me, computed as O, unref as y, ref as Z, onMounted as rt, onUnmounted as bt, nextTick as Ct, defineComponent as W, openBlock as M, createElementBlock as I, createBlock as H, resolveDynamicComponent as mr, createCommentVNode as ue, Fragment as X, renderList as ee, mergeProps as Se, renderSlot as K, normalizeClass as pe, withModifiers as Ee, normalizeStyle as yt, useAttrs as br, createElementVNode as Vo, createTextVNode as yr, toDisplayString as Yn, createVNode as Fe, withCtx as ne, normalizeProps as de, guardReactiveProps as fe, useSlots as jt, createSlots as Wo, TransitionGroup as ht, toHandlers as wr, readonly as at } from "vue";
const xr = [
  "paths",
  "node-labels",
  "nodes",
  "focusring",
  "edge-labels",
  "edges",
  "base",
  "grid",
  "background",
  "root"
];
function Ae(e) {
  return gr(e) ? e : Ce(e);
}
function q(e, t = "Parameter") {
  if (e == null)
    throw new Error(`${t} is null`);
  return e;
}
const Fo = Symbol("containers");
function Er(e) {
  je(Fo, e);
}
function En() {
  const e = q(Be(Fo), "containers");
  return {
    container: e.container,
    svg: e.svg,
    viewport: e.viewport,
    svgPanZoom: e.svgPanZoom
  };
}
function Pr() {
  this.__data__ = [], this.size = 0;
}
function wt(e, t) {
  return e === t || e !== e && t !== t;
}
function Bt(e, t) {
  for (var n = e.length; n--; )
    if (wt(e[n][0], t))
      return n;
  return -1;
}
var Sr = Array.prototype, kr = Sr.splice;
function Mr(e) {
  var t = this.__data__, n = Bt(t, e);
  if (n < 0)
    return !1;
  var o = t.length - 1;
  return n == o ? t.pop() : kr.call(t, n, 1), --this.size, !0;
}
function Tr(e) {
  var t = this.__data__, n = Bt(t, e);
  return n < 0 ? void 0 : t[n][1];
}
function Or(e) {
  return Bt(this.__data__, e) > -1;
}
function Cr(e, t) {
  var n = this.__data__, o = Bt(n, e);
  return o < 0 ? (++this.size, n.push([e, t])) : n[o][1] = t, this;
}
function $e(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var o = e[t];
    this.set(o[0], o[1]);
  }
}
$e.prototype.clear = Pr;
$e.prototype.delete = Mr;
$e.prototype.get = Tr;
$e.prototype.has = Or;
$e.prototype.set = Cr;
function $r() {
  this.__data__ = new $e(), this.size = 0;
}
function _r(e) {
  var t = this.__data__, n = t.delete(e);
  return this.size = t.size, n;
}
function zr(e) {
  return this.__data__.get(e);
}
function Ir(e) {
  return this.__data__.has(e);
}
var Ar = typeof global == "object" && global && global.Object === Object && global;
const Uo = Ar;
var Lr = typeof self == "object" && self && self.Object === Object && self, Nr = Uo || Lr || Function("return this")();
const xe = Nr;
var Dr = xe.Symbol;
const De = Dr;
var Go = Object.prototype, Zr = Go.hasOwnProperty, jr = Go.toString, lt = De ? De.toStringTag : void 0;
function Br(e) {
  var t = Zr.call(e, lt), n = e[lt];
  try {
    e[lt] = void 0;
    var o = !0;
  } catch (r) {
  }
  var i = jr.call(e);
  return o && (t ? e[lt] = n : delete e[lt]), i;
}
var Rr = Object.prototype, Hr = Rr.toString;
function Vr(e) {
  return Hr.call(e);
}
var Wr = "[object Null]", Fr = "[object Undefined]", Qn = De ? De.toStringTag : void 0;
function Xe(e) {
  return e == null ? e === void 0 ? Fr : Wr : Qn && Qn in Object(e) ? Br(e) : Vr(e);
}
function ke(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var Ur = "[object AsyncFunction]", Gr = "[object Function]", Xr = "[object GeneratorFunction]", qr = "[object Proxy]";
function Pn(e) {
  if (!ke(e))
    return !1;
  var t = Xe(e);
  return t == Gr || t == Xr || t == Ur || t == qr;
}
var Kr = xe["__core-js_shared__"];
const en = Kr;
var Jn = function() {
  var e = /[^.]+$/.exec(en && en.keys && en.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function Yr(e) {
  return !!Jn && Jn in e;
}
var Qr = Function.prototype, Jr = Qr.toString;
function qe(e) {
  if (e != null) {
    try {
      return Jr.call(e);
    } catch (t) {
    }
    try {
      return e + "";
    } catch (t) {
    }
  }
  return "";
}
var es = /[\\^$.*+?()[\]{}|]/g, ts = /^\[object .+?Constructor\]$/, ns = Function.prototype, os = Object.prototype, is = ns.toString, rs = os.hasOwnProperty, ss = RegExp(
  "^" + is.call(rs).replace(es, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function as(e) {
  if (!ke(e) || Yr(e))
    return !1;
  var t = Pn(e) ? ss : ts;
  return t.test(qe(e));
}
function ls(e, t) {
  return e == null ? void 0 : e[t];
}
function Ke(e, t) {
  var n = ls(e, t);
  return as(n) ? n : void 0;
}
var cs = Ke(xe, "Map");
const vt = cs;
var us = Ke(Object, "create");
const pt = us;
function ds() {
  this.__data__ = pt ? pt(null) : {}, this.size = 0;
}
function fs(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var hs = "__lodash_hash_undefined__", vs = Object.prototype, ps = vs.hasOwnProperty;
function gs(e) {
  var t = this.__data__;
  if (pt) {
    var n = t[e];
    return n === hs ? void 0 : n;
  }
  return ps.call(t, e) ? t[e] : void 0;
}
var ms = Object.prototype, bs = ms.hasOwnProperty;
function ys(e) {
  var t = this.__data__;
  return pt ? t[e] !== void 0 : bs.call(t, e);
}
var ws = "__lodash_hash_undefined__";
function xs(e, t) {
  var n = this.__data__;
  return this.size += this.has(e) ? 0 : 1, n[e] = pt && t === void 0 ? ws : t, this;
}
function Ue(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var o = e[t];
    this.set(o[0], o[1]);
  }
}
Ue.prototype.clear = ds;
Ue.prototype.delete = fs;
Ue.prototype.get = gs;
Ue.prototype.has = ys;
Ue.prototype.set = xs;
function Es() {
  this.size = 0, this.__data__ = {
    hash: new Ue(),
    map: new (vt || $e)(),
    string: new Ue()
  };
}
function Ps(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function Rt(e, t) {
  var n = e.__data__;
  return Ps(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
function Ss(e) {
  var t = Rt(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function ks(e) {
  return Rt(this, e).get(e);
}
function Ms(e) {
  return Rt(this, e).has(e);
}
function Ts(e, t) {
  var n = Rt(this, e), o = n.size;
  return n.set(e, t), this.size += n.size == o ? 0 : 1, this;
}
function Ye(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var o = e[t];
    this.set(o[0], o[1]);
  }
}
Ye.prototype.clear = Es;
Ye.prototype.delete = Ss;
Ye.prototype.get = ks;
Ye.prototype.has = Ms;
Ye.prototype.set = Ts;
var Os = 200;
function Cs(e, t) {
  var n = this.__data__;
  if (n instanceof $e) {
    var o = n.__data__;
    if (!vt || o.length < Os - 1)
      return o.push([e, t]), this.size = ++n.size, this;
    n = this.__data__ = new Ye(o);
  }
  return n.set(e, t), this.size = n.size, this;
}
function Oe(e) {
  var t = this.__data__ = new $e(e);
  this.size = t.size;
}
Oe.prototype.clear = $r;
Oe.prototype.delete = _r;
Oe.prototype.get = zr;
Oe.prototype.has = Ir;
Oe.prototype.set = Cs;
var $s = function() {
  try {
    var e = Ke(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch (t) {
  }
}();
const zt = $s;
function Sn(e, t, n) {
  t == "__proto__" && zt ? zt(e, t, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : e[t] = n;
}
function un(e, t, n) {
  (n !== void 0 && !wt(e[t], n) || n === void 0 && !(t in e)) && Sn(e, t, n);
}
function _s(e) {
  return function(t, n, o) {
    for (var i = -1, r = Object(t), s = o(t), a = s.length; a--; ) {
      var l = s[e ? a : ++i];
      if (n(r[l], l, r) === !1)
        break;
    }
    return t;
  };
}
var zs = _s();
const Is = zs;
var Xo = typeof exports == "object" && exports && !exports.nodeType && exports, eo = Xo && typeof module == "object" && module && !module.nodeType && module, As = eo && eo.exports === Xo, to = As ? xe.Buffer : void 0, no = to ? to.allocUnsafe : void 0;
function Ls(e, t) {
  if (t)
    return e.slice();
  var n = e.length, o = no ? no(n) : new e.constructor(n);
  return e.copy(o), o;
}
var Ns = xe.Uint8Array;
const It = Ns;
function Ds(e) {
  var t = new e.constructor(e.byteLength);
  return new It(t).set(new It(e)), t;
}
function Zs(e, t) {
  var n = t ? Ds(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.length);
}
function js(e, t) {
  var n = -1, o = e.length;
  for (t || (t = Array(o)); ++n < o; )
    t[n] = e[n];
  return t;
}
var oo = Object.create, Bs = function() {
  function e() {
  }
  return function(t) {
    if (!ke(t))
      return {};
    if (oo)
      return oo(t);
    e.prototype = t;
    var n = new e();
    return e.prototype = void 0, n;
  };
}();
const Rs = Bs;
function qo(e, t) {
  return function(n) {
    return e(t(n));
  };
}
var Hs = qo(Object.getPrototypeOf, Object);
const Ko = Hs;
var Vs = Object.prototype;
function kn(e) {
  var t = e && e.constructor, n = typeof t == "function" && t.prototype || Vs;
  return e === n;
}
function Ws(e) {
  return typeof e.constructor == "function" && !kn(e) ? Rs(Ko(e)) : {};
}
function Ze(e) {
  return e != null && typeof e == "object";
}
var Fs = "[object Arguments]";
function io(e) {
  return Ze(e) && Xe(e) == Fs;
}
var Yo = Object.prototype, Us = Yo.hasOwnProperty, Gs = Yo.propertyIsEnumerable, Xs = io(function() {
  return arguments;
}()) ? io : function(e) {
  return Ze(e) && Us.call(e, "callee") && !Gs.call(e, "callee");
};
const dn = Xs;
var qs = Array.isArray;
const Ge = qs;
var Ks = 9007199254740991;
function Qo(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= Ks;
}
function Ht(e) {
  return e != null && Qo(e.length) && !Pn(e);
}
function Ys(e) {
  return Ze(e) && Ht(e);
}
function Qs() {
  return !1;
}
var Jo = typeof exports == "object" && exports && !exports.nodeType && exports, ro = Jo && typeof module == "object" && module && !module.nodeType && module, Js = ro && ro.exports === Jo, so = Js ? xe.Buffer : void 0, ea = so ? so.isBuffer : void 0, ta = ea || Qs;
const At = ta;
var na = "[object Object]", oa = Function.prototype, ia = Object.prototype, ei = oa.toString, ra = ia.hasOwnProperty, sa = ei.call(Object);
function ti(e) {
  if (!Ze(e) || Xe(e) != na)
    return !1;
  var t = Ko(e);
  if (t === null)
    return !0;
  var n = ra.call(t, "constructor") && t.constructor;
  return typeof n == "function" && n instanceof n && ei.call(n) == sa;
}
var aa = "[object Arguments]", la = "[object Array]", ca = "[object Boolean]", ua = "[object Date]", da = "[object Error]", fa = "[object Function]", ha = "[object Map]", va = "[object Number]", pa = "[object Object]", ga = "[object RegExp]", ma = "[object Set]", ba = "[object String]", ya = "[object WeakMap]", wa = "[object ArrayBuffer]", xa = "[object DataView]", Ea = "[object Float32Array]", Pa = "[object Float64Array]", Sa = "[object Int8Array]", ka = "[object Int16Array]", Ma = "[object Int32Array]", Ta = "[object Uint8Array]", Oa = "[object Uint8ClampedArray]", Ca = "[object Uint16Array]", $a = "[object Uint32Array]", Q = {};
Q[Ea] = Q[Pa] = Q[Sa] = Q[ka] = Q[Ma] = Q[Ta] = Q[Oa] = Q[Ca] = Q[$a] = !0;
Q[aa] = Q[la] = Q[wa] = Q[ca] = Q[xa] = Q[ua] = Q[da] = Q[fa] = Q[ha] = Q[va] = Q[pa] = Q[ga] = Q[ma] = Q[ba] = Q[ya] = !1;
function _a(e) {
  return Ze(e) && Qo(e.length) && !!Q[Xe(e)];
}
function za(e) {
  return function(t) {
    return e(t);
  };
}
var ni = typeof exports == "object" && exports && !exports.nodeType && exports, dt = ni && typeof module == "object" && module && !module.nodeType && module, Ia = dt && dt.exports === ni, tn = Ia && Uo.process, Aa = function() {
  try {
    var e = dt && dt.require && dt.require("util").types;
    return e || tn && tn.binding && tn.binding("util");
  } catch (t) {
  }
}();
const ao = Aa;
var lo = ao && ao.isTypedArray, La = lo ? za(lo) : _a;
const Mn = La;
function fn(e, t) {
  if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
    return e[t];
}
var Na = Object.prototype, Da = Na.hasOwnProperty;
function Za(e, t, n) {
  var o = e[t];
  (!(Da.call(e, t) && wt(o, n)) || n === void 0 && !(t in e)) && Sn(e, t, n);
}
function ja(e, t, n, o) {
  var i = !n;
  n || (n = {});
  for (var r = -1, s = t.length; ++r < s; ) {
    var a = t[r], l = o ? o(n[a], e[a], a, n, e) : void 0;
    l === void 0 && (l = e[a]), i ? Sn(n, a, l) : Za(n, a, l);
  }
  return n;
}
function Ba(e, t) {
  for (var n = -1, o = Array(e); ++n < e; )
    o[n] = t(n);
  return o;
}
var Ra = 9007199254740991, Ha = /^(?:0|[1-9]\d*)$/;
function oi(e, t) {
  var n = typeof e;
  return t = t == null ? Ra : t, !!t && (n == "number" || n != "symbol" && Ha.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
var Va = Object.prototype, Wa = Va.hasOwnProperty;
function ii(e, t) {
  var n = Ge(e), o = !n && dn(e), i = !n && !o && At(e), r = !n && !o && !i && Mn(e), s = n || o || i || r, a = s ? Ba(e.length, String) : [], l = a.length;
  for (var u in e)
    (t || Wa.call(e, u)) && !(s && // Safari 9 has enumerable `arguments.length` in strict mode.
    (u == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (u == "offset" || u == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    r && (u == "buffer" || u == "byteLength" || u == "byteOffset") || // Skip index properties.
    oi(u, l))) && a.push(u);
  return a;
}
function Fa(e) {
  var t = [];
  if (e != null)
    for (var n in Object(e))
      t.push(n);
  return t;
}
var Ua = Object.prototype, Ga = Ua.hasOwnProperty;
function Xa(e) {
  if (!ke(e))
    return Fa(e);
  var t = kn(e), n = [];
  for (var o in e)
    o == "constructor" && (t || !Ga.call(e, o)) || n.push(o);
  return n;
}
function ri(e) {
  return Ht(e) ? ii(e, !0) : Xa(e);
}
function qa(e) {
  return ja(e, ri(e));
}
function Ka(e, t, n, o, i, r, s) {
  var a = fn(e, n), l = fn(t, n), u = s.get(l);
  if (u) {
    un(e, n, u);
    return;
  }
  var c = r ? r(a, l, n + "", e, t, s) : void 0, f = c === void 0;
  if (f) {
    var d = Ge(l), v = !d && At(l), x = !d && !v && Mn(l);
    c = l, d || v || x ? Ge(a) ? c = a : Ys(a) ? c = js(a) : v ? (f = !1, c = Ls(l, !0)) : x ? (f = !1, c = Zs(l, !0)) : c = [] : ti(l) || dn(l) ? (c = a, dn(a) ? c = qa(a) : (!ke(a) || Pn(a)) && (c = Ws(l))) : f = !1;
  }
  f && (s.set(l, c), i(c, l, o, r, s), s.delete(l)), un(e, n, c);
}
function Tn(e, t, n, o, i) {
  e !== t && Is(t, function(r, s) {
    if (i || (i = new Oe()), ke(r))
      Ka(e, t, s, n, Tn, o, i);
    else {
      var a = o ? o(fn(e, s), r, s + "", e, t, i) : void 0;
      a === void 0 && (a = r), un(e, s, a);
    }
  }, ri);
}
function si(e) {
  return e;
}
function Ya(e, t, n) {
  switch (n.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, n[0]);
    case 2:
      return e.call(t, n[0], n[1]);
    case 3:
      return e.call(t, n[0], n[1], n[2]);
  }
  return e.apply(t, n);
}
var co = Math.max;
function Qa(e, t, n) {
  return t = co(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var o = arguments, i = -1, r = co(o.length - t, 0), s = Array(r); ++i < r; )
      s[i] = o[t + i];
    i = -1;
    for (var a = Array(t + 1); ++i < t; )
      a[i] = o[i];
    return a[t] = n(s), Ya(e, this, a);
  };
}
function Ja(e) {
  return function() {
    return e;
  };
}
var el = zt ? function(e, t) {
  return zt(e, "toString", {
    configurable: !0,
    enumerable: !1,
    value: Ja(t),
    writable: !0
  });
} : si;
const tl = el;
var nl = 800, ol = 16, il = Date.now;
function rl(e) {
  var t = 0, n = 0;
  return function() {
    var o = il(), i = ol - (o - n);
    if (n = o, i > 0) {
      if (++t >= nl)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
var sl = rl(tl);
const al = sl;
function ll(e, t) {
  return al(Qa(e, t, si), e + "");
}
function ai(e, t, n) {
  if (!ke(n))
    return !1;
  var o = typeof t;
  return (o == "number" ? Ht(n) && oi(t, n.length) : o == "string" && t in n) ? wt(n[t], e) : !1;
}
function li(e) {
  return ll(function(t, n) {
    var o = -1, i = n.length, r = i > 1 ? n[i - 1] : void 0, s = i > 2 ? n[2] : void 0;
    for (r = e.length > 3 && typeof r == "function" ? (i--, r) : void 0, s && ai(n[0], n[1], s) && (r = i < 3 ? void 0 : r, i = 1), t = Object(t); ++o < i; ) {
      var a = n[o];
      a && e(t, a, o, r);
    }
    return t;
  });
}
var cl = li(function(e, t, n) {
  Tn(e, t, n);
});
const ci = cl;
var ul = li(function(e, t, n, o) {
  Tn(e, t, n, o);
});
const dl = ul;
var fl = /\s/;
function hl(e) {
  for (var t = e.length; t-- && fl.test(e.charAt(t)); )
    ;
  return t;
}
var vl = /^\s+/;
function pl(e) {
  return e && e.slice(0, hl(e) + 1).replace(vl, "");
}
var gl = "[object Symbol]";
function ui(e) {
  return typeof e == "symbol" || Ze(e) && Xe(e) == gl;
}
var uo = 0 / 0, ml = /^[-+]0x[0-9a-f]+$/i, bl = /^0b[01]+$/i, yl = /^0o[0-7]+$/i, wl = parseInt;
function Lt(e) {
  if (typeof e == "number")
    return e;
  if (ui(e))
    return uo;
  if (ke(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = ke(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = pl(e);
  var n = bl.test(e);
  return n || yl.test(e) ? wl(e.slice(2), n ? 2 : 8) : ml.test(e) ? uo : +e;
}
var fo = 1 / 0, xl = 17976931348623157e292;
function El(e) {
  if (!e)
    return e === 0 ? e : 0;
  if (e = Lt(e), e === fo || e === -fo) {
    var t = e < 0 ? -1 : 1;
    return t * xl;
  }
  return e === e ? e : 0;
}
function di(e) {
  var t = El(e), n = t % 1;
  return t === t ? n ? t - n : t : 0;
}
function Pl(e, t) {
  for (var n = -1, o = e == null ? 0 : e.length, i = Array(o); ++n < o; )
    i[n] = t(e[n], n, e);
  return i;
}
var Sl = 1 / 0, ho = De ? De.prototype : void 0, vo = ho ? ho.toString : void 0;
function fi(e) {
  if (typeof e == "string")
    return e;
  if (Ge(e))
    return Pl(e, fi) + "";
  if (ui(e))
    return vo ? vo.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -Sl ? "-0" : t;
}
function po(e) {
  return e == null ? "" : fi(e);
}
var kl = xe.isFinite, Ml = Math.min;
function Tl(e) {
  var t = Math[e];
  return function(n, o) {
    if (n = Lt(n), o = o == null ? 0 : Ml(di(o), 292), o && kl(n)) {
      var i = (po(n) + "e").split("e"), r = t(i[0] + "e" + (+i[1] + o));
      return i = (po(r) + "e").split("e"), +(i[0] + "e" + (+i[1] - o));
    }
    return t(n);
  };
}
var Ol = Tl("round");
const go = Ol;
class z {
  static value(t, n) {
    return t instanceof Function ? t(n) : t;
  }
  static values(t, n) {
    return Object.values(t).filter((o) => o instanceof Function).length === 0 ? t : Object.fromEntries(
      Object.entries(t).map(([o, i]) => [o, i instanceof Function ? i(n) : i])
    );
  }
}
var N = /* @__PURE__ */ ((e) => (e.CENTER = "center", e.NORTH = "north", e.NORTH_EAST = "north-east", e.EAST = "east", e.SOUTH_EAST = "south-east", e.SOUTH = "south", e.SOUTH_WEST = "south-west", e.WEST = "west", e.NORTH_WEST = "north-west", e))(N || {});
function nn(e) {
  const t = {};
  return Object.assign(t, e(t));
}
function Af(e) {
  return e;
}
function Lf(e) {
  return e;
}
function mo(e, t, n) {
  const o = z.values(t.normal, e);
  return o.type == "circle" ? {
    width: o.radius * 2 * n,
    height: o.radius * 2 * n
  } : {
    width: o.width * n,
    height: o.height * n
  };
}
function Cl(e, t, n, o) {
  const r = Math.abs(e.x - n.x) < t.width / 2 + o.width / 2, a = Math.abs(e.y - n.y) < t.height / 2 + o.height / 2;
  return r && a;
}
function xt(e, t) {
  let n = 0;
  return t === 1 || e === void 0 || e === "none" ? n = e != null ? e : 0 : typeof e == "string" ? n = e.split(/\s+/).map((o) => parseInt(o) * t).filter((o) => !isNaN(o)).join(" ") : n = e * t, n && n !== "0" ? n : void 0;
}
function Vt(e) {
  let t = 0;
  if (e === void 0 || e === "none")
    t = 0;
  else if (typeof e == "string") {
    const n = e.split(/\s+/).map((o) => parseInt(o)).filter((o) => !isNaN(o));
    n.length % 2 === 0 ? t = n.reduce((o, i) => o + i, 0) : t = n.reduce((o, i) => o + i, 0) * 2;
  } else
    t = e * 2;
  return t;
}
const bo = 20;
class hi {
  activate(t) {
    const { nodePositions: n, nodes: o, configs: i, emitter: r, scale: s, svgPanZoom: a } = t, l = (f) => {
      for (const [d, v] of Object.entries(f)) {
        const x = this.getOrCreateNodePosition(n, d);
        this.setNodePosition(x, v);
      }
    }, u = (f) => {
      const d = f.filter((P) => !(P in n.value)), v = a.getViewArea(), x = s.value;
      for (const P of d) {
        const E = o.value[P], p = mo(E, i.node, x), m = se({}, v.center);
        for (; ; ) {
          let b = !1;
          for (const [h, g] of Object.entries(n.value)) {
            if (P === h)
              continue;
            const k = o.value[h];
            if (!k)
              continue;
            const T = mo(k, i.node, x);
            if (b = Cl(m, p, g, T), b)
              break;
          }
          if (b)
            m.x += p.width + bo * x, m.x + p.width / 2 > v.box.right && (m.x = v.center.x, m.y += p.height + bo * x);
          else
            break;
        }
        const w = this.getOrCreateNodePosition(n, P);
        this.setNodePosition(w, m);
      }
    };
    u(Object.keys(o.value));
    const c = G(() => Object.keys(o.value), u);
    r.on("node:dragstart", l), r.on("node:pointermove", l), r.on("node:dragend", l), this.onDeactivate = () => {
      c(), r.off("node:dragstart", l), r.off("node:pointermove", l), r.off("node:dragend", l);
    };
  }
  deactivate() {
    this.onDeactivate && this.onDeactivate();
  }
  setNodePosition(t, n) {
    t.value.x = go(n.x, 3), t.value.y = go(n.y, 3);
  }
  getOrCreateNodePosition(t, n) {
    const o = Te(t.value, n);
    return o.value || (o.value = { x: 0, y: 0 }), o;
  }
}
function vi() {
  return {
    view: {
      scalingObjects: !1,
      panEnabled: !0,
      zoomEnabled: !0,
      minZoomLevel: 0.1,
      maxZoomLevel: 64,
      doubleClickZoomEnabled: !0,
      mouseWheelZoomEnabled: !0,
      boxSelectionEnabled: !1,
      autoPanAndZoomOnLoad: "center-content",
      autoPanOnResize: !0,
      layoutHandler: new hi(),
      onSvgPanZoomInitialized: void 0,
      grid: {
        visible: !1,
        interval: 10,
        thickIncrements: 5,
        line: {
          color: "#e0e0e0",
          width: 1,
          dasharray: 1
        },
        thick: {
          color: "#cccccc",
          width: 1,
          dasharray: 0
        }
      },
      selection: {
        box: {
          color: "#0000ff20",
          strokeWidth: 1,
          strokeColor: "#aaaaff",
          strokeDasharray: 0
        },
        detector: (e) => {
          const t = /Mac OS/.test(navigator.userAgent) ? e.metaKey : e.ctrlKey;
          return e.type === "keydown" ? t : !t;
        }
      },
      builtInLayerOrder: []
    },
    node: nn((e) => ({
      normal: {
        type: "circle",
        radius: 16,
        // for rect -->
        width: 32,
        height: 32,
        borderRadius: 4,
        // <-- for rect
        color: "#4466cc",
        strokeWidth: 0,
        strokeColor: "#000000",
        strokeDasharray: 0
      },
      hover: {
        type: (t) => z.value(e.normal.type, t),
        radius: (t) => {
          var n;
          return ((n = z.value(e.normal.radius, t)) != null ? n : 0) + 2;
        },
        width: (t) => {
          var n;
          return ((n = z.value(e.normal.width, t)) != null ? n : 0) + 2;
        },
        height: (t) => {
          var n;
          return ((n = z.value(e.normal.height, t)) != null ? n : 0) + 2;
        },
        borderRadius: (t) => {
          var n;
          return (n = z.value(e.normal.borderRadius, t)) != null ? n : 0;
        },
        strokeWidth: (t) => z.value(e.normal.strokeWidth, t),
        strokeColor: (t) => z.value(e.normal.strokeColor, t),
        strokeDasharray: (t) => z.value(e.normal.strokeDasharray, t),
        color: "#3355bb"
      },
      selected: void 0,
      draggable: !0,
      selectable: !1,
      label: {
        visible: !0,
        fontFamily: void 0,
        fontSize: 11,
        lineHeight: 1.1,
        color: "#000000",
        background: void 0,
        // background: {
        //   visible: true,
        //   color: "#ffffff",
        //   padding: {
        //     vertical: 1,
        //     horizontal: 4,
        //   },
        //   borderRadius: 2
        // },
        margin: 4,
        direction: N.SOUTH,
        directionAutoAdjustment: !1,
        text: "name",
        handleNodeEvents: !0
      },
      focusring: {
        visible: !0,
        width: 4,
        padding: 3,
        color: "#eebb00"
      },
      zOrder: {
        enabled: !1,
        zIndex: 0,
        bringToFrontOnHover: !0,
        bringToFrontOnSelected: !0
      },
      transition: void 0
    })),
    edge: nn((e) => ({
      normal: {
        width: 2,
        color: "#4466cc",
        dasharray: 0,
        linecap: "butt",
        animate: !1,
        animationSpeed: 50
      },
      hover: {
        width: (t) => z.value(e.normal.width, t) + 1,
        color: "#3355bb",
        dasharray: (t) => z.value(e.normal.dasharray, t),
        linecap: (t) => z.value(e.normal.linecap, t),
        animate: (t) => z.value(e.normal.animate, t),
        animationSpeed: (t) => z.value(e.normal.animationSpeed, t)
      },
      selected: {
        width: (t) => z.value(e.normal.width, t) + 1,
        color: "#dd8800",
        dasharray: (t) => {
          const n = z.value(e.normal.width, t);
          return `${n * 1.5} ${n * 2}`;
        },
        linecap: (t) => z.value(e.normal.linecap, t),
        animate: (t) => z.value(e.normal.animate, t),
        animationSpeed: (t) => z.value(e.normal.animationSpeed, t)
      },
      selectable: !1,
      gap: 3,
      type: "straight",
      marker: {
        source: {
          type: "none",
          width: 5,
          height: 5,
          margin: -1,
          units: "strokeWidth",
          color: null
        },
        target: {
          type: "none",
          width: 5,
          height: 5,
          margin: -1,
          units: "strokeWidth",
          color: null
        }
      },
      margin: null,
      summarize: (t, n) => n.edge.type == "curve" ? !1 : null,
      summarized: {
        label: {
          fontSize: 10,
          lineHeight: 1,
          color: "#4466cc"
        },
        shape: {
          type: "rect",
          // for circle -->
          radius: 6,
          // <-- for circle
          width: 12,
          height: 12,
          borderRadius: 3,
          color: "#ffffff",
          strokeWidth: 1,
          strokeColor: "#4466cc",
          strokeDasharray: void 0
        },
        stroke: {
          width: 5,
          color: "#4466cc",
          dasharray: void 0,
          linecap: void 0,
          animate: !1,
          animationSpeed: 50
        }
      },
      selfLoop: {
        radius: 12,
        isClockwise: !0,
        offset: 10,
        angle: 270
      },
      keepOrder: "clock",
      label: {
        fontFamily: void 0,
        fontSize: 11,
        lineHeight: 1.1,
        color: "#000000",
        background: void 0,
        // background: {
        //   visible: true,
        //   color: "#ffffff",
        //   padding: {
        //     vertical: 1,
        //     horizontal: 4,
        //   },
        //   borderRadius: 2
        // },
        margin: 4,
        padding: 4
      },
      zOrder: {
        enabled: !1,
        zIndex: 0,
        bringToFrontOnHover: !0,
        bringToFrontOnSelected: !0
      }
    })),
    path: nn((e) => ({
      visible: !1,
      clickable: !1,
      hoverable: !1,
      curveInNode: !1,
      end: "centerOfNode",
      margin: 0,
      // @Deprecated
      path: Ce({
        width: 6,
        color: (t) => {
          const n = [
            "#d5000088",
            "#c5116288",
            "#aa00ff88",
            "#6200ea88",
            "#304ffe88",
            "#2962ff88",
            "#0091ea88",
            "#00b8d488",
            "#00bfa588",
            "#00c85388",
            "#64dd1788",
            "#aeea0088",
            "#ffd60088",
            "#ffab0088",
            "#ff6d0088",
            "#dd2c0088"
          ], o = t.edges.map(
            (i) => i.split("").reduce((r, s) => (r = (r << 5) - r + s.charCodeAt(0), r & r), 0)
          ).reduce((i, r) => i + r, 0);
          return n[Math.abs(o) % n.length];
        },
        dasharray: void 0,
        linecap: "round",
        linejoin: "round",
        animate: !1,
        animationSpeed: 50
      }),
      normal: {
        width: (t) => z.value(e.path.width, t),
        color: (t) => z.value(e.path.color, t),
        dasharray: (t) => z.value(e.path.dasharray, t),
        linecap: (t) => z.value(e.path.linecap, t),
        linejoin: (t) => z.value(e.path.linejoin, t),
        animate: (t) => z.value(e.path.animate, t),
        animationSpeed: (t) => z.value(e.path.animationSpeed, t)
      },
      hover: {
        width: (t) => z.value(e.normal.width, t) + 2,
        color: (t) => z.value(e.normal.color, t),
        dasharray: (t) => z.value(e.normal.dasharray, t),
        linecap: (t) => z.value(e.normal.linecap, t),
        linejoin: (t) => z.value(e.normal.linejoin, t),
        animate: (t) => z.value(e.normal.animate, t),
        animationSpeed: (t) => z.value(e.normal.animationSpeed, t)
      },
      selected: {
        width: (t) => z.value(e.normal.width, t) + 2,
        color: (t) => z.value(e.normal.color, t),
        dasharray: "6 12",
        linecap: (t) => z.value(e.normal.linecap, t),
        linejoin: (t) => z.value(e.normal.linejoin, t),
        animate: (t) => z.value(e.normal.animate, t),
        animationSpeed: (t) => z.value(e.normal.animationSpeed, t)
      },
      selectable: !1,
      zOrder: {
        enabled: !1,
        zIndex: 0,
        bringToFrontOnHover: !0,
        bringToFrontOnSelected: !0
      },
      transition: void 0
    }))
  };
}
function Nf(e) {
  const t = vi();
  return e && ci(t, e), t;
}
const pi = Symbol("style");
function $l(e, t) {
  return ti(e) ? ci(e, t) : t;
}
function _l(e) {
  const t = Ce(vi()), n = Object.keys(t);
  for (const o of n)
    G(() => e.value[o], () => {
      dl(t[o], e.value[o] || {}, $l);
    }, { immediate: !0, deep: !0 });
  return je(pi, t), t;
}
function Wt(e) {
  return q(Be(pi), `Configs(${e})`)[e];
}
function zl() {
  return Wt("view");
}
function Ft() {
  return Wt("node");
}
function Et() {
  return Wt("edge");
}
function gi() {
  return Wt("path");
}
let Il = 1;
function Al() {
  return Il++;
}
var Ll = "__lodash_hash_undefined__";
function Nl(e) {
  return this.__data__.set(e, Ll), this;
}
function Dl(e) {
  return this.__data__.has(e);
}
function gt(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.__data__ = new Ye(); ++t < n; )
    this.add(e[t]);
}
gt.prototype.add = gt.prototype.push = Nl;
gt.prototype.has = Dl;
function Zl(e, t) {
  for (var n = -1, o = e == null ? 0 : e.length; ++n < o; )
    if (t(e[n], n, e))
      return !0;
  return !1;
}
function mi(e, t) {
  return e.has(t);
}
var jl = 1, Bl = 2;
function bi(e, t, n, o, i, r) {
  var s = n & jl, a = e.length, l = t.length;
  if (a != l && !(s && l > a))
    return !1;
  var u = r.get(e), c = r.get(t);
  if (u && c)
    return u == t && c == e;
  var f = -1, d = !0, v = n & Bl ? new gt() : void 0;
  for (r.set(e, t), r.set(t, e); ++f < a; ) {
    var x = e[f], P = t[f];
    if (o)
      var E = s ? o(P, x, f, t, e, r) : o(x, P, f, e, t, r);
    if (E !== void 0) {
      if (E)
        continue;
      d = !1;
      break;
    }
    if (v) {
      if (!Zl(t, function(p, m) {
        if (!mi(v, m) && (x === p || i(x, p, n, o, r)))
          return v.push(m);
      })) {
        d = !1;
        break;
      }
    } else if (!(x === P || i(x, P, n, o, r))) {
      d = !1;
      break;
    }
  }
  return r.delete(e), r.delete(t), d;
}
function Rl(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(o, i) {
    n[++t] = [i, o];
  }), n;
}
function On(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(o) {
    n[++t] = o;
  }), n;
}
var Hl = 1, Vl = 2, Wl = "[object Boolean]", Fl = "[object Date]", Ul = "[object Error]", Gl = "[object Map]", Xl = "[object Number]", ql = "[object RegExp]", Kl = "[object Set]", Yl = "[object String]", Ql = "[object Symbol]", Jl = "[object ArrayBuffer]", ec = "[object DataView]", yo = De ? De.prototype : void 0, on = yo ? yo.valueOf : void 0;
function tc(e, t, n, o, i, r, s) {
  switch (n) {
    case ec:
      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
        return !1;
      e = e.buffer, t = t.buffer;
    case Jl:
      return !(e.byteLength != t.byteLength || !r(new It(e), new It(t)));
    case Wl:
    case Fl:
    case Xl:
      return wt(+e, +t);
    case Ul:
      return e.name == t.name && e.message == t.message;
    case ql:
    case Yl:
      return e == t + "";
    case Gl:
      var a = Rl;
    case Kl:
      var l = o & Hl;
      if (a || (a = On), e.size != t.size && !l)
        return !1;
      var u = s.get(e);
      if (u)
        return u == t;
      o |= Vl, s.set(e, t);
      var c = bi(a(e), a(t), o, i, r, s);
      return s.delete(e), c;
    case Ql:
      if (on)
        return on.call(e) == on.call(t);
  }
  return !1;
}
function nc(e, t) {
  for (var n = -1, o = t.length, i = e.length; ++n < o; )
    e[i + n] = t[n];
  return e;
}
function oc(e, t, n) {
  var o = t(e);
  return Ge(e) ? o : nc(o, n(e));
}
function ic(e, t) {
  for (var n = -1, o = e == null ? 0 : e.length, i = 0, r = []; ++n < o; ) {
    var s = e[n];
    t(s, n, e) && (r[i++] = s);
  }
  return r;
}
function rc() {
  return [];
}
var sc = Object.prototype, ac = sc.propertyIsEnumerable, wo = Object.getOwnPropertySymbols, lc = wo ? function(e) {
  return e == null ? [] : (e = Object(e), ic(wo(e), function(t) {
    return ac.call(e, t);
  }));
} : rc;
const cc = lc;
var uc = qo(Object.keys, Object);
const dc = uc;
var fc = Object.prototype, hc = fc.hasOwnProperty;
function vc(e) {
  if (!kn(e))
    return dc(e);
  var t = [];
  for (var n in Object(e))
    hc.call(e, n) && n != "constructor" && t.push(n);
  return t;
}
function pc(e) {
  return Ht(e) ? ii(e) : vc(e);
}
function xo(e) {
  return oc(e, pc, cc);
}
var gc = 1, mc = Object.prototype, bc = mc.hasOwnProperty;
function yc(e, t, n, o, i, r) {
  var s = n & gc, a = xo(e), l = a.length, u = xo(t), c = u.length;
  if (l != c && !s)
    return !1;
  for (var f = l; f--; ) {
    var d = a[f];
    if (!(s ? d in t : bc.call(t, d)))
      return !1;
  }
  var v = r.get(e), x = r.get(t);
  if (v && x)
    return v == t && x == e;
  var P = !0;
  r.set(e, t), r.set(t, e);
  for (var E = s; ++f < l; ) {
    d = a[f];
    var p = e[d], m = t[d];
    if (o)
      var w = s ? o(m, p, d, t, e, r) : o(p, m, d, e, t, r);
    if (!(w === void 0 ? p === m || i(p, m, n, o, r) : w)) {
      P = !1;
      break;
    }
    E || (E = d == "constructor");
  }
  if (P && !E) {
    var b = e.constructor, h = t.constructor;
    b != h && "constructor" in e && "constructor" in t && !(typeof b == "function" && b instanceof b && typeof h == "function" && h instanceof h) && (P = !1);
  }
  return r.delete(e), r.delete(t), P;
}
var wc = Ke(xe, "DataView");
const hn = wc;
var xc = Ke(xe, "Promise");
const vn = xc;
var Ec = Ke(xe, "Set");
const nt = Ec;
var Pc = Ke(xe, "WeakMap");
const pn = Pc;
var Eo = "[object Map]", Sc = "[object Object]", Po = "[object Promise]", So = "[object Set]", ko = "[object WeakMap]", Mo = "[object DataView]", kc = qe(hn), Mc = qe(vt), Tc = qe(vn), Oc = qe(nt), Cc = qe(pn), He = Xe;
(hn && He(new hn(new ArrayBuffer(1))) != Mo || vt && He(new vt()) != Eo || vn && He(vn.resolve()) != Po || nt && He(new nt()) != So || pn && He(new pn()) != ko) && (He = function(e) {
  var t = Xe(e), n = t == Sc ? e.constructor : void 0, o = n ? qe(n) : "";
  if (o)
    switch (o) {
      case kc:
        return Mo;
      case Mc:
        return Eo;
      case Tc:
        return Po;
      case Oc:
        return So;
      case Cc:
        return ko;
    }
  return t;
});
const To = He;
var $c = 1, Oo = "[object Arguments]", Co = "[object Array]", kt = "[object Object]", _c = Object.prototype, $o = _c.hasOwnProperty;
function zc(e, t, n, o, i, r) {
  var s = Ge(e), a = Ge(t), l = s ? Co : To(e), u = a ? Co : To(t);
  l = l == Oo ? kt : l, u = u == Oo ? kt : u;
  var c = l == kt, f = u == kt, d = l == u;
  if (d && At(e)) {
    if (!At(t))
      return !1;
    s = !0, c = !1;
  }
  if (d && !c)
    return r || (r = new Oe()), s || Mn(e) ? bi(e, t, n, o, i, r) : tc(e, t, l, n, o, i, r);
  if (!(n & $c)) {
    var v = c && $o.call(e, "__wrapped__"), x = f && $o.call(t, "__wrapped__");
    if (v || x) {
      var P = v ? e.value() : e, E = x ? t.value() : t;
      return r || (r = new Oe()), i(P, E, n, o, r);
    }
  }
  return d ? (r || (r = new Oe()), yc(e, t, n, o, i, r)) : !1;
}
function yi(e, t, n, o, i) {
  return e === t ? !0 : e == null || t == null || !Ze(e) && !Ze(t) ? e !== e && t !== t : zc(e, t, n, o, yi, i);
}
function We(e, t) {
  return yi(e, t);
}
function ve(e) {
  return Object.entries(e);
}
function $t(e, t) {
  const n = new Set(Object.keys(e));
  ve(t).forEach(([o, i]) => {
    We(e[o], i) || (e[o] = i), n.delete(o);
  }), n.forEach((o) => delete e[o]);
}
function Ic(e, t, n) {
  const o = Ae({
    edgeLayoutPoints: {},
    edgeGroups: {},
    summarizedEdges: {}
  });
  return me(() => {
    const { edgeLayoutPoints: i, edgeGroups: r } = Lc(
      n,
      e.value,
      t.value
    );
    $t(o.edgeLayoutPoints, i), $t(o.edgeGroups, r);
  }), me(() => {
    const i = {};
    for (const [r, { edges: s, groupWidth: a }] of Object.entries(o.edgeGroups)) {
      let l = !1;
      if (a == 0)
        l = !1;
      else if (n.edge.summarize instanceof Function) {
        const u = n.edge.summarize(s, n);
        u === null ? l = _o(e.value, s, n, a) : l = u;
      } else
        n.edge.summarize ? l = _o(e.value, s, n, a) : l = !1;
      o.edgeGroups[r].summarize = l, l && Object.keys(s).forEach((u) => i[u] = !0);
    }
    $t(o.summarizedEdges, i);
  }), o;
}
function Ac(e, t, n, o, i, r) {
  return e ? t ? zo(e.edge, n, o, i, 0, 0, r) : zo(
    e.edge,
    n,
    o,
    i,
    e.groupWidth,
    e.pointInGroup,
    r
  ) : { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } };
}
function Lc(e, t, n) {
  const o = {}, i = {}, r = {};
  for (const [a, l] of Object.entries(n)) {
    if (!(l.source in t && l.target in t))
      continue;
    const u = [l.source, l.target].sort().join("<=>"), c = r[u] || {};
    c[a] = l, r[u] = c;
  }
  const s = e.edge.gap instanceof Function ? e.edge.gap : (a, l) => e.edge.gap;
  for (const [a, l] of Object.entries(r)) {
    const u = Object.keys(l).length;
    if (u == 0)
      continue;
    const c = s(l, e), [f, d] = Object.entries(l)[0];
    if (u === 1)
      o[f] = { edge: d, pointInGroup: 0, groupWidth: 0 }, i[a] = { edges: l, groupWidth: 0, summarize: !1 };
    else {
      let v = 0;
      const x = Object.entries(l).map(([p, m]) => {
        let w = z.value(e.edge.normal.width, m);
        return isNaN(+w) && (console.warn(
          "[v-network-graph] Edge width is invalid value. id=[%s] value=[%s]",
          p,
          w
        ), w = 1), w / 2;
      }), P = Object.entries(l).map(([p, m], w) => (w > 0 && (v += x[w - 1] + c + x[w]), [p, m, v])), E = v;
      P.forEach(([p, m, w]) => {
        o[p] = { edge: m, pointInGroup: w, groupWidth: E };
      }), i[a] = { edges: l, groupWidth: E, summarize: !1 };
    }
  }
  return { edgeLayoutPoints: o, edgeGroups: i };
}
function _o(e, t, n, o) {
  if (Object.entries(t).length === 1)
    return !1;
  const r = Math.min(
    ...Object.values(t).flatMap((s) => [e[s.source], e[s.target]]).filter((s) => s).map((s) => {
      const a = z.values(n.node.normal, s);
      return a.type === "circle" ? a.radius * 2 : Math.min(a.width, a.height);
    })
  );
  return o > r;
}
function zo(e, t, n, o, i, r, s) {
  var f, d, v, x, P, E, p, m;
  let a, l, u, c;
  return e.source < e.target ? [a, l, u, c] = Io(
    (f = t == null ? void 0 : t.x) != null ? f : 0,
    (d = t == null ? void 0 : t.y) != null ? d : 0,
    (v = n == null ? void 0 : n.x) != null ? v : 0,
    (x = n == null ? void 0 : n.y) != null ? x : 0,
    o,
    i,
    r,
    s
  ) : [u, c, a, l] = Io(
    (P = n == null ? void 0 : n.x) != null ? P : 0,
    (E = n == null ? void 0 : n.y) != null ? E : 0,
    (p = t == null ? void 0 : t.x) != null ? p : 0,
    (m = t == null ? void 0 : t.y) != null ? m : 0,
    o,
    i,
    r,
    s
  ), { p1: { x: a, y: l }, p2: { x: u, y: c } };
}
function Io(e, t, n, o, i, r, s, a) {
  const l = n - e, u = o - t;
  let c = (r / 2 - s) * i;
  if (c !== 0 && a !== "clock") {
    const f = Math.atan2(o - t, n - e);
    if (a === "vertical") {
      const d = Math.PI / 2;
      (f < -d || f >= d) && (c *= -1);
    } else
      a === "horizontal" && f < 0 && (c *= -1);
  }
  if (l === 0) {
    const f = u < 0 ? -1 : 1;
    return [e + c * f, t, n + c * f, o];
  } else if (u === 0) {
    const f = l < 0 ? 1 : -1;
    return [e, t + c * f, n, o + c * f];
  } else {
    const d = -1 / (u / l);
    u < 0 && (c = -c);
    const v = c / Math.sqrt(1 + Math.pow(d, 2));
    return [e + v, t + v * d, n + v, o + v * d];
  }
}
function wi(e, t, n) {
  return n || (n = { x: 0, y: 0 }), n.x = e.x + t.x, n.y = e.y + t.y, n;
}
function Cn(e, t, n) {
  return n || (n = { x: 0, y: 0 }), n.x = e.x - t.x, n.y = e.y - t.y, n;
}
function xi(e, t, n) {
  return n || (n = { x: 0, y: 0 }), n.x = e.x * t.x, n.y = e.y * t.y, n;
}
function Ei(e, t, n) {
  return n || (n = { x: 0, y: 0 }), n.x = e.x * t, n.y = e.y * t, n;
}
function $n(e, t, n) {
  return n || (n = { x: 0, y: 0 }), n.x = e.x / t.x, n.y = e.y / t.y, n;
}
function Pi(e, t) {
  return e.x * t.x + e.y * t.y;
}
function Si(e, t) {
  return e.x * t.y - e.y * t.x;
}
function _n(e) {
  return e.x * e.x + e.y * e.y;
}
function zn(e) {
  return Math.sqrt(_n(e));
}
function In(e, t) {
  const n = e.x - t.x, o = e.y - t.y;
  return n * n + o * o;
}
function ki(e, t) {
  return Math.sqrt(In(e, t));
}
function Mi(e, t) {
  t || (t = { x: 0, y: 0 });
  const n = zn(e);
  return n === 0 ? (t.x = 1, t.y = 0) : $n(e, { x: n, y: n }, t), t;
}
function Nt(e, t, n) {
  n || (n = { x: 0, y: 0 });
  const o = e.x * Math.cos(t) - e.y * Math.sin(t), i = e.x * Math.sin(t) + e.y * Math.cos(t);
  return n.x = o, n.y = i, n;
}
const Nc = 180 / Math.PI;
function Dc(e) {
  return e * Nc;
}
function An(e) {
  return Math.atan2(e.y, e.x);
}
function Ln(e) {
  return Dc(An(e));
}
const Zc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  add: wi,
  angle: An,
  angleDegree: Ln,
  cross: Si,
  distance: ki,
  distanceSquared: In,
  divide: $n,
  dot: Pi,
  length: zn,
  lengthSquared: _n,
  multiply: xi,
  multiplyScalar: Ei,
  normalize: Mi,
  rotate: Nt,
  subtract: Cn
}, Symbol.toStringTag, { value: "Module" }));
class R {
  static fromArray(t) {
    return new R(t[0] || 0, t[1] || 0);
  }
  static fromObject(t) {
    return new R(t.x, t.y);
  }
  constructor(t, n) {
    this.x = t, this.y = n;
  }
  // instance methods
  add(t) {
    return wi(this, t, this);
  }
  subtract(t) {
    return Cn(this, t, this);
  }
  multiply(t) {
    return xi(this, t, this);
  }
  multiplyScalar(t) {
    return Ei(this, t, this);
  }
  divide(t) {
    return $n(this, t, this);
  }
  dot(t) {
    return Pi(this, t);
  }
  cross(t) {
    return Si(this, t);
  }
  lengthSquared() {
    return _n(this);
  }
  length() {
    return zn(this);
  }
  distanceSquared(t) {
    return In(this, t);
  }
  distance(t) {
    return ki(this, t);
  }
  normalize() {
    return Mi(this, this);
  }
  angle() {
    return An(this);
  }
  angleDegree() {
    return Ln(this);
  }
  rotate(t) {
    return Nt(this, t, this);
  }
  isEqualTo(t) {
    return this.x === t.x && this.y === t.y;
  }
  clone() {
    return new R(this.x, this.y);
  }
  toObject() {
    return { x: this.x, y: this.y };
  }
  toArray() {
    return [this.x, this.y];
  }
}
const te = se({
  Vector2D: R
}, Zc);
class J {
  constructor(t, n, o) {
    this.source = t, this.target = n, this.v = o;
  }
  static fromLinePosition(t) {
    const n = R.fromObject(t.p1), o = R.fromObject(t.p2);
    return new J(n, o, ot(n, o));
  }
  static fromPositions(t, n) {
    const o = R.fromObject(t), i = R.fromObject(n);
    return new J(o, i, ot(o, i));
  }
  static fromVectors(t, n) {
    return new J(t, n, ot(t, n));
  }
}
function ot(e, t) {
  return t.clone().subtract(e);
}
function jc(e) {
  return [R.fromObject(e.p1), R.fromObject(e.p2)];
}
function Bc(e) {
  return new R((e.p1.x + e.p2.x) / 2, (e.p1.y + e.p2.y) / 2);
}
function Dt(e, t) {
  return { p1: e, p2: t };
}
function gn(e, t, n) {
  const o = J.fromLinePosition(e);
  return Rc(o, t, n);
}
function Rc(e, t, n) {
  const o = e.v.clone().normalize(), i = e.source.clone().add(o.clone().multiplyScalar(t)), r = e.target.clone().subtract(o.clone().multiplyScalar(n));
  let s = i.toObject(), a = r.toObject();
  const l = ot(i, r);
  if (e.v.angle() * l.angle() < 0) {
    const u = new R((s.x + a.x) / 2, (s.y + a.y) / 2), c = u.clone().add(o.multiplyScalar(0.5));
    s = u.toObject(), a = c.toObject();
  }
  return { p1: s, p2: a };
}
function Hc(e) {
  return { p1: e.p2, p2: e.p1 };
}
function ct(e) {
  const t = e.v.clone().normalize().rotate(Math.PI / 2);
  return J.fromVectors(e.target, e.target.clone().add(t));
}
function Nn(e, t) {
  const n = t.v.clone().normalize(), o = t.source, i = te.subtract(e, o), r = n.dot(i);
  return o.clone().add(n.multiplyScalar(r));
}
function Ut(e, t, n, o) {
  if (!(te.lengthSquared(te.subtract(t, n)) - o * o <= Math.pow(1, -10)))
    return null;
  const s = J.fromVectors(e, t), a = Nn(n, s), l = te.length(te.subtract(a, n));
  if (o < l)
    return null;
  if (o === l)
    return a;
  const u = Math.sqrt(ce(o, 2) - ce(l, 2)), c = s.v.normalize().multiplyScalar(u);
  return a.subtract(c);
}
function Vc(e, t, n, o, i) {
  if (!(te.lengthSquared(te.subtract(t, n)) - o * o <= Math.pow(1, -10)))
    return null;
  const a = J.fromVectors(e, t), l = Nn(n, a), u = te.length(te.subtract(l, n));
  if (o < u)
    return null;
  if (o === u)
    return l;
  const c = Math.sqrt(ce(o, 2) - ce(u, 2)), f = a.v.normalize().multiplyScalar(c), d = l.clone().add(f), v = l.clone().subtract(f), x = i.distance(d), P = i.distance(v);
  return Math.abs(x - P) < 2 ? v : x < P ? d : v;
}
function Ve(e, t) {
  const n = te.subtract(t.source, e.source), o = e.v, i = t.v, r = te.cross(n, o) / te.cross(o, i);
  return t.source.clone().add(i.clone().multiplyScalar(r));
}
function mt(e, t, n, o, i) {
  const r = e, a = n.clone().subtract(r), l = a.length(), u = t + o;
  if (u < l)
    return null;
  const c = Math.abs(t - o);
  if (l < c)
    return null;
  if (l === u) {
    const g = a.clone().normalize(), k = e.clone().add(g.multiplyScalar(t));
    return i ? k : [k, k];
  }
  if (l === c) {
    const g = a.clone().normalize(), k = t > o, T = e.clone().add(g.multiplyScalar(k ? t : -t));
    return i ? T : [T, T];
  }
  const f = t, d = o, v = (ce(l, 2) + ce(f, 2) - ce(d, 2)) / (2 * l * f), x = f * v, P = Math.sqrt(ce(f, 2) - ce(x, 2)), E = a.clone().normalize(), p = new R(-E.y, E.x), m = E.clone().multiplyScalar(x), w = p.clone().multiplyScalar(P), b = e.clone().add(m).add(w), h = e.clone().add(m).subtract(w);
  if (i) {
    const g = b.distance(i), k = h.distance(i);
    return g < k ? b : h;
  } else
    return [b, h];
}
function Ao(e, t, n, o) {
  const i = J.fromPositions(e, t), r = (n.width + n.strokeWidth) / 2 * o, s = (n.height + n.strokeWidth) / 2 * o, a = n.borderRadius > 0 ? (n.borderRadius + n.strokeWidth / 2) * o : 0, l = (i.v.angle() - Math.PI / 2) % Math.PI, u = Math.PI / 2 - l % Math.PI, c = s * Math.abs(Math.tan(l)), f = r * Math.abs(Math.tan(u)), d = c <= r - a, v = f <= s - a;
  if (d || v || a === 0)
    return Math.sqrt(d ? ce(s, 2) + ce(c, 2) : ce(r, 2) + ce(f, 2));
  {
    const x = t.x - r + a, P = t.y - s + a, E = t.x + r - a, p = t.y + s - a, m = [
      new R(x, P),
      new R(E, P),
      new R(E, p),
      new R(x, p)
    ], w = Math.floor((i.v.angleDegree() + 360) % 360 / 90), b = m[w], h = Ut(
      i.source,
      Nn(b, i),
      b,
      a
    );
    return h ? ot(h, i.target).length() : ot(b, i.target).length() + a;
  }
}
function Ti(e, t, n, o, i) {
  const r = J.fromLinePosition(e), s = r.v.clone().normalize(), a = o === 0 ? r.source : r.source.clone().add(s.clone().multiplyScalar(o * i)), l = o === 0 ? r.target : r.target.clone().subtract(s.clone().multiplyScalar(o * i)), u = (t.width / 2 + n) * i, c = new R(-s.y, s.x).multiplyScalar(u);
  let f = te.subtract(a, c), d = te.add(a, c), v = te.subtract(l, c), x = te.add(l, c);
  const P = r.v.angleDegree();
  return (P < -90 || P >= 90) && ([f, d] = [d, f], [v, x] = [x, v]), {
    source: { above: f, below: d },
    target: { above: v, below: x }
  };
}
function Wc(e, t, n, o) {
  let i;
  n.type === "circle" ? i = n.radius + n.strokeWidth / 2 : i = Ao(
    t,
    e,
    n,
    1
    // scale
  );
  let r;
  return o.type === "circle" ? r = o.radius + o.strokeWidth / 2 : r = Ao(
    e,
    t,
    o,
    1
    // scale
  ), [i, r];
}
function Le(e, t, n) {
  const { x: o, y: i } = e, r = o - t.x, s = i - t.y;
  return {
    x: r * Math.cos(n) - s * Math.sin(n) + t.x,
    y: r * Math.sin(n) + s * Math.cos(n) + t.y
  };
}
function mn(e) {
  return e > 0 ? -(Math.PI * 2 - e) : Math.PI * 2 + e;
}
function bn(e, t, n, o) {
  const i = [], r = J.fromVectors(t, e), s = J.fromVectors(t, n);
  let a = it(r, s);
  o * a < 0 && (a = mn(a));
  const l = R.fromObject(Le(e, t, -a / 2)), u = J.fromVectors(t, l), c = ct(u), f = it(r, u);
  let d = ct(r);
  if (Math.abs(f) < Math.PI / 2) {
    const x = Ve(d, c);
    i.push(x);
  } else {
    const x = R.fromObject(Le(l, t, f / 2)), P = ct(
      J.fromVectors(t, R.fromObject(x))
    ), E = Ve(d, P), p = Ve(P, c);
    i.push(E, x, p);
  }
  i.push(l);
  const v = it(s, u);
  if (d = ct(s), Math.abs(v) < Math.PI / 2) {
    const x = Ve(d, c);
    i.push(x);
  } else {
    const x = R.fromObject(Le(l, t, v / 2)), P = ct(
      J.fromVectors(t, R.fromObject(x))
    ), E = Ve(c, P), p = Ve(P, d);
    i.push(E, x, p);
  }
  return i;
}
function it(e, t) {
  return Math.atan2(
    e.v.y * t.v.x - e.v.x * t.v.y,
    e.v.x * t.v.x + e.v.y * t.v.y
  );
}
function Fc(e, t, n) {
  const o = e.x, i = e.y, r = t.x, s = t.y, a = n.x, l = n.y, u = o - r, c = i - s, f = a - r, d = l - s, v = (d * (u * (o + r) + c * (i + s)) - c * (f * (a + r) + d * (l + s))) / (2 * u * d - 2 * c * f), x = (-f * (u * (o + r) + c * (i + s)) + u * (f * (a + r) + d * (l + s))) / (2 * u * d - 2 * c * f), P = Math.sqrt(Math.pow(o - v, 2) + Math.pow(i - x, 2));
  return [new R(v, x), P];
}
function tt(e) {
  return e.type == "circle" ? e.radius : Math.min(e.width, e.height) / 2;
}
function rn(e, t, n, o, i, r, s) {
  const a = Ce({});
  G(
    () => new Set(Object.keys(e.value)),
    (u, c) => {
      c || (c = /* @__PURE__ */ new Set([]));
      for (const f of u)
        c.has(f) || Uc(e, a, f, !1, t, i);
      for (const f of c)
        u.has(f) || (n.delete(f), o.delete(f), r == null || r(f, a[f]), delete a[f]);
    },
    { immediate: !0 }
  ), G(
    () => [...n],
    (u, c) => {
      const f = c ? u.filter((v) => !c.includes(v)) : u, d = c ? c.filter((v) => !u.includes(v)) : [];
      f.forEach((v) => {
        const x = a[v];
        x && !x.selected && (x.selected = !0);
      }), d.forEach((v) => {
        const x = a[v];
        x && x.selected && (x.selected = !1);
      });
    },
    { immediate: !0 }
    // for specified from the beginning
  ), G(
    () => [...o],
    (u, c) => {
      const f = u.filter((v) => !c.includes(v)), d = c.filter((v) => !u.includes(v));
      f.forEach((v) => {
        const x = a[v];
        x && !x.hovered && (x.hovered = !0);
      }), d.forEach((v) => {
        const x = a[v];
        x && x.hovered && (x.hovered = !1);
      });
    }
  );
  const l = O(() => {
    const u = s ? s() : Object.values(a);
    return t.zOrder.enabled ? Gc(u, t.zOrder, o, n) : u;
  });
  return { states: a, zOrderedList: l };
}
function Uc(e, t, n, o, i, r) {
  const s = {
    id: n,
    selected: o,
    hovered: !1,
    selectable: O(() => e.value[n] ? z.value(i.selectable, e.value[n]) : y(s.selectable)),
    zIndex: O(() => e.value[n] ? z.value(i.zOrder.zIndex, e.value[n]) : y(s.zIndex))
  };
  t[n] = s, r(
    e,
    n,
    t[n]
    /* get reactive object */
  );
}
function Gc(e, t, n, o) {
  return t.bringToFrontOnHover && t.bringToFrontOnSelected ? e.sort((i, r) => {
    const s = n.has(i.id), a = n.has(r.id);
    if (s != a)
      return s ? 1 : -1;
    const l = o.has(i.id), u = o.has(r.id);
    return l != u ? l ? 1 : -1 : i.zIndex - r.zIndex;
  }) : t.bringToFrontOnHover ? e.sort((i, r) => {
    const s = n.has(i.id), a = n.has(r.id);
    return s != a ? s ? 1 : -1 : i.zIndex - r.zIndex;
  }) : t.bringToFrontOnSelected ? e.sort((i, r) => {
    const s = o.has(i.id), a = o.has(r.id);
    return s != a ? s ? 1 : -1 : i.zIndex - r.zIndex;
  }) : e.sort((i, r) => i.zIndex - r.zIndex);
}
function Xc(e) {
  return typeof btoa === void 0 ? Buffer.from(e).toString("base64").replaceAll("=", "") : btoa(e).replaceAll("=", "");
}
function qc() {
  return { markers: Ce({}), referenceCount: {} };
}
function Kc(e) {
  const { markers: t, referenceCount: n } = e;
  function o(a, l) {
    var c;
    const u = (c = n[a]) != null ? c : 0;
    n[a] = u + 1, u || (t[a] = l);
  }
  function i(a) {
    var u;
    const l = (u = n[a]) != null ? u : 0;
    l && (l - 1 === 0 ? (delete t[a], delete n[a]) : n[a] = l - 1);
  }
  function r(a) {
    a && i(a);
  }
  function s(a, l, u, c, f) {
    if (a.type === "none") {
      r(u);
      return;
    }
    if (a.type === "custom")
      return r(u), a.customId;
    const d = Yc(a, l, c), v = Qc(d, f);
    return v === u || (r(u), o(v, d)), v;
  }
  return {
    makeMarker: s,
    clearMarker: r
  };
}
function Yc(e, t, n) {
  var o;
  return st(se({}, e), {
    color: (o = e.color) != null ? o : n,
    isSource: t
  });
}
function Qc(e, t) {
  const n = Xc(e.color), o = e.isSource ? "L" : "R", i = e.units === "strokeWidth" ? "rel" : "abs";
  return `marker_${t}_${e.type}_${e.width}_${e.height}_${e.margin}_${n}_${o}_${i}`;
}
function sn(e, t, n) {
  return {
    objects: e,
    selected: t,
    hovered: n
  };
}
const Oi = Symbol("states"), Jc = {
  type: "none",
  width: 0,
  height: 0,
  margin: 0,
  units: "strokeWidth",
  color: null
};
function eu(e, t, n, o, i, r, s) {
  const a = Ce({}), l = Ae({});
  me(() => {
    const w = Object.fromEntries(
      Object.keys(e.objects.value).map((b) => [b, {}])
    );
    Object.entries(t.objects.value).forEach(([b, h]) => {
      w != null && w[h.source] || (w[h.source] = {}), w != null && w[h.target] || (w[h.target] = {}), w[h.source][b] = h.target, w[h.target][b] = h.source;
    }), $t(l, w);
  });
  const {
    states: u,
    zOrderedList: c
    //
  } = rn(
    e.objects,
    o.node,
    e.selected,
    e.hovered,
    (w, b, h) => {
      ou(
        w,
        b,
        h,
        o.node,
        l,
        i
      );
    },
    (w, b) => {
      const h = i.nodes;
      delete h[w];
    }
  ), f = Al(), d = Ic(e.objects, t.objects, o), v = Z([]), {
    states: x,
    zOrderedList: P
    //
  } = rn(
    t.objects,
    o.edge,
    t.selected,
    t.hovered,
    (w, b, h) => {
      ru(
        w,
        b,
        h,
        o.edge,
        r,
        u,
        d,
        i,
        s,
        f
      );
    },
    (w, b) => {
      var h;
      (h = b.stopWatchHandle) == null || h.call(b);
    },
    () => v.value
  );
  me(() => {
    v.value = su(d.edgeGroups, x);
  }), G(
    d.edgeGroups,
    (w) => cu(a, d, o),
    { immediate: !0 }
  );
  const {
    states: E,
    zOrderedList: p
    //
  } = rn(
    n.objects,
    o.path,
    n.selected,
    n.hovered,
    (w, b, h) => {
      const g = h;
      g.clickable = O(() => w.value[b] ? z.value(o.path.clickable, w.value[b]) : !1), g.hoverable = O(() => w.value[b] ? z.value(o.path.hoverable, w.value[b]) : !1), g.path = w.value[b], g.edges = O(() => w.value[b].edges.map((T) => ({ edgeId: T, edge: t.objects.value[T] })).filter((T) => T.edge));
    }
  ), m = {
    nodeStates: u,
    edgeStates: x,
    edgeGroupStates: d,
    summarizedEdgeStates: a,
    pathStates: E,
    layouts: i,
    nodeZOrderedList: c,
    edgeZOrderedList: P,
    pathZOrderedList: p
  };
  return je(Oi, m), m;
}
function tu(e) {
  return e.summarized;
}
function Me() {
  return q(Be(Oi), "states");
}
function nu(e, t, n, o) {
  return n && o.hover ? z.values(o.hover, e) : Ci(e, t, o);
}
function Ci(e, t, n) {
  return t && n.selected ? z.values(n.selected, e) : z.values(n.normal, e);
}
function ou(e, t, n, o, i, r) {
  n.shape = O(() => e.value[t] ? nu(e.value[t], n.selected, n.hovered, o) : y(n.shape)), n.staticShape = O(() => e.value[t] ? Ci(e.value[t], n.selected, o) : y(n.staticShape)), n.label = O(() => e.value[t] ? z.values(o.label, e.value[t]) : y(n.label)), n.labelText = O(() => {
    var s, a;
    return o.label.text instanceof Function ? y(n.label).text : e.value[t] ? (a = (s = e.value[t]) == null ? void 0 : s[y(n.label).text]) != null ? a : "" : y(n.labelText);
  }), n.draggable = O(() => e.value[t] ? z.value(o.draggable, e.value[t]) : y(n.draggable)), n.oppositeNodeIds = Te(i, t), n.oppositeNodes = O(() => Object.entries(n.oppositeNodeIds).reduce((s, a) => {
    const [l, u] = a, c = r.nodes[u];
    return c && (s[l] = { nodeId: u, pos: se({}, c) }), s;
  }, {}));
}
function iu(e, t, n, o) {
  return t ? z.values(o.selected, e) : n && o.hover ? z.values(o.hover, e) : z.values(o.normal, e);
}
function Lo(e) {
  return e.type === "none" ? Jc : e;
}
function ru(e, t, n, o, i, r, s, a, l, u) {
  const { makeMarker: c, clearMarker: f } = Kc(i);
  Object.assign(n, {
    origin: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } },
    labelPosition: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } },
    position: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } }
  });
  const d = O(() => {
    const p = e.value[t], m = iu(p, n.selected, n.hovered, o);
    isNaN(+m.width) && (console.warn(
      "[v-network-graph] Edge width is invalid value. id=[%s] value=[%s]",
      t,
      m.width
    ), m.width = 1), (m.color === void 0 || m.color === null) && (console.warn(
      "[v-network-graph] Edge color is invalid value. id=[%s] value=[%s]",
      t,
      m.color
    ), m.color = "#000000");
    let w = z.value(o.normal.width, p);
    isNaN(+w) && (w = 1);
    const b = Lo(z.values(o.marker.source, [p, m])), h = Lo(z.values(o.marker.target, [p, m]));
    return { stroke: m, normalWidth: w, source: b, target: h };
  });
  n.line = d;
  const v = Te(
    s.edgeLayoutPoints,
    t
  ), x = Te(s.summarizedEdges, t), P = me(() => {
    var j, F, ye, ie, Pe;
    const p = e.value[t];
    if (!p)
      return;
    const m = a.nodes[p == null ? void 0 : p.source], w = a.nodes[p == null ? void 0 : p.target], b = (j = r[p.source]) == null ? void 0 : j.staticShape, h = (F = r[p.target]) == null ? void 0 : F.staticShape;
    if (!m || !w || !b || !h)
      return;
    const g = Ac(
      v.value,
      (ye = x.value) != null ? ye : !1,
      m,
      w,
      l.value,
      o.keepOrder
    ), [k, T] = Wc(m, w, b, h), _ = l.value;
    n.labelPosition = gn(
      g,
      k * _,
      T * _
    );
    let C = 0, $ = 0;
    const A = d.value;
    if (A.source.type !== "none") {
      const le = A.source;
      C = le.margin + le.width, le.units === "strokeWidth" && (C *= A.normalWidth);
    }
    if (A.target.type !== "none") {
      const le = A.target;
      $ = le.margin + le.width, le.units === "strokeWidth" && ($ *= A.normalWidth);
    }
    o.margin && (C += o.margin, $ += o.margin);
    const B = !!o.margin || A.source.type !== "none" || A.target.type !== "none";
    if (p.source === p.target) {
      n.origin = Dt(m, w);
      const le = z.values(o.selfLoop, p), [Qe, Je] = lu(
        m,
        b,
        le,
        B,
        C,
        $,
        (Pe = (ie = v.value) == null ? void 0 : ie.pointInGroup) != null ? Pe : 0,
        _
      );
      n.position = Qe, n.loop = Je, n.curve = void 0;
      return;
    } else
      n.loop = void 0;
    if (B && (C += k, $ += T), o.type === "straight")
      n.origin = g, n.curve = void 0, C === 0 && $ === 0 ? n.position = n.origin : n.position = gn(n.origin, C * _, $ * _);
    else {
      n.origin = Dt(m, w);
      const le = v.value ? v.value.groupWidth / 2 - v.value.pointInGroup : 0, [Qe, Je] = au(
        n.origin,
        g,
        le,
        C * _,
        $ * _
      );
      n.position = Qe, n.curve = Je;
    }
  }), E = me(() => {
    e.value[t] && (n.sourceMarkerId = c(
      d.value.source,
      !0,
      n.sourceMarkerId,
      d.value.stroke.color,
      u
    ), n.targetMarkerId = c(
      d.value.target,
      !1,
      n.targetMarkerId,
      d.value.stroke.color,
      u
    ));
  });
  n.stopWatchHandle = () => {
    P(), E(), f(n.sourceMarkerId), f(n.targetMarkerId);
  };
}
function su(e, t) {
  return Object.entries(e).map(([n, o]) => {
    var i;
    return o.summarize ? {
      id: (i = Object.keys(o.edges)[0]) != null ? i : n,
      summarized: !0,
      key: n,
      group: o,
      zIndex: Object.keys(o.edges).map((r) => {
        var s, a;
        return (a = (s = t[r]) == null ? void 0 : s.zIndex) != null ? a : 0;
      }).reduce((r, s) => Math.max(r, s))
    } : Object.entries(o.edges).map(
      ([r, s]) => {
        var a, l;
        return {
          id: r,
          summarized: !1,
          key: r,
          edge: s,
          zIndex: (l = (a = t[r]) == null ? void 0 : a.zIndex) != null ? l : 0
        };
      }
    );
  }).flat();
}
function au(e, t, n, o, i) {
  const r = J.fromLinePosition(e), s = J.fromLinePosition(t), a = Bc(t), [l, u] = Fc(
    r.source,
    r.target,
    a
  );
  let c, f;
  if (n === 0)
    return o === 0 && i === 0 ? c = e : c = gn(e, o, i), [c, f];
  const d = J.fromVectors(l, a), v = it(
    J.fromVectors(l, r.source),
    d
  );
  if (o === 0 && i === 0)
    c = e;
  else {
    let p = o / u, m = i / u;
    v > 0 && (p *= -1, m *= -1), c = Dt(
      Le(r.source, l, p),
      Le(r.target, l, -m)
    );
    let w = it(
      J.fromVectors(l, r.source),
      J.fromVectors(l, r.target)
    ), b = it(
      J.fromPositions(l, c.p1),
      J.fromPositions(l, c.p2)
    );
    if (v * w < 0 && (w = mn(w), v * b < 0 && (b = mn(b))), w * b < 0) {
      const h = a.clone().add(s.v.normalize().multiplyScalar(0.5));
      return c = Dt(a, h), [c, f];
    }
  }
  const [x, P] = jc(c), E = bn(x, l, P, v).map((p) => p.toObject());
  return f = {
    center: a,
    theta: v,
    circle: { center: l, radius: u },
    control: E
  }, [c, f];
}
function lu(e, t, n, o, i, r, s, a) {
  const l = a, u = (n.radius + s / 2) * l, c = n.offset * l + u, f = (n.angle - 90) * (Math.PI / 180), d = R.fromObject({
    x: e.x + c * Math.cos(f),
    y: e.y + c * Math.sin(f)
  }), v = n.isClockwise;
  let x, P;
  if (o) {
    const b = mt(
      d,
      u,
      R.fromObject(e),
      tt(t) * l
    );
    if (b) {
      [x, P] = b;
      let h = 1;
      if (v || ([x, P] = [P, x], h = -1), i !== 0 || r !== 0) {
        const g = i * l / u * h, k = r * l / u * h;
        x = Le(x, d, g), P = Le(P, d, -k);
      }
    }
  }
  if (x === void 0 || P === void 0) {
    const b = R.fromObject(e).subtract(d).normalize().multiplyScalar(u);
    let h = 1 * (Math.PI / 180);
    v || (h *= -1), x = d.clone().add(Nt(b, h)), P = d.clone().add(Nt(b, -h));
  }
  const E = R.fromObject(x).subtract(d).angleDegree(), w = (R.fromObject(P).subtract(d).angleDegree() + 360 - E) % 360 >= 180;
  return [
    { p1: x, p2: P },
    {
      center: d,
      radius: [u, u],
      isLargeArc: v ? w : !w,
      isClockwise: v
    }
  ];
}
function cu(e, t, n) {
  const o = t.edgeGroups;
  Object.entries(o).filter(([i, r]) => r.summarize && !(i in e)).forEach(([i, r]) => {
    const s = { stroke: void 0 };
    s.stroke = O(
      () => z.values(n.edge.summarized.stroke, r.edges)
    ), e[i] = s;
  }), Object.keys(e).forEach((i) => {
    var r;
    (r = t.edgeGroups[i]) != null && r.summarize || delete e[i];
  });
}
class ft {
  static valueOf(t) {
    return Array.from(t.values());
  }
}
const uu = 3, du = 6, $i = 500;
function _t(e) {
  return e === "touch" ? du : uu;
}
function Dn(e, t, n, o) {
  let i = e.get(t);
  if (i)
    i.id !== n && (i = void 0);
  else {
    const a = Array.from(e.entries()).find(([l, u]) => u.id === n);
    if (a) {
      const [l, u] = a;
      e.delete(l), i = u;
    }
  }
  let r, s;
  return [i, r, s] = _i(i, o, n), e.set(t, i), [r, s];
}
function _i(e, t, n) {
  const o = Date.now();
  e && o - e.lastTime <= $i ? (e.count++, e.lastTime = o) : e = { count: 1, lastTime: o, id: n };
  const i = {
    view: window,
    screenX: t.screenX,
    screenY: t.screenY,
    clientX: t.clientX,
    clientY: t.clientY,
    ctrlKey: t.ctrlKey,
    shiftKey: t.shiftKey,
    altKey: t.altKey,
    metaKey: t.metaKey,
    button: t.button,
    buttons: t.buttons,
    detail: e.count
  };
  let r, s;
  return t instanceof PointerEvent ? (Object.assign(i, {
    pointerId: t.pointerId,
    width: t.width,
    height: t.height,
    pressure: t.pressure,
    tangentialPressure: t.tangentialPressure,
    tiltX: t.tiltX,
    tiltY: t.tiltY,
    twist: t.twist,
    pointerType: t.pointerType,
    isPrimary: t.isPrimary
  }), r = new PointerEvent("click", i), e.count === 2 && (s = new PointerEvent("dblclick", i))) : (r = new MouseEvent("click", i), e.count === 2 && (s = new MouseEvent("dblclick", i))), [e, r, s];
}
function Zn(e) {
  const t = Date.now();
  Array.from(e.entries()).filter(([n, o]) => t - o.lastTime > $i).map(([n, o]) => e.delete(n));
}
function fu(e, t, n, o, i, r, s) {
  const a = {
    pointers: /* @__PURE__ */ new Map(),
    follow: {
      followedPointerId: -1,
      nodeBasePositions: {}
    },
    hoveredNodesPre: /* @__PURE__ */ new Set(),
    clicks: /* @__PURE__ */ new Map()
  }, l = {
    pointermove: v,
    pointerup: P,
    pointercancel: x
  };
  function u(b) {
    const h = a.follow.followedPointerId === b.pointerId, g = i.has(b.nodeId), k = !(b.pointerId in a.pointers);
    if (h && k || h && !g) {
      const T = ft.valueOf(a.pointers).find((_) => i.has(_.nodeId));
      if (!T) {
        a.follow = { followedPointerId: -1, nodeBasePositions: {} };
        return;
      }
      b = T, a.follow.followedPointerId = b.pointerId;
    } else {
      const T = a.pointers.get(a.follow.followedPointerId);
      if (!T) {
        a.follow = { followedPointerId: -1, nodeBasePositions: {} };
        return;
      }
      b = T;
    }
    if (h || g) {
      const T = ft.valueOf(a.pointers).map((_) => _.nodeId);
      a.follow.nodeBasePositions = Object.fromEntries(
        Array.from(i).filter((_) => !T.includes(_)).filter((_) => {
          var C;
          return (C = e[_]) == null ? void 0 : C.draggable;
        }).map((_) => [_, an(t.nodes, _)])
      ), b.dragBasePosition = se({}, b.latestPosition), b.nodeBasePosition = an(t.nodes, b.nodeId);
    }
  }
  G(i, (b) => {
    const h = a.pointers.get(a.follow.followedPointerId);
    h && u(h), b.size > 0 && n.selectionMode.value !== "node" ? n.selectionMode.value = "node" : b.size === 0 && n.selectionMode.value === "node" && (n.selectionMode.value = "container");
  }), G(n.selectionMode, (b) => {
    b !== "node" && i.clear();
  });
  function c(b, h) {
    const g = b.dragBasePosition.x - h.pageX, k = b.dragBasePosition.y - h.pageY, T = a.follow.followedPointerId == b.pointerId ? se({
      [b.nodeId]: b.nodeBasePosition
    }, a.follow.nodeBasePositions) : { [b.nodeId]: b.nodeBasePosition }, _ = r.value;
    return Object.fromEntries(
      Object.entries(T).map(([C, $]) => [
        C,
        {
          x: $.x - g / _,
          y: $.y - k / _
        }
      ])
    );
  }
  function f(b, h) {
    var k, T;
    if (h.isTrusted || h.shiftKey && !["container", "node"].includes(n.selectionMode.value))
      return;
    n.selectionMode.value = "node";
    const g = (T = (k = e[b]) == null ? void 0 : k.selectable) != null ? T : !1;
    if (g) {
      const _ = ft.valueOf(a.pointers).filter((C) => i.has(C.nodeId)).length > 0;
      h.shiftKey || _ ? i.has(b) ? i.delete(b) : typeof g == "number" && i.size >= g || i.add(b) : i.has(b) || (i.clear(), i.add(b));
    }
    s.emit("node:click", { node: b, event: h });
  }
  function d(b, h) {
    h.isTrusted || s.emit("node:dblclick", { node: b, event: h });
  }
  function v(b) {
    var T;
    b.stopPropagation();
    const h = a.pointers.get(b.pointerId);
    if (!h)
      return;
    h.latestPosition = { x: b.pageX, y: b.pageY }, h.moveCounter++;
    const g = _t(b.pointerType);
    if (h.moveCounter <= g || !((T = e[h.nodeId]) != null && T.draggable))
      return;
    if (h.moveCounter === g + 1) {
      const _ = c(h, {
        pointerId: h.pointerId,
        pageX: h.dragBasePosition.x,
        pageY: h.dragBasePosition.y
      });
      s.emit("node:dragstart", _);
    }
    const k = c(h, b);
    s.emit("node:pointermove", k);
  }
  function x(b) {
    b.stopPropagation();
    let h = a.pointers.get(b.pointerId);
    if (h) {
      for (h of a.pointers.values()) {
        const g = h.nodeId, k = _t(b.pointerType);
        if (h.moveCounter > k) {
          const _ = c(h, {
            pointerId: h.pointerId,
            pageX: h.latestPosition.x,
            pageY: h.latestPosition.y
          });
          s.emit("node:dragend", _);
        }
        s.emit("node:pointerup", { node: g, event: b });
      }
      a.pointers.clear(), a.follow = { followedPointerId: -1, nodeBasePositions: {} }, ve(l).forEach(([g, k]) => {
        document.removeEventListener(g, k);
      }), n.viewMode.value = "default";
    }
  }
  function P(b) {
    var _, C, $;
    b.stopPropagation();
    const h = a.pointers.get(b.pointerId);
    if (!h)
      return;
    a.pointers.delete(b.pointerId);
    const g = h.nodeId, k = _t(b.pointerType), T = h.moveCounter > k;
    if (T) {
      if ((_ = e[h.nodeId]) != null && _.draggable) {
        const A = c(h, b);
        s.emit("node:dragend", A), s.emit("node:pointerup", { node: g, event: b });
      }
    } else
      s.emit("node:pointerup", { node: g, event: b });
    if (!T) {
      const [A, B] = Dn(
        a.clicks,
        h.pointerId,
        g,
        b
      );
      (C = h.eventTarget) == null || C.dispatchEvent(A), B && (($ = h.eventTarget) == null || $.dispatchEvent(B));
    }
    a.pointers.size === 0 ? (a.follow = { followedPointerId: -1, nodeBasePositions: {} }, ve(l).forEach(([A, B]) => {
      document.removeEventListener(A, B);
    }), Zn(a.clicks), n.viewMode.value = "default") : u(h), o.clear(), a.hoveredNodesPre.forEach(o.add, o);
  }
  function E(b, h) {
    if (h.button == 2 || (h.stopPropagation(), !["default", "node"].includes(n.viewMode.value)))
      return;
    a.pointers.size == 0 && (n.viewMode.value = "node", ve(l).forEach(([k, T]) => {
      document.addEventListener(k, T);
    }));
    const g = {
      pointerId: h.pointerId,
      nodeId: b,
      moveCounter: 0,
      nodeBasePosition: an(t.nodes, b),
      dragBasePosition: { x: h.pageX, y: h.pageY },
      latestPosition: { x: h.pageX, y: h.pageY },
      eventTarget: h.currentTarget
    };
    a.pointers.set(h.pointerId, g), i.has(b) && (a.follow.followedPointerId < 0 ? (a.follow.followedPointerId = h.pointerId, u(g)) : delete a.follow.nodeBasePositions[g.nodeId]), s.emit("node:pointerdown", { node: b, event: h });
  }
  function p(b, h) {
    a.hoveredNodesPre.add(b), !(a.pointers.size > 0) && (o.add(b), s.emit("node:pointerover", { node: b, event: h }));
  }
  function m(b, h) {
    a.hoveredNodesPre.delete(b), !(a.pointers.size > 0) && (o.delete(b), s.emit("node:pointerout", { node: b, event: h }));
  }
  function w(b, h) {
    h.stopPropagation(), s.emit("node:contextmenu", { node: b, event: h });
  }
  return {
    handleNodePointerDownEvent: E,
    handleNodePointerOverEvent: p,
    handleNodePointerOutEvent: m,
    handleNodeClickEvent: f,
    handleNodeDoubleClickEvent: d,
    handleNodeContextMenu: w
  };
}
function an(e, t) {
  var o;
  const n = (o = e[t]) != null ? o : { x: 0, y: 0 };
  return se({}, n);
}
function hu(e, t, n, o, i) {
  const r = {
    pointers: /* @__PURE__ */ new Map(),
    // <PointerId, ...>
    pointerPeekCount: 0,
    clicks: /* @__PURE__ */ new Map()
  }, s = {
    pointerup: l,
    pointercancel: u
  };
  G(o, (h) => {
    h.size > 0 && t.selectionMode.value !== "edge" ? t.selectionMode.value = "edge" : h.size === 0 && t.selectionMode.value === "edge" && (t.selectionMode.value = "container");
  }), G(t.selectionMode, (h) => {
    h !== "edge" && o.clear();
  });
  function a(h, g) {
    if (g.button == 2 || (g.stopPropagation(), !["default", "edge"].includes(t.viewMode.value)))
      return;
    r.pointers.size == 0 && (t.viewMode.value = "edge", ve(s).forEach(([T, _]) => {
      document.addEventListener(T, _);
    }), r.pointerPeekCount = 0), r.pointerPeekCount++;
    const k = {
      pointerId: g.pointerId,
      id: h,
      eventTarget: g.currentTarget
    };
    r.pointers.set(g.pointerId, k), i.emit("edge:pointerdown", we(h, g));
  }
  function l(h) {
    var C, $;
    h.stopPropagation();
    const g = r.pointers.get(h.pointerId);
    if (!g)
      return;
    r.pointers.delete(h.pointerId);
    const k = g.id;
    i.emit("edge:pointerup", we(k, h));
    const [T, _] = Dn(
      r.clicks,
      g.pointerId,
      k instanceof Array ? k.join(",") : k,
      h
    );
    (C = g.eventTarget) == null || C.dispatchEvent(T), _ && (($ = g.eventTarget) == null || $.dispatchEvent(_)), r.pointers.size === 0 && (r.pointerPeekCount = 0, ve(s).forEach(([A, B]) => {
      document.removeEventListener(A, B);
    }), Zn(r.clicks), t.viewMode.value = "default");
  }
  function u(h) {
    if (h.stopPropagation(), !!r.pointers.get(h.pointerId)) {
      for (const k of r.pointers.values()) {
        const T = k.id;
        i.emit("edge:pointerup", we(T, h));
      }
      r.pointers.clear(), r.pointerPeekCount = 0, ve(s).forEach(([k, T]) => {
        document.removeEventListener(k, T);
      }), i.emit("view:mode", "default");
    }
  }
  function c(h, g) {
    var _;
    if (g.isTrusted || g.shiftKey && !["container", "edge"].includes(t.selectionMode.value))
      return;
    t.selectionMode.value = "edge";
    const k = h instanceof Array ? h : [h], T = ft.valueOf(r.pointers).filter((C) => (C.id instanceof Array ? C.id : [C.id]).every((A) => o.has(A))).length > 0;
    if (h instanceof Array)
      k.find(($) => {
        var A;
        return (A = e[$]) == null ? void 0 : A.selectable;
      }) && (g.shiftKey || T ? k.some(($) => o.has($)) ? k.forEach(($) => o.delete($)) : k.forEach(($) => {
        var B;
        const A = (B = e[$]) == null ? void 0 : B.selectable;
        typeof A == "number" && o.size >= A || o.add($);
      }) : (o.clear(), k.forEach(($) => o.add($))));
    else {
      const C = (_ = e[h]) == null ? void 0 : _.selectable;
      C && (g.shiftKey || T ? o.has(h) ? o.delete(h) : typeof C == "number" && o.size >= C || o.add(h) : o.has(h) || (o.clear(), o.add(h)));
    }
    i.emit("edge:click", we(h, g));
  }
  function f(h, g) {
    g.isTrusted || i.emit("edge:dblclick", we(h, g));
  }
  function d(h, g) {
    n.add(h), i.emit("edge:pointerover", we(h, g));
  }
  function v(h, g) {
    n.delete(h), i.emit("edge:pointerout", we(h, g));
  }
  function x(h, g) {
    g.stopPropagation(), i.emit("edge:contextmenu", we(h, g));
  }
  function P(h, g) {
    if (g.button == 2 || (g.stopPropagation(), !["default", "edge"].includes(t.viewMode.value)))
      return;
    r.pointers.size == 0 && (t.viewMode.value = "edge", ve(s).forEach(([T, _]) => {
      document.addEventListener(T, _);
    }), r.pointerPeekCount = 0), r.pointerPeekCount++;
    const k = {
      pointerId: g.pointerId,
      id: h,
      eventTarget: g.currentTarget
    };
    r.pointers.set(g.pointerId, k), i.emit("edge:pointerdown", we(h, g));
  }
  function E(h, g) {
    h.forEach((k) => n.add(k)), i.emit("edge:pointerover", we(h, g));
  }
  function p(h, g) {
    h.forEach((k) => n.delete(k)), i.emit("edge:pointerout", we(h, g));
  }
  function m(h, g) {
    c(h, g);
  }
  function w(h, g) {
    f(h, g);
  }
  function b(h, g) {
    g.stopPropagation(), i.emit("edge:contextmenu", we(h, g));
  }
  return {
    handleEdgePointerDownEvent: a,
    handleEdgePointerOverEvent: d,
    handleEdgePointerOutEvent: v,
    handleEdgeClickEvent: c,
    handleEdgeDoubleClickEvent: f,
    handleEdgeContextMenu: x,
    handleEdgesPointerDownEvent: P,
    handleEdgesPointerOverEvent: E,
    handleEdgesPointerOutEvent: p,
    handleEdgesClickEvent: m,
    handleEdgesDoubleClickEvent: w,
    handleEdgesContextMenu: b
  };
}
function we(e, t) {
  return e instanceof Array ? {
    edges: e,
    event: t,
    summarized: !0
  } : {
    edge: e,
    edges: [e],
    event: t,
    summarized: !1
  };
}
function vu(e, t, n, o) {
  const i = {
    moveCounter: 0,
    pointerCounter: 0,
    clickState: void 0
  }, r = {
    pointermove: a,
    pointerup: l,
    pointercancel: l
  };
  function s(v) {
    i.moveCounter = 0, i.pointerCounter === 0 && ve(r).forEach(([x, P]) => {
      document.addEventListener(x, P, { passive: !0 });
    }), i.pointerCounter++;
  }
  function a(v) {
    i.moveCounter++;
  }
  function l(v) {
    if (i.pointerCounter--, i.pointerCounter <= 0) {
      i.pointerCounter = 0, ve(r).forEach(([P, E]) => {
        document.removeEventListener(P, E);
      });
      const x = _t(v.pointerType);
      if (i.moveCounter <= x) {
        if (v.shiftKey && t.selectionMode.value !== "container")
          return;
        t.selectionMode.value = "container";
        const [P, E, p] = _i(
          i.clickState,
          v,
          "view"
        );
        i.clickState = P, e.value.dispatchEvent(E), p && e.value.dispatchEvent(p);
      }
    }
  }
  function u(v) {
    v.isTrusted || (v.stopPropagation(), o.emit("view:click", { event: v }));
  }
  function c(v) {
    v.isTrusted || (v.stopPropagation(), o.emit("view:dblclick", { event: v }));
  }
  function f(v) {
    o.emit("view:contextmenu", { event: v }), i.pointerCounter > 0 && (i.pointerCounter = 0, ve(r).forEach(([x, P]) => {
      var E;
      (E = e.value) == null || E.removeEventListener(x, P);
    }));
  }
  const d = (v) => {
    v.preventDefault();
  };
  rt(() => {
    const v = e.value;
    v && (v.addEventListener("pointerdown", s, { passive: !0 }), v.addEventListener("click", u, { passive: !1 }), v.addEventListener("dblclick", c, { passive: !1 }), v.addEventListener("contextmenu", f, { passive: !1 }), n.value && v.addEventListener("wheel", d, { passive: !1 }));
  }), bt(() => {
    const v = e.value;
    v && (v.removeEventListener("pointerdown", s), v.removeEventListener("click", u), v.removeEventListener("dblclick", c), v.removeEventListener("contextmenu", f), n.value && v.removeEventListener("wheel", d));
  }), G(n, (v, x) => {
    const P = e.value;
    !P || v === x || (v ? P.addEventListener("wheel", d, { passive: !1 }) : P.removeEventListener("wheel", d));
  });
}
function pu(e, t, n, o, i, r) {
  const s = {
    pointers: /* @__PURE__ */ new Map(),
    // <PointerId, ...>
    pointerPeekCount: 0,
    clicks: /* @__PURE__ */ new Map()
  };
  function a(p, m) {
    var w, b;
    return i.value ? { path: (b = (w = e[p]) == null ? void 0 : w.path) != null ? b : p, event: m } : { path: p, event: m };
  }
  const l = {
    pointerup: c,
    pointercancel: f
  };
  G(o, (p) => {
    p.size > 0 && t.selectionMode.value !== "path" ? t.selectionMode.value = "path" : p.size === 0 && t.selectionMode.value === "path" && (t.selectionMode.value = "container");
  }), G(t.selectionMode, (p) => {
    p !== "path" && o.clear();
  });
  function u(p, m) {
    var b;
    if (!((b = e[p]) != null && b.clickable) || m.button == 2 || (m.stopPropagation(), !["default", "path"].includes(t.viewMode.value)))
      return;
    s.pointers.size == 0 && (t.viewMode.value = "path", ve(l).forEach(([h, g]) => {
      document.addEventListener(h, g);
    }), s.pointerPeekCount = 0), s.pointerPeekCount++;
    const w = {
      pointerId: m.pointerId,
      id: p,
      eventTarget: m.currentTarget
    };
    s.pointers.set(m.pointerId, w), r.emit("path:pointerdown", a(p, m));
  }
  function c(p) {
    var g, k;
    const m = s.pointers.get(p.pointerId);
    if (!m)
      return;
    p.stopPropagation(), s.pointers.delete(p.pointerId);
    const w = m.id;
    r.emit("path:pointerup", a(w, p));
    const [b, h] = Dn(
      s.clicks,
      m.pointerId,
      w,
      p
    );
    (g = m.eventTarget) == null || g.dispatchEvent(b), h && ((k = m.eventTarget) == null || k.dispatchEvent(h)), s.pointers.size === 0 && (s.pointerPeekCount = 0, ve(l).forEach(([T, _]) => {
      document.removeEventListener(T, _);
    }), Zn(s.clicks), t.viewMode.value = "default");
  }
  function f(p) {
    if (s.pointers.get(p.pointerId)) {
      p.stopPropagation();
      for (const w of s.pointers.values()) {
        const b = w.id;
        r.emit("path:pointerup", a(b, p));
      }
      s.pointers.clear(), s.pointerPeekCount = 0, ve(l).forEach(([w, b]) => {
        document.removeEventListener(w, b);
      }), r.emit("view:mode", "default");
    }
  }
  function d(p, m) {
    var w;
    (w = e[p]) != null && w.hoverable && (n.add(p), r.emit("path:pointerover", a(p, m)));
  }
  function v(p, m) {
    var w;
    (w = e[p]) != null && w.hoverable && (n.delete(p), r.emit("path:pointerout", a(p, m)));
  }
  function x(p, m) {
    var b, h, g;
    if (m.isTrusted || !((b = e[p]) != null && b.clickable) || m.shiftKey && !["container", "path"].includes(t.selectionMode.value))
      return;
    t.selectionMode.value = "path";
    const w = (g = (h = e[p]) == null ? void 0 : h.selectable) != null ? g : !1;
    if (w) {
      const k = ft.valueOf(s.pointers).filter((T) => o.has(T.id)).length > 0;
      m.shiftKey || k ? o.has(p) ? o.delete(p) : typeof w == "number" && o.size >= w || o.add(p) : o.has(p) || (o.clear(), o.add(p));
    }
    r.emit("path:click", a(p, m));
  }
  function P(p, m) {
    var w;
    m.isTrusted || (w = e[p]) != null && w.clickable && r.emit("path:dblclick", a(p, m));
  }
  function E(p, m) {
    var w;
    (w = e[p]) != null && w.clickable && (m.stopPropagation(), r.emit("path:contextmenu", a(p, m)));
  }
  return {
    handlePathPointerDownEvent: u,
    handlePathPointerOverEvent: d,
    handlePathPointerOutEvent: v,
    handlePathClickEvent: x,
    handlePathDoubleClickEvent: P,
    handlePathContextMenu: E
  };
}
function gu() {
}
function mu(e, t, n, o) {
  for (var i = e.length, r = n + (o ? 1 : -1); o ? r-- : ++r < i; )
    if (t(e[r], r, e))
      return r;
  return -1;
}
function bu(e) {
  return e !== e;
}
function yu(e, t, n) {
  for (var o = n - 1, i = e.length; ++o < i; )
    if (e[o] === t)
      return o;
  return -1;
}
function wu(e, t, n) {
  return t === t ? yu(e, t, n) : mu(e, bu, n);
}
function xu(e, t) {
  var n = e == null ? 0 : e.length;
  return !!n && wu(e, t, 0) > -1;
}
function Eu(e, t, n) {
  var o = -1, i = e.length;
  t < 0 && (t = -t > i ? 0 : i + t), n = n > i ? i : n, n < 0 && (n += i), i = t > n ? 0 : n - t >>> 0, t >>>= 0;
  for (var r = Array(i); ++o < i; )
    r[o] = e[o + t];
  return r;
}
var Pu = Math.ceil, Su = Math.max;
function jn(e, t, n) {
  (n ? ai(e, t, n) : t === void 0) ? t = 1 : t = Su(di(t), 0);
  var o = e == null ? 0 : e.length;
  if (!o || t < 1)
    return [];
  for (var i = 0, r = 0, s = Array(Pu(o / t)); i < o; )
    s[r++] = Eu(e, i, i += t);
  return s;
}
var ku = function() {
  return xe.Date.now();
};
const ln = ku;
var Mu = "Expected a function", Tu = Math.max, Ou = Math.min;
function Cu(e, t, n) {
  var o, i, r, s, a, l, u = 0, c = !1, f = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(Mu);
  t = Lt(t) || 0, ke(n) && (c = !!n.leading, f = "maxWait" in n, r = f ? Tu(Lt(n.maxWait) || 0, t) : r, d = "trailing" in n ? !!n.trailing : d);
  function v(g) {
    var k = o, T = i;
    return o = i = void 0, u = g, s = e.apply(T, k), s;
  }
  function x(g) {
    return u = g, a = setTimeout(p, t), c ? v(g) : s;
  }
  function P(g) {
    var k = g - l, T = g - u, _ = t - k;
    return f ? Ou(_, r - T) : _;
  }
  function E(g) {
    var k = g - l, T = g - u;
    return l === void 0 || k >= t || k < 0 || f && T >= r;
  }
  function p() {
    var g = ln();
    if (E(g))
      return m(g);
    a = setTimeout(p, P(g));
  }
  function m(g) {
    return a = void 0, d && o ? v(g) : (o = i = void 0, s);
  }
  function w() {
    a !== void 0 && clearTimeout(a), u = 0, o = l = i = a = void 0;
  }
  function b() {
    return a === void 0 ? s : m(ln());
  }
  function h() {
    var g = ln(), k = E(g);
    if (o = arguments, i = this, l = g, k) {
      if (a === void 0)
        return x(l);
      if (f)
        return clearTimeout(a), a = setTimeout(p, t), v(l);
    }
    return a === void 0 && (a = setTimeout(p, t)), s;
  }
  return h.cancel = w, h.flush = b, h;
}
function $u(e, t, n) {
  for (var o = -1, i = e == null ? 0 : e.length; ++o < i; )
    if (n(t, e[o]))
      return !0;
  return !1;
}
var _u = 1 / 0, zu = nt && 1 / On(new nt([, -0]))[1] == _u ? function(e) {
  return new nt(e);
} : gu;
const Iu = zu;
var Au = 200;
function Lu(e, t, n) {
  var o = -1, i = xu, r = e.length, s = !0, a = [], l = a;
  if (n)
    s = !1, i = $u;
  else if (r >= Au) {
    var u = t ? null : Iu(e);
    if (u)
      return On(u);
    s = !1, i = mi, l = new gt();
  } else
    l = t ? [] : a;
  e:
    for (; ++o < r; ) {
      var c = e[o], f = t ? t(c) : c;
      if (c = n || c !== 0 ? c : 0, s && f === f) {
        for (var d = l.length; d--; )
          if (l[d] === f)
            continue e;
        t && l.push(f), a.push(c);
      } else
        i(l, f, n) || (l !== a && l.push(f), a.push(c));
    }
  return a;
}
function Nu(e) {
  return e && e.length ? Lu(e) : [];
}
function Du(e) {
  return Re(this, null, function* () {
    const n = yield (yield fetch(e)).blob();
    return new Promise((o, i) => {
      try {
        const r = new FileReader();
        r.onload = function() {
          o(this.result);
        }, r.readAsDataURL(n);
      } catch (r) {
        i(r);
      }
    });
  });
}
function yn(e, t, n) {
  var r;
  const o = e.createSVGPoint();
  o.x = n.x, o.y = n.y;
  const i = o.matrixTransform((r = t.getCTM()) == null ? void 0 : r.inverse());
  return { x: i.x, y: i.y };
}
function Zu(e, t, n) {
  const o = e.createSVGPoint();
  o.x = n.x, o.y = n.y;
  const i = o.matrixTransform(t.getCTM());
  return { x: i.x, y: i.y };
}
function zi(e, t, n) {
  var u;
  const o = e.cloneNode(!0), i = t.getBBox(), r = 1 / n, s = {
    x: Math.floor((i.x - 10) * r),
    y: Math.floor((i.y - 10) * r),
    width: Math.ceil((i.width + 20) * r),
    height: Math.ceil((i.height + 20) * r)
  };
  o.setAttribute("width", s.width.toString()), o.setAttribute("height", s.height.toString());
  const a = o.querySelector(".v-ng-viewport");
  a.setAttribute("transform", `translate(${-s.x} ${-s.y}), scale(${r})`), a.removeAttribute("style"), o.setAttribute("viewBox", `0 0 ${s.width} ${s.height}`), o.removeAttribute("style");
  const l = document.createNodeIterator(o, NodeFilter.SHOW_COMMENT);
  for (; l.nextNode(); ) {
    const c = l.referenceNode;
    (u = c.parentNode) == null || u.removeChild(c);
  }
  return o;
}
function ju(e) {
  return Re(this, null, function* () {
    let t = !1, n = e.getAttribute("href");
    if (n || (t = !0, n = e.getAttribute("xlink:href")), !(!n || n.startsWith("data:")))
      try {
        const o = yield Du(n);
        e.setAttribute(t ? "xlink:href" : "href", o);
      } catch (o) {
        console.warn("Image download failed.", n);
        return;
      }
  });
}
function Bu(i, r, s) {
  return Re(this, arguments, function* (e, t, n, o = {}) {
    const a = zi(e, t, n);
    if (o.embedImages) {
      const u = Array.from(a.querySelectorAll("image")).map((c) => ju(c));
      yield Promise.all(u);
    }
    return a;
  });
}
function Ru(e, t, n, o, i, r) {
  const s = O(
    () => !!r.node.selectable && r.view.boxSelectionEnabled
  ), a = O(() => t.viewMode.value === "box-selection"), l = Z(), u = Z(), c = {
    pointers: /* @__PURE__ */ new Set(),
    // Set of pointers being pressed
    points: /* @__PURE__ */ new Map(),
    // Point indicated by each pointer
    startPoint: null,
    // Point where the drag started
    selectedNodesAtSelectStarted: /* @__PURE__ */ new Set(),
    // Nodes selected at the start of the selection
    selectionType: "append",
    // Selection method for nodes included in the dragged range
    options: {
      // options specified by user at start of selection mode
      stopTrigger: "pointerup",
      selectionType: "append",
      selectionTypeWithShiftKey: "same"
    }
  }, f = Cu(
    () => {
      Hu(
        q(e.value, "container"),
        q(l.value, "viewport"),
        u,
        n.nodes,
        o,
        i,
        c.selectedNodesAtSelectStarted,
        c.selectionType
      );
    },
    50,
    { maxWait: 100 }
  ), d = new Vu(
    e,
    x,
    P,
    E,
    v,
    p
  );
  function v(g) {
    if (c.options.stopTrigger !== "click" || c.pointers.size > 0)
      return;
    const k = { x: g.offsetX, y: g.offsetY };
    c.startPoint && R.fromObject(c.startPoint).distance(k) > 10 || h();
  }
  function x(g) {
    g.stopPropagation();
    const k = { x: g.offsetX, y: g.offsetY };
    c.pointers.size === 0 && (c.startPoint = k, d.activate(), c.selectedNodesAtSelectStarted.clear(), i.forEach((T) => c.selectedNodesAtSelectStarted.add(T)), c.options.selectionTypeWithShiftKey === "same" ? c.selectionType = c.options.selectionType : c.selectionType = g.shiftKey ? c.options.selectionTypeWithShiftKey : c.options.selectionType), c.pointers.has(g.pointerId) || c.pointers.add(g.pointerId), c.points.set(g.pointerId, k), m();
  }
  function P(g) {
    if (c.pointers.delete(g.pointerId), c.pointers.size === 1) {
      const k = q(e.value).getBoundingClientRect(), T = { x: g.x - k.x, y: g.y - k.y };
      c.startPoint = T;
    } else
      c.pointers.size === 0 && (d.deactivate(), c.options.stopTrigger === "pointerup" && h(), c.selectedNodesAtSelectStarted.clear());
    m();
  }
  function E(g) {
    const k = q(e.value).getBoundingClientRect(), T = { x: g.x - k.x, y: g.y - k.y };
    c.points.set(g.pointerId, T), m(), f();
  }
  function p(g) {
    g.key === "Escape" && c.options.stopTrigger !== "manual" && (g.stopPropagation(), h());
  }
  function m() {
    let g, k;
    const T = Array.from(c.pointers);
    if (T.length >= 2) {
      const _ = T[0], C = T[T.length - 1];
      g = c.points.get(_), k = c.points.get(C);
    } else if (c.startPoint && T.length === 1) {
      const _ = T[0];
      g = c.startPoint, k = c.points.get(_);
    } else
      g = void 0, k = void 0;
    g && k ? (u.value = {
      pos: {
        x: Math.min(g.x, k.x),
        y: Math.min(g.y, k.y)
      },
      size: {
        width: Math.abs(k.x - g.x),
        height: Math.abs(k.y - g.y)
      }
    }, u.value.size.width === 0 && (u.value.size.width = 1), u.value.size.height === 0 && (u.value.size.height = 1)) : u.value && (u.value = void 0);
  }
  const w = new Wu(
    e,
    // key down
    (g) => {
      s.value && r.view.selection.detector(g) && (b({
        stop: "manual",
        type: "append",
        withShiftKey: "invert"
      }), w.activate());
    },
    // key up
    (g) => {
      s.value && r.view.selection.detector(g) && (c.pointers.size === 0 ? h() : c.options.stopTrigger = "pointerup", w.deactivate());
    }
  );
  G(s, (g) => {
    g ? w.register() : w.unregister();
  }), rt(() => {
    var g;
    l.value = (g = e.value) == null ? void 0 : g.querySelector(".v-ng-viewport"), s.value && w.register();
  }), bt(() => {
    h(), s.value && w.unregister();
  });
  function b(g = {}) {
    var k, T, _;
    c.options = {
      stopTrigger: (k = g.stop) != null ? k : "pointerup",
      selectionType: (T = g.type) != null ? T : "append",
      selectionTypeWithShiftKey: (_ = g.withShiftKey) != null ? _ : "same"
    }, t.viewMode.value !== "box-selection" && (t.viewMode.value = "box-selection", c.pointers.clear(), d.register());
  }
  function h() {
    t.viewMode.value === "box-selection" && (t.viewMode.value = "default", d.unregister());
  }
  return { isBoxSelectionMode: a, selectionBox: u, startBoxSelection: b, stopBoxSelection: h };
}
function Hu(e, t, n, o, i, r, s, a) {
  if (!n.value)
    return;
  const l = n.value, u = yn(e, t, l.pos), c = yn(e, t, {
    x: l.pos.x + l.size.width,
    y: l.pos.y + l.size.height
  }), f = new Set(
    Object.entries(o).filter(([d, v]) => u.x <= v.x && v.x <= c.x && u.y <= v.y && v.y <= c.y).map(([d, v]) => d)
  );
  if (a === "append")
    r.forEach((d) => {
      f.has(d) || r.delete(d);
    }), f.forEach((d) => {
      var x, P;
      const v = (P = (x = i[d]) == null ? void 0 : x.selectable) != null ? P : !1;
      (v === !0 || typeof v == "number" && r.size < v) && r.add(d);
    });
  else {
    const d = new Set(s);
    d.forEach((v) => {
      f.has(v) && d.delete(v);
    }), f.forEach((v) => {
      var x, P;
      if (!s.has(v)) {
        const E = (P = (x = i[v]) == null ? void 0 : x.selectable) != null ? P : !1;
        (E === !0 || typeof E == "number" && d.size < E) && d.add(v);
      }
    }), r.clear(), d.forEach((v) => r.add(v));
  }
}
class Vu {
  constructor(t, n, o, i, r, s) {
    this._container = t, this._handlePointerDownEvent = n, this._handlePointerUpEvent = o, this._handlePointerMoveEvent = i, this._handleClickEvent = r, this._handleKeyDownEvent = s, this._ignoreEvent = (a) => a.stopPropagation();
  }
  register() {
    const t = { capture: !0, passive: !1 }, n = q(this._container.value, "container");
    n.addEventListener("pointerdown", this._handlePointerDownEvent, t), n.addEventListener("click", this._handleClickEvent, t), n.addEventListener("pointerenter", this._ignoreEvent, t), n.addEventListener("pointerleave", this._ignoreEvent, t), document.addEventListener("keydown", this._handleKeyDownEvent, t);
  }
  activate() {
    const t = { capture: !0, passive: !1 };
    document.addEventListener("pointermove", this._handlePointerMoveEvent, t), document.addEventListener("pointerup", this._handlePointerUpEvent, t);
  }
  deactivate() {
    const t = { capture: !0 };
    document.removeEventListener("pointermove", this._handlePointerMoveEvent, t), document.removeEventListener("pointerup", this._handlePointerUpEvent, t);
  }
  unregister() {
    this.deactivate();
    const t = { capture: !0 };
    if (this._container.value) {
      const n = this._container.value;
      n.removeEventListener("pointerdown", this._handlePointerDownEvent, t), n.removeEventListener("click", this._handleClickEvent, t), n.removeEventListener("pointerenter", this._ignoreEvent, t), n.removeEventListener("pointerleave", this._ignoreEvent, t), document.removeEventListener("keydown", this._handleKeyDownEvent, t);
    }
  }
}
class Wu {
  constructor(t, n, o) {
    this._container = t, this._handleKeyDownEvent = n, this._handleKeyUpEvent = o, this._preventDefault = (i) => {
      i.stopPropagation(), i.preventDefault();
    };
  }
  register() {
    document.addEventListener("keydown", this._handleKeyDownEvent, { capture: !0, passive: !0 });
  }
  activate() {
    document.addEventListener("keyup", this._handleKeyUpEvent, { capture: !0, passive: !0 }), q(this._container.value, "container").addEventListener("contextmenu", this._preventDefault, { passive: !1 });
  }
  deactivate() {
    document.removeEventListener("keyup", this._handleKeyUpEvent, { capture: !0 }), this._container.value && this._container.value.removeEventListener("contextmenu", this._preventDefault);
  }
  unregister() {
    this.deactivate(), document.removeEventListener("keydown", this._handleKeyDownEvent, { capture: !0 });
  }
}
const Ii = Symbol("mouseEventHandlers");
function Fu(e, t, n, o, i, r, s, a, l, u, c, f, d, v, x, P) {
  const E = {
    selectionMode: Z("container"),
    viewMode: Z("default")
  };
  s.size > 0 ? E.selectionMode.value = "node" : a.size > 0 ? E.selectionMode.value = "edge" : l.size > 0 && (E.selectionMode.value = "path"), G(E.viewMode, (m) => {
    P.emit("view:mode", m);
  }), vu(e, E, v, P);
  const p = se(se(se(se({
    selectedNodes: s,
    hoveredNodes: u,
    selectedEdges: a,
    hoveredEdges: c,
    selectedPaths: l,
    hoveredPaths: f
  }, fu(
    o,
    t,
    E,
    u,
    s,
    n,
    P
  )), hu(i, E, c, a, P)), pu(
    r,
    E,
    f,
    l,
    d,
    P
  )), Ru(
    e,
    E,
    t,
    o,
    s,
    x
  ));
  return je(Ii, p), p;
}
function Pt() {
  return q(Be(Ii), "mouseEventHandlers");
}
function Uu(e) {
  return { all: e = e || /* @__PURE__ */ new Map(), on: function(t, n) {
    var o = e.get(t);
    o ? o.push(n) : e.set(t, [n]);
  }, off: function(t, n) {
    var o = e.get(t);
    o && (n ? o.splice(o.indexOf(n) >>> 0, 1) : e.set(t, []));
  }, emit: function(t, n) {
    var o = e.get(t);
    o && o.slice().map(function(i) {
      i(n);
    }), (o = e.get("*")) && o.slice().map(function(i) {
      i(t, n);
    });
  } };
}
const Ai = Symbol("emitter");
function Gu() {
  const e = Uu();
  return je(Ai, e), e;
}
function Xu() {
  return q(Be(Ai), "event emitter");
}
var Zt = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {}, Gt = {
  /**
   * Get global this object
   *
   * @return {Object}        global this object
   */
  getGlobalThis: function() {
    if (typeof globalThis != "undefined")
      return globalThis;
    if (typeof self != "undefined")
      return self;
    if (typeof window != "undefined")
      return window;
    if (typeof Zt != "undefined")
      return Zt;
    if (typeof this != "undefined")
      return this;
    throw new Error("Unable to locate global `this`");
  },
  /**
   * Extends an object
   *
   * @param  {Object} target object to extend
   * @param  {Object} source object to take properties from
   * @return {Object}        extended object
   */
  extend: function(e, t) {
    e = e || {};
    for (var n in t)
      this.isObject(t[n]) ? e[n] = this.extend(e[n], t[n]) : e[n] = t[n];
    return e;
  },
  /**
   * Checks if an object is a DOM element
   *
   * @param  {Object}  o HTML element or String
   * @return {Boolean}   returns true if object is a DOM element
   */
  isElement: function(e) {
    return e instanceof HTMLElement || e instanceof SVGElement || e instanceof SVGSVGElement || //DOM2
    e && typeof e == "object" && e !== null && e.nodeType === 1 && typeof e.nodeName == "string";
  },
  /**
   * Checks if an object is an Object
   *
   * @param  {Object}  o Object
   * @return {Boolean}   returns true if object is an Object
   */
  isObject: function(e) {
    return Object.prototype.toString.call(e) === "[object Object]";
  },
  /**
   * Checks if variable is Number
   *
   * @param  {Integer|Float}  n
   * @return {Boolean}   returns true if variable is Number
   */
  isNumber: function(e) {
    return !isNaN(parseFloat(e)) && isFinite(e);
  },
  /**
   * Search for an SVG element
   *
   * @param  {Object|String} elementOrSelector DOM Element or selector String
   * @return {Object|Null}                   SVG or null
   */
  getSvg: function(e) {
    var t, n;
    if (this.isElement(e))
      t = e;
    else if (typeof e == "string" || e instanceof String) {
      if (t = document.querySelector(e), !t)
        throw new Error(
          "Provided selector did not find any elements. Selector: " + e
        );
    } else
      throw new Error("Provided selector is not an HTML object nor String");
    if (t.tagName.toLowerCase() === "svg")
      n = t;
    else if (t.tagName.toLowerCase() === "object")
      n = t.contentDocument.documentElement;
    else if (t.tagName.toLowerCase() === "embed")
      n = t.getSVGDocument().documentElement;
    else
      throw t.tagName.toLowerCase() === "img" ? new Error(
        'Cannot script an SVG in an "img" element. Please use an "object" element or an in-line SVG.'
      ) : new Error("Cannot get SVG.");
    return n;
  },
  /**
   * Attach a given context to a function
   * @param  {Function} fn      Function
   * @param  {Object}   context Context
   * @return {Function}           Function with certain context
   */
  proxy: function(e, t) {
    return function() {
      return e.apply(t, arguments);
    };
  },
  /**
   * Returns object type
   * Uses toString that returns [object SVGPoint]
   * And than parses object type from string
   *
   * @param  {Object} o Any object
   * @return {String}   Object type
   */
  getType: function(e) {
    return Object.prototype.toString.apply(e).replace(/^\[object\s/, "").replace(/\]$/, "");
  },
  /**
   * If it is a touch event than add clientX and clientY to event object
   *
   * @param  {Event} evt
   * @param  {SVGSVGElement} svg
   */
  mouseAndTouchNormalize: function(e, t) {
    if (e.clientX === void 0 || e.clientX === null)
      if (e.clientX = 0, e.clientY = 0, e.touches !== void 0 && e.touches.length) {
        if (e.touches[0].clientX !== void 0)
          e.clientX = e.touches[0].clientX, e.clientY = e.touches[0].clientY;
        else if (e.touches[0].pageX !== void 0) {
          var n = t.getBoundingClientRect();
          e.clientX = e.touches[0].pageX - n.left, e.clientY = e.touches[0].pageY - n.top;
        }
      } else
        e.originalEvent !== void 0 && e.originalEvent.clientX !== void 0 && (e.clientX = e.originalEvent.clientX, e.clientY = e.originalEvent.clientY);
  },
  /**
   * If it is a touch event than add clientX and clientY to event object
   *
   * @param  {Event} evt
   * @param  {SVGSVGElement} svg
   * @param  {Number} touch
   */
  touchNormalize: function(e, t, n) {
    if (e.touches !== void 0 && e.touches.length) {
      if (e.touches[n].clientX !== void 0)
        e.clientX = e.touches[n].clientX, e.clientY = e.touches[n].clientY;
      else if (e.touches[n].pageX !== void 0) {
        var o = t.getBoundingClientRect();
        e.clientX = e.touches[n].pageX - o.left, e.clientY = e.touches[n].pageY - o.top;
      }
    } else
      (e.clientX === void 0 || e.clientX === null) && (e.clientX = 0, e.clientY = 0, e.originalEvent !== void 0 && e.originalEvent.clientX !== void 0 && (e.clientX = e.originalEvent.clientX, e.clientY = e.originalEvent.clientY));
  },
  /**
   * Check if an event is a double click/tap
   * TODO: For touch gestures use a library (hammer.js) that takes in account other events
   * (touchmove and touchend). It should take in account tap duration and traveled distance
   *
   * @param  {Event}  evt
   * @param  {Event}  prevEvt Previous Event
   * @return {Boolean}
   */
  isDblClick: function(e, t) {
    if (e.detail === 2)
      return !0;
    if (t != null) {
      var n = e.timeStamp - t.timeStamp, o = Math.sqrt(
        Math.pow(e.clientX - t.clientX, 2) + Math.pow(e.clientY - t.clientY, 2)
      );
      return n < 250 && o < 10;
    }
    return !1;
  },
  /**
   * Returns current timestamp as an integer
   *
   * @return {Number}
   */
  now: Date.now || function() {
    return new Date().getTime();
  },
  // From underscore.
  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  throttle: function(e, t, n) {
    var o = this, i, r, s, a = null, l = 0;
    n || (n = {});
    var u = function() {
      l = n.leading === !1 ? 0 : o.now(), a = null, s = e.apply(i, r), a || (i = r = null);
    };
    return function() {
      var c = o.now();
      !l && n.leading === !1 && (l = c);
      var f = t - (c - l);
      return i = this, r = arguments, f <= 0 || f > t ? (clearTimeout(a), a = null, l = c, s = e.apply(i, r), a || (i = r = null)) : !a && n.trailing !== !1 && (a = setTimeout(u, f)), s;
    };
  },
  /**
   * Create a requestAnimationFrame simulation
   *
   * @param  {Number|String} refreshRate
   * @return {Function}
   */
  createRequestAnimationFrame: function(e) {
    var t = null;
    return e !== "auto" && e < 60 && e > 1 && (t = Math.floor(1e3 / e)), t === null ? window.requestAnimationFrame || No(33) : No(t);
  },
  /**
   * Calculate distance of points
   *
   * @param  {SVGPoint} point1
   * @param  {SVGPoint} point2
   * @return {Number}
   */
  calculateDistance: function(e, t) {
    var n = e.x - t.x, o = e.y - t.y;
    return Math.sqrt(n * n + o * o);
  }
};
function No(e) {
  return function(t) {
    window.setTimeout(t, e);
  };
}
var qu = Gt, Ku = function() {
  var e = "", t, n, o, i = [], r = { passive: !0 }, s = { passive: !1 };
  qu.getGlobalThis().addEventListener ? (t = "addEventListener", n = "removeEventListener") : (t = "attachEvent", n = "detachEvent", e = "on");
  function a() {
    return o || (o = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll"), o;
  }
  function l(P, E) {
    var p = function(m) {
      !m && (m = window.event);
      var w = {
        // keep a ref to the original event object
        originalEvent: m,
        target: m.target || m.srcElement,
        type: "wheel",
        deltaMode: m.type == "MozMousePixelScroll" ? 0 : 1,
        deltaX: 0,
        delatZ: 0,
        preventDefault: function() {
          m.preventDefault ? m.preventDefault() : m.returnValue = !1;
        }
      };
      return a() == "mousewheel" ? (w.deltaY = -0.025 * m.wheelDelta, m.wheelDeltaX && (w.deltaX = -0.025 * m.wheelDeltaX)) : w.deltaY = m.detail, E(w);
    };
    return i.push({
      element: P,
      fn: p
    }), p;
  }
  function u(P) {
    for (var E = 0; E < i.length; E++)
      if (i[E].element === P)
        return i[E].fn;
    return function() {
    };
  }
  function c(P) {
    for (var E = 0; E < i.length; E++)
      if (i[E].element === P)
        return i.splice(E, 1);
  }
  function f(P, E, p, m) {
    var w;
    a() === "wheel" ? w = p : w = l(P, p), P[t](
      e + E,
      w,
      m ? r : s
    );
  }
  function d(P, E, p, m) {
    var w;
    a() === "wheel" ? w = p : w = u(P), P[n](
      e + E,
      w,
      m ? r : s
    ), c(P);
  }
  function v(P, E, p) {
    f(P, a(), E, p), a() == "DOMMouseScroll" && f(
      P,
      "MozMousePixelScroll",
      E,
      p
    );
  }
  function x(P, E, p) {
    d(P, a(), E, p), a() == "DOMMouseScroll" && d(
      P,
      "MozMousePixelScroll",
      E,
      p
    );
  }
  return {
    on: v,
    off: x
  };
}(), Mt = Gt, Li = "unknown";
/*@cc_on!@*/
typeof document != "undefined" && document.documentMode && (Li = "ie");
var Bn = {
  svgNS: "http://www.w3.org/2000/svg",
  xmlNS: "http://www.w3.org/XML/1998/namespace",
  xmlnsNS: "http://www.w3.org/2000/xmlns/",
  xlinkNS: "http://www.w3.org/1999/xlink",
  evNS: "http://www.w3.org/2001/xml-events",
  /**
   * Get svg dimensions: width and height
   *
   * @param  {SVGSVGElement} svg
   * @return {Object}     {width: 0, height: 0}
   */
  getBoundingClientRectNormalized: function(e) {
    if (e.clientWidth && e.clientHeight)
      return { width: e.clientWidth, height: e.clientHeight };
    if (e.getBoundingClientRect())
      return e.getBoundingClientRect();
    throw new Error("Cannot get BoundingClientRect for SVG.");
  },
  /**
   * Gets g element with class of "viewport" or creates it if it doesn't exist
   *
   * @param  {SVGSVGElement} svg
   * @return {SVGElement}     g (group) element
   */
  getOrCreateViewport: function(e, t) {
    var n = null;
    if (Mt.isElement(t) ? n = t : n = e.querySelector(t), !n) {
      var o = Array.prototype.slice.call(e.childNodes || e.children).filter(function(l) {
        return l.nodeName !== "defs" && l.nodeName !== "#text";
      });
      o.length === 1 && o[0].nodeName === "g" && o[0].getAttribute("transform") === null && (n = o[0]);
    }
    if (!n) {
      var i = "viewport-" + new Date().toISOString().replace(/\D/g, "");
      n = document.createElementNS(this.svgNS, "g"), n.setAttribute("id", i);
      var r = e.childNodes || e.children;
      if (r && r.length > 0)
        for (var s = r.length; s > 0; s--)
          r[r.length - s].nodeName !== "defs" && n.appendChild(r[r.length - s]);
      e.appendChild(n);
    }
    var a = [];
    return n.getAttribute("class") && (a = n.getAttribute("class").split(" ")), ~a.indexOf("svg-pan-zoom_viewport") || (a.push("svg-pan-zoom_viewport"), n.setAttribute("class", a.join(" "))), n;
  },
  /**
   * Set SVG attributes
   *
   * @param  {SVGSVGElement} svg
   */
  setupSvgAttributes: function(e) {
    if (e.setAttribute("xmlns", this.svgNS), e.setAttributeNS(this.xmlnsNS, "xmlns:xlink", this.xlinkNS), e.setAttributeNS(this.xmlnsNS, "xmlns:ev", this.evNS), e.parentNode !== null) {
      var t = e.getAttribute("style") || "";
      t.toLowerCase().indexOf("overflow") === -1 && e.setAttribute("style", "overflow: hidden; " + t);
    }
  },
  /**
   * How long Internet Explorer takes to finish updating its display (ms).
   */
  internetExplorerRedisplayInterval: 300,
  /**
   * Forces the browser to redisplay all SVG elements that rely on an
   * element defined in a 'defs' section. It works globally, for every
   * available defs element on the page.
   * The throttling is intentionally global.
   *
   * This is only needed for IE. It is as a hack to make markers (and 'use' elements?)
   * visible after pan/zoom when there are multiple SVGs on the page.
   * See bug report: https://connect.microsoft.com/IE/feedback/details/781964/
   * also see svg-pan-zoom issue: https://github.com/ariutta/svg-pan-zoom/issues/62
   */
  refreshDefsGlobal: Mt.throttle(
    function() {
      for (var e = document.querySelectorAll("defs"), t = e.length, n = 0; n < t; n++) {
        var o = e[n];
        o.parentNode.insertBefore(o, o);
      }
    },
    Zt ? Zt.internetExplorerRedisplayInterval : null
  ),
  /**
   * Sets the current transform matrix of an element
   *
   * @param {SVGElement} element
   * @param {SVGMatrix} matrix  CTM
   * @param {SVGElement} defs
   */
  setCTM: function(e, t, n) {
    var o = this, i = "matrix(" + t.a + "," + t.b + "," + t.c + "," + t.d + "," + t.e + "," + t.f + ")";
    e.setAttributeNS(null, "transform", i), "transform" in e.style ? e.style.transform = i : "-ms-transform" in e.style ? e.style["-ms-transform"] = i : "-webkit-transform" in e.style && (e.style["-webkit-transform"] = i), Li === "ie" && n && (n.parentNode.insertBefore(n, n), window.setTimeout(function() {
      o.refreshDefsGlobal();
    }, o.internetExplorerRedisplayInterval));
  },
  /**
   * Instantiate an SVGPoint object with given event coordinates
   *
   * @param {Event} evt
   * @param  {SVGSVGElement} svg
   * @return {SVGPoint}     point
   */
  getEventPoint: function(e, t) {
    var n = t.createSVGPoint();
    return Mt.mouseAndTouchNormalize(e, t), n.x = e.clientX, n.y = e.clientY, n;
  },
  /**
   * Instantiate an SVGPoint object with given touch event coordinates
   *
   * @param {Event} evt
   * @param  {SVGSVGElement} svg
   * @param  {Number} touch
   * @return {SVGPoint}     point
   */
  getTouchPoint: function(e, t, n) {
    var o = t.createSVGPoint();
    return Mt.touchNormalize(e, t, n), o.x = e.clientX, o.y = e.clientY, o;
  },
  /**
   * Get SVG center point
   *
   * @param  {SVGSVGElement} svg
   * @return {SVGPoint}
   */
  getSvgCenterPoint: function(e, t, n) {
    return this.createSVGPoint(e, t / 2, n / 2);
  },
  /**
   * Create a SVGPoint with given x and y
   *
   * @param  {SVGSVGElement} svg
   * @param  {Number} x
   * @param  {Number} y
   * @return {SVGPoint}
   */
  createSVGPoint: function(e, t, n) {
    var o = e.createSVGPoint();
    return o.x = t, o.y = n, o;
  }
}, ge = Bn, Yu = {
  enable: function(e) {
    var t = e.svg.querySelector("defs");
    t || (t = document.createElementNS(ge.svgNS, "defs"), e.svg.appendChild(t));
    var n = t.querySelector("style#svg-pan-zoom-controls-styles");
    if (!n) {
      var o = document.createElementNS(ge.svgNS, "style");
      o.setAttribute("id", "svg-pan-zoom-controls-styles"), o.setAttribute("type", "text/css"), o.textContent = ".svg-pan-zoom-control { cursor: pointer; fill: black; fill-opacity: 0.333; } .svg-pan-zoom-control:hover { fill-opacity: 0.8; } .svg-pan-zoom-control-background { fill: white; fill-opacity: 0.5; } .svg-pan-zoom-control-background { fill-opacity: 0.8; }", t.appendChild(o);
    }
    var i = document.createElementNS(ge.svgNS, "g");
    i.setAttribute("id", "svg-pan-zoom-controls"), i.setAttribute(
      "transform",
      "translate(" + (e.width - 70) + " " + (e.height - 76) + ") scale(0.75)"
    ), i.setAttribute("class", "svg-pan-zoom-control"), i.appendChild(this._createZoomIn(e)), i.appendChild(this._createZoomReset(e)), i.appendChild(this._createZoomOut(e)), e.svg.appendChild(i), e.controlIcons = i;
  },
  _createZoomIn: function(e) {
    var t = document.createElementNS(ge.svgNS, "g");
    t.setAttribute("id", "svg-pan-zoom-zoom-in"), t.setAttribute("transform", "translate(30.5 5) scale(0.015)"), t.setAttribute("class", "svg-pan-zoom-control"), t.addEventListener(
      "click",
      function() {
        e.getPublicInstance().zoomIn();
      },
      !1
    ), t.addEventListener(
      "touchstart",
      function() {
        e.getPublicInstance().zoomIn();
      },
      !1
    );
    var n = document.createElementNS(ge.svgNS, "rect");
    n.setAttribute("x", "0"), n.setAttribute("y", "0"), n.setAttribute("width", "1500"), n.setAttribute("height", "1400"), n.setAttribute("class", "svg-pan-zoom-control-background"), t.appendChild(n);
    var o = document.createElementNS(ge.svgNS, "path");
    return o.setAttribute(
      "d",
      "M1280 576v128q0 26 -19 45t-45 19h-320v320q0 26 -19 45t-45 19h-128q-26 0 -45 -19t-19 -45v-320h-320q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h320v-320q0 -26 19 -45t45 -19h128q26 0 45 19t19 45v320h320q26 0 45 19t19 45zM1536 1120v-960 q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5t84.5 -203.5z"
    ), o.setAttribute("class", "svg-pan-zoom-control-element"), t.appendChild(o), t;
  },
  _createZoomReset: function(e) {
    var t = document.createElementNS(ge.svgNS, "g");
    t.setAttribute("id", "svg-pan-zoom-reset-pan-zoom"), t.setAttribute("transform", "translate(5 35) scale(0.4)"), t.setAttribute("class", "svg-pan-zoom-control"), t.addEventListener(
      "click",
      function() {
        e.getPublicInstance().reset();
      },
      !1
    ), t.addEventListener(
      "touchstart",
      function() {
        e.getPublicInstance().reset();
      },
      !1
    );
    var n = document.createElementNS(
      ge.svgNS,
      "rect"
    );
    n.setAttribute("x", "2"), n.setAttribute("y", "2"), n.setAttribute("width", "182"), n.setAttribute("height", "58"), n.setAttribute(
      "class",
      "svg-pan-zoom-control-background"
    ), t.appendChild(n);
    var o = document.createElementNS(
      ge.svgNS,
      "path"
    );
    o.setAttribute(
      "d",
      "M33.051,20.632c-0.742-0.406-1.854-0.609-3.338-0.609h-7.969v9.281h7.769c1.543,0,2.701-0.188,3.473-0.562c1.365-0.656,2.048-1.953,2.048-3.891C35.032,22.757,34.372,21.351,33.051,20.632z"
    ), o.setAttribute(
      "class",
      "svg-pan-zoom-control-element"
    ), t.appendChild(o);
    var i = document.createElementNS(
      ge.svgNS,
      "path"
    );
    return i.setAttribute(
      "d",
      "M170.231,0.5H15.847C7.102,0.5,0.5,5.708,0.5,11.84v38.861C0.5,56.833,7.102,61.5,15.847,61.5h154.384c8.745,0,15.269-4.667,15.269-10.798V11.84C185.5,5.708,178.976,0.5,170.231,0.5z M42.837,48.569h-7.969c-0.219-0.766-0.375-1.383-0.469-1.852c-0.188-0.969-0.289-1.961-0.305-2.977l-0.047-3.211c-0.03-2.203-0.41-3.672-1.142-4.406c-0.732-0.734-2.103-1.102-4.113-1.102h-7.05v13.547h-7.055V14.022h16.524c2.361,0.047,4.178,0.344,5.45,0.891c1.272,0.547,2.351,1.352,3.234,2.414c0.731,0.875,1.31,1.844,1.737,2.906s0.64,2.273,0.64,3.633c0,1.641-0.414,3.254-1.242,4.84s-2.195,2.707-4.102,3.363c1.594,0.641,2.723,1.551,3.387,2.73s0.996,2.98,0.996,5.402v2.32c0,1.578,0.063,2.648,0.19,3.211c0.19,0.891,0.635,1.547,1.333,1.969V48.569z M75.579,48.569h-26.18V14.022h25.336v6.117H56.454v7.336h16.781v6H56.454v8.883h19.125V48.569z M104.497,46.331c-2.44,2.086-5.887,3.129-10.34,3.129c-4.548,0-8.125-1.027-10.731-3.082s-3.909-4.879-3.909-8.473h6.891c0.224,1.578,0.662,2.758,1.316,3.539c1.196,1.422,3.246,2.133,6.15,2.133c1.739,0,3.151-0.188,4.236-0.562c2.058-0.719,3.087-2.055,3.087-4.008c0-1.141-0.504-2.023-1.512-2.648c-1.008-0.609-2.607-1.148-4.796-1.617l-3.74-0.82c-3.676-0.812-6.201-1.695-7.576-2.648c-2.328-1.594-3.492-4.086-3.492-7.477c0-3.094,1.139-5.664,3.417-7.711s5.623-3.07,10.036-3.07c3.685,0,6.829,0.965,9.431,2.895c2.602,1.93,3.966,4.73,4.093,8.402h-6.938c-0.128-2.078-1.057-3.555-2.787-4.43c-1.154-0.578-2.587-0.867-4.301-0.867c-1.907,0-3.428,0.375-4.565,1.125c-1.138,0.75-1.706,1.797-1.706,3.141c0,1.234,0.561,2.156,1.682,2.766c0.721,0.406,2.25,0.883,4.589,1.43l6.063,1.43c2.657,0.625,4.648,1.461,5.975,2.508c2.059,1.625,3.089,3.977,3.089,7.055C108.157,41.624,106.937,44.245,104.497,46.331z M139.61,48.569h-26.18V14.022h25.336v6.117h-18.281v7.336h16.781v6h-16.781v8.883h19.125V48.569z M170.337,20.14h-10.336v28.43h-7.266V20.14h-10.383v-6.117h27.984V20.14z"
    ), i.setAttribute(
      "class",
      "svg-pan-zoom-control-element"
    ), t.appendChild(i), t;
  },
  _createZoomOut: function(e) {
    var t = document.createElementNS(ge.svgNS, "g");
    t.setAttribute("id", "svg-pan-zoom-zoom-out"), t.setAttribute("transform", "translate(30.5 70) scale(0.015)"), t.setAttribute("class", "svg-pan-zoom-control"), t.addEventListener(
      "click",
      function() {
        e.getPublicInstance().zoomOut();
      },
      !1
    ), t.addEventListener(
      "touchstart",
      function() {
        e.getPublicInstance().zoomOut();
      },
      !1
    );
    var n = document.createElementNS(ge.svgNS, "rect");
    n.setAttribute("x", "0"), n.setAttribute("y", "0"), n.setAttribute("width", "1500"), n.setAttribute("height", "1400"), n.setAttribute("class", "svg-pan-zoom-control-background"), t.appendChild(n);
    var o = document.createElementNS(ge.svgNS, "path");
    return o.setAttribute(
      "d",
      "M1280 576v128q0 26 -19 45t-45 19h-896q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h896q26 0 45 19t19 45zM1536 1120v-960q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5 t84.5 -203.5z"
    ), o.setAttribute("class", "svg-pan-zoom-control-element"), t.appendChild(o), t;
  },
  disable: function(e) {
    e.controlIcons && (e.controlIcons.parentNode.removeChild(e.controlIcons), e.controlIcons = null);
  }
}, Qu = Bn, Ne = Gt, oe = function(e, t) {
  this.init(e, t);
};
oe.prototype.init = function(e, t) {
  this.viewport = e, this.options = t, this.originalState = { zoom: 1, x: 0, y: 0 }, this.activeState = { zoom: 1, x: 0, y: 0 }, this.updateCTMCached = Ne.proxy(this.updateCTM, this), this.requestAnimationFrame = Ne.createRequestAnimationFrame(
    this.options.refreshRate
  ), this.viewBox = { x: 0, y: 0, width: 0, height: 0 }, this.cacheViewBox();
  var n = this.processCTM();
  this.setCTM(n), this.updateCTM();
};
oe.prototype.cacheViewBox = function() {
  var e = this.options.svg.getAttribute("viewBox");
  if (e) {
    var t = e.split(/[\s\,]/).filter(function(o) {
      return o;
    }).map(parseFloat);
    this.viewBox.x = t[0], this.viewBox.y = t[1], this.viewBox.width = t[2], this.viewBox.height = t[3];
    var n = Math.min(
      this.options.width / this.viewBox.width,
      this.options.height / this.viewBox.height
    );
    this.activeState.zoom = isFinite(n) ? n : 1, this.activeState.x = (this.options.width - this.viewBox.width * n) / 2, this.activeState.y = (this.options.height - this.viewBox.height * n) / 2, this.updateCTMOnNextFrame(), this.options.svg.removeAttribute("viewBox");
  } else
    this.simpleViewBoxCache();
};
oe.prototype.simpleViewBoxCache = function() {
  var e = this.viewport.getBBox();
  this.viewBox.x = e.x, this.viewBox.y = e.y, this.viewBox.width = e.width, this.viewBox.height = e.height;
};
oe.prototype.getViewBox = function() {
  return Ne.extend({}, this.viewBox);
};
oe.prototype.processCTM = function() {
  var e = this.getCTM();
  if (this.options.fit || this.options.contain) {
    var t;
    this.options.fit ? t = Math.min(
      this.options.width / this.viewBox.width,
      this.options.height / this.viewBox.height
    ) : t = Math.max(
      this.options.width / this.viewBox.width,
      this.options.height / this.viewBox.height
    ), t = isFinite(t) ? t : 1, e.a = t, e.d = t, e.e = -this.viewBox.x * t, e.f = -this.viewBox.y * t;
  }
  if (this.options.center) {
    var n = (this.options.width - (this.viewBox.width + this.viewBox.x * 2) * e.a) * 0.5, o = (this.options.height - (this.viewBox.height + this.viewBox.y * 2) * e.a) * 0.5;
    e.e = n, e.f = o;
  }
  return this.originalState.zoom = e.a, this.originalState.x = e.e, this.originalState.y = e.f, e;
};
oe.prototype.getOriginalState = function() {
  return Ne.extend({}, this.originalState);
};
oe.prototype.getState = function() {
  return Ne.extend({}, this.activeState);
};
oe.prototype.getZoom = function() {
  return this.activeState.zoom;
};
oe.prototype.getRelativeZoom = function() {
  return this.activeState.zoom / this.originalState.zoom;
};
oe.prototype.computeRelativeZoom = function(e) {
  return e / this.originalState.zoom;
};
oe.prototype.getPan = function() {
  return { x: this.activeState.x, y: this.activeState.y };
};
oe.prototype.getCTM = function() {
  var e = this.options.svg.createSVGMatrix();
  return e.a = this.activeState.zoom, e.b = 0, e.c = 0, e.d = this.activeState.zoom, e.e = this.activeState.x, e.f = this.activeState.y, e;
};
oe.prototype.setCTM = function(e) {
  var t = this.isZoomDifferent(e), n = this.isPanDifferent(e);
  if (t || n) {
    if (t && (this.options.beforeZoom(
      this.getRelativeZoom(),
      this.computeRelativeZoom(e.a)
    ) === !1 ? (e.a = e.d = this.activeState.zoom, t = !1) : (this.updateCache(e), this.options.onZoom(this.getRelativeZoom()))), n) {
      var o = this.options.beforePan(this.getPan(), {
        x: e.e,
        y: e.f
      }), i = !1, r = !1;
      o === !1 ? (e.e = this.getPan().x, e.f = this.getPan().y, i = r = !0) : Ne.isObject(o) && (o.x === !1 ? (e.e = this.getPan().x, i = !0) : Ne.isNumber(o.x) && (e.e = o.x), o.y === !1 ? (e.f = this.getPan().y, r = !0) : Ne.isNumber(o.y) && (e.f = o.y)), i && r || !this.isPanDifferent(e) ? n = !1 : (this.updateCache(e), this.options.onPan(this.getPan()));
    }
    (t || n) && this.updateCTMOnNextFrame();
  }
};
oe.prototype.isZoomDifferent = function(e) {
  return this.activeState.zoom !== e.a;
};
oe.prototype.isPanDifferent = function(e) {
  return this.activeState.x !== e.e || this.activeState.y !== e.f;
};
oe.prototype.updateCache = function(e) {
  this.activeState.zoom = e.a, this.activeState.x = e.e, this.activeState.y = e.f;
};
oe.prototype.pendingUpdate = !1;
oe.prototype.updateCTMOnNextFrame = function() {
  this.pendingUpdate || (this.pendingUpdate = !0, this.requestAnimationFrame.call(window, this.updateCTMCached));
};
oe.prototype.updateCTM = function() {
  var e = this.getCTM();
  Qu.setCTM(this.viewport, e, this.defs), this.pendingUpdate = !1, this.options.onUpdatedCTM && this.options.onUpdatedCTM(e);
};
var Ju = function(e, t) {
  return new oe(e, t);
}, Ni = Ku, wn = Yu, he = Gt, ae = Bn, ed = Ju, U = function(e, t) {
  this.init(e, t);
}, td = {
  viewportSelector: ".svg-pan-zoom_viewport",
  // Viewport selector. Can be querySelector string or SVGElement
  panEnabled: !0,
  // enable or disable panning (default enabled)
  controlIconsEnabled: !1,
  // insert icons to give user an option in addition to mouse events to control pan/zoom (default disabled)
  zoomEnabled: !0,
  // enable or disable zooming (default enabled)
  dblClickZoomEnabled: !0,
  // enable or disable zooming by double clicking (default enabled)
  mouseWheelZoomEnabled: !0,
  // enable or disable zooming by mouse wheel (default enabled)
  preventMouseEventsDefault: !0,
  // enable or disable preventDefault for mouse events
  zoomScaleSensitivity: 0.1,
  // Zoom sensitivity
  minZoom: 0.5,
  // Minimum Zoom level
  maxZoom: 10,
  // Maximum Zoom level
  fit: !0,
  // enable or disable viewport fit in SVG (default true)
  contain: !1,
  // enable or disable viewport contain the svg (default false)
  center: !0,
  // enable or disable viewport centering in SVG (default true)
  refreshRate: "auto",
  // Maximum number of frames per second (altering SVG's viewport)
  beforeZoom: null,
  onZoom: null,
  beforePan: null,
  onPan: null,
  customEventsHandler: null,
  eventsListenerElement: null,
  onUpdatedCTM: null
}, Di = { passive: !0 }, Zi = { passive: !1 };
U.prototype.init = function(e, t) {
  var n = this;
  this.svg = e, this.defs = e.querySelector("defs"), ae.setupSvgAttributes(this.svg), this.options = he.extend(he.extend({}, td), t), this.state = "none";
  var o = ae.getBoundingClientRectNormalized(e);
  this.width = o.width, this.height = o.height, this.viewport = ed(
    ae.getOrCreateViewport(this.svg, this.options.viewportSelector),
    {
      svg: this.svg,
      width: this.width,
      height: this.height,
      fit: this.options.fit,
      contain: this.options.contain,
      center: this.options.center,
      refreshRate: this.options.refreshRate,
      // Put callbacks into functions as they can change through time
      beforeZoom: function(r, s) {
        if (n.viewport && n.options.beforeZoom)
          return n.options.beforeZoom(r, s);
      },
      onZoom: function(r) {
        if (n.viewport && n.options.onZoom)
          return n.options.onZoom(r);
      },
      beforePan: function(r, s) {
        if (n.viewport && n.options.beforePan)
          return n.options.beforePan(r, s);
      },
      onPan: function(r) {
        if (n.viewport && n.options.onPan)
          return n.options.onPan(r);
      },
      onUpdatedCTM: function(r) {
        if (n.viewport && n.options.onUpdatedCTM)
          return n.options.onUpdatedCTM(r);
      }
    }
  );
  var i = this.getPublicInstance();
  i.setBeforeZoom(this.options.beforeZoom), i.setOnZoom(this.options.onZoom), i.setBeforePan(this.options.beforePan), i.setOnPan(this.options.onPan), i.setOnUpdatedCTM(this.options.onUpdatedCTM), this.options.controlIconsEnabled && wn.enable(this), this.lastMouseWheelEventTime = Date.now(), this.setupHandlers();
};
U.prototype.setupHandlers = function() {
  var e = this, t = null;
  if (this.eventListeners = {
    // Mouse down group
    pointerdown: function(r) {
      if (r.pointerType !== "touch") {
        var s = e.handleMouseDown(r, t);
        return t = r, s;
      }
    },
    touchstart: function(r) {
      var s = e.handleTouchStart(r, t);
      return t = r, s;
    },
    // Mouse up group
    pointerup: function(r) {
      if (r.pointerType !== "touch")
        return e.handleMouseUp(r);
    },
    touchend: function(r) {
      return e.handleTouchEnd(r);
    },
    // Mouse move group
    pointermove: function(r) {
      if (r.pointerType !== "touch")
        return e.handleMouseMove(r);
    },
    touchmove: function(r) {
      return e.handleTouchMove(r);
    },
    // Mouse leave group
    pointerleave: function(r) {
      if (r.pointerType !== "touch")
        return e.handleMouseUp(r);
    },
    pointercancel: function(r) {
      if (r.pointerType !== "touch")
        return e.handleMouseUp(r);
    },
    touchleave: function(r) {
      return e.handleTouchEnd(r);
    },
    touchcancel: function(r) {
      return e.handleTouchEnd(r);
    }
  }, this.options.customEventsHandler != null) {
    this.options.customEventsHandler.init({
      svgElement: this.svg,
      eventsListenerElement: this.options.eventsListenerElement,
      instance: this.getPublicInstance()
    });
    var n = this.options.customEventsHandler.haltEventListeners;
    if (n && n.length)
      for (var o = n.length - 1; o >= 0; o--)
        this.eventListeners.hasOwnProperty(n[o]) && delete this.eventListeners[n[o]];
  }
  for (var i in this.eventListeners)
    (this.options.eventsListenerElement || this.svg).addEventListener(
      i,
      this.eventListeners[i],
      this.options.preventMouseEventsDefault ? Zi : Di
    );
  this.options.mouseWheelZoomEnabled && (this.options.mouseWheelZoomEnabled = !1, this.enableMouseWheelZoom());
};
U.prototype.enableMouseWheelZoom = function() {
  if (!this.options.mouseWheelZoomEnabled) {
    var e = this;
    this.wheelListener = function(n) {
      return e.handleMouseWheel(n);
    };
    var t = !this.options.preventMouseEventsDefault;
    Ni.on(
      this.options.eventsListenerElement || this.svg,
      this.wheelListener,
      t
    ), this.options.mouseWheelZoomEnabled = !0;
  }
};
U.prototype.disableMouseWheelZoom = function() {
  if (this.options.mouseWheelZoomEnabled) {
    var e = !this.options.preventMouseEventsDefault;
    Ni.off(
      this.options.eventsListenerElement || this.svg,
      this.wheelListener,
      e
    ), this.options.mouseWheelZoomEnabled = !1;
  }
};
U.prototype.handleMouseWheel = function(e) {
  if (!(!this.options.zoomEnabled || this.state !== "none")) {
    this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1);
    var t = e.deltaY || 1, n = Date.now() - this.lastMouseWheelEventTime, o = 3 + Math.max(0, 30 - n);
    this.lastMouseWheelEventTime = Date.now(), "deltaMode" in e && e.deltaMode === 0 && e.wheelDelta && (t = e.deltaY === 0 ? 0 : Math.abs(e.wheelDelta) / e.deltaY), t = -0.3 < t && t < 0.3 ? t : (t > 0 ? 1 : -1) * Math.log(Math.abs(t) + 10) / o;
    var i = this.svg.getScreenCTM().inverse(), r = ae.getEventPoint(e, this.svg).matrixTransform(
      i
    ), s = Math.pow(1 + this.options.zoomScaleSensitivity, -1 * t);
    this.zoomAtPoint(s, r);
  }
};
U.prototype.zoomAtPoint = function(e, t, n) {
  var o = this.viewport.getOriginalState();
  n ? (e = Math.max(
    this.options.minZoom * o.zoom,
    Math.min(this.options.maxZoom * o.zoom, e)
  ), e = e / this.getZoom()) : this.getZoom() * e < this.options.minZoom * o.zoom ? e = this.options.minZoom * o.zoom / this.getZoom() : this.getZoom() * e > this.options.maxZoom * o.zoom && (e = this.options.maxZoom * o.zoom / this.getZoom());
  var i = this.viewport.getCTM(), r = t.matrixTransform(i.inverse()), s = this.svg.createSVGMatrix().translate(r.x, r.y).scale(e).translate(-r.x, -r.y), a = i.multiply(s);
  a.a !== i.a && this.viewport.setCTM(a);
};
U.prototype.zoom = function(e, t) {
  this.zoomAtPoint(
    e,
    ae.getSvgCenterPoint(this.svg, this.width, this.height),
    t
  );
};
U.prototype.publicZoom = function(e, t) {
  t && (e = this.computeFromRelativeZoom(e)), this.zoom(e, t);
};
U.prototype.publicZoomAtPoint = function(e, t, n) {
  if (n && (e = this.computeFromRelativeZoom(e)), he.getType(t) !== "SVGPoint")
    if ("x" in t && "y" in t)
      t = ae.createSVGPoint(this.svg, t.x, t.y);
    else
      throw new Error("Given point is invalid");
  this.zoomAtPoint(e, t, n);
};
U.prototype.getZoom = function() {
  return this.viewport.getZoom();
};
U.prototype.getRelativeZoom = function() {
  return this.viewport.getRelativeZoom();
};
U.prototype.computeFromRelativeZoom = function(e) {
  return e * this.viewport.getOriginalState().zoom;
};
U.prototype.resetZoom = function() {
  var e = this.viewport.getOriginalState();
  this.zoom(e.zoom, !0);
};
U.prototype.resetPan = function() {
  this.pan(this.viewport.getOriginalState());
};
U.prototype.reset = function() {
  this.resetZoom(), this.resetPan();
};
U.prototype.handleDblClick = function(e) {
  if (this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.options.controlIconsEnabled) {
    var t = e.target.getAttribute("class") || "";
    if (t.indexOf("svg-pan-zoom-control") > -1)
      return !1;
  }
  var n;
  e.shiftKey ? n = 1 / ((1 + this.options.zoomScaleSensitivity) * 2) : n = (1 + this.options.zoomScaleSensitivity) * 2;
  var o = ae.getEventPoint(e, this.svg).matrixTransform(
    this.svg.getScreenCTM().inverse()
  );
  this.zoomAtPoint(n, o);
};
U.prototype.handleMouseDown = function(e, t) {
  this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), he.mouseAndTouchNormalize(e, this.svg), this.options.dblClickZoomEnabled && he.isDblClick(e, t) ? this.handleDblClick(e) : (this.state = "pan", this.firstEventCTM = this.viewport.getCTM(), this.stateOrigin = ae.getEventPoint(e, this.svg).matrixTransform(
    this.firstEventCTM.inverse()
  ));
};
U.prototype.handleMouseMove = function(e) {
  if (this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.state === "pan" && this.options.panEnabled) {
    var t = ae.getEventPoint(e, this.svg).matrixTransform(
      this.firstEventCTM.inverse()
    ), n = this.firstEventCTM.translate(
      t.x - this.stateOrigin.x,
      t.y - this.stateOrigin.y
    );
    this.viewport.setCTM(n);
  }
};
U.prototype.handleMouseUp = function(e) {
  this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.state === "pan" && (this.state = "none");
};
U.prototype.handleTouchStart = function(e, t) {
  if (e.touches.length == 1)
    this.handleMouseDown(e, t);
  else {
    this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.firstEventCTM = this.viewport.getCTM();
    var n = ae.getTouchPoint(e, this.svg, 0), o = ae.getTouchPoint(e, this.svg, 1);
    this.firstDistance = he.calculateDistance(n, o), n.x = (n.x + o.x) / 2, n.y = (n.y + o.y) / 2, this.stateOrigin = n.matrixTransform(this.firstEventCTM.inverse()), this.firstZoomLevel = this.getZoom();
  }
};
U.prototype.handleTouchMove = function(e) {
  if (e.touches.length == 1)
    this.handleMouseMove(e);
  else {
    if (this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), !this.options.panEnabled && !this.options.zoomEnabled)
      return;
    var t = ae.getTouchPoint(e, this.svg, 0), n = ae.getTouchPoint(e, this.svg, 1), o = this.svg.createSVGPoint();
    if (o.x = (t.x + n.x) / 2, o.y = (t.y + n.y) / 2, this.state === "pan" && this.options.panEnabled) {
      var i = o.matrixTransform(this.firstEventCTM.inverse()), r = this.firstEventCTM.translate(
        i.x - this.stateOrigin.x,
        i.y - this.stateOrigin.y
      );
      this.viewport.setCTM(r);
    }
    if (this.options.zoomEnabled) {
      var s = he.calculateDistance(t, n), a = s / this.firstDistance, l = this.svg.getScreenCTM().inverse(), u = o.matrixTransform(l);
      this.zoomAtPoint(this.firstZoomLevel * a, u, !0);
    }
  }
};
U.prototype.handleTouchEnd = function(e) {
  if (e.touches.length == 0)
    this.handleMouseUp(e);
  else if (this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.firstEventCTM = this.viewport.getCTM(), e.touches.length == 1)
    this.stateOrigin = ae.getEventPoint(e, this.svg).matrixTransform(
      this.firstEventCTM.inverse()
    );
  else {
    var t = ae.getTouchPoint(e, this.svg, 0), n = ae.getTouchPoint(e, this.svg, 1);
    this.firstDistance = he.calculateDistance(t, n), t.x = (t.x + n.x) / 2, t.y = (t.y + n.y) / 2, this.stateOrigin = t.matrixTransform(this.firstEventCTM.inverse());
  }
};
U.prototype.fit = function() {
  var e = this.viewport.getViewBox(), t = Math.min(
    this.width / e.width,
    this.height / e.height
  );
  this.zoom(t, !0);
};
U.prototype.contain = function() {
  var e = this.viewport.getViewBox(), t = Math.max(
    this.width / e.width,
    this.height / e.height
  );
  this.zoom(t, !0);
};
U.prototype.center = function() {
  var e = this.viewport.getViewBox(), t = (this.width - (e.width + e.x * 2) * this.getZoom()) * 0.5, n = (this.height - (e.height + e.y * 2) * this.getZoom()) * 0.5;
  this.getPublicInstance().pan({ x: t, y: n });
};
U.prototype.updateBBox = function() {
  this.viewport.simpleViewBoxCache();
};
U.prototype.pan = function(e) {
  var t = this.viewport.getCTM();
  t.e = e.x, t.f = e.y, this.viewport.setCTM(t);
};
U.prototype.panBy = function(e) {
  var t = this.viewport.getCTM();
  t.e += e.x, t.f += e.y, this.viewport.setCTM(t);
};
U.prototype.getPan = function() {
  var e = this.viewport.getState();
  return { x: e.x, y: e.y };
};
U.prototype.resize = function() {
  var e = ae.getBoundingClientRectNormalized(
    this.svg
  );
  this.width = e.width, this.height = e.height;
  var t = this.viewport;
  t.options.width = this.width, t.options.height = this.height, t.processCTM(), this.options.controlIconsEnabled && (this.getPublicInstance().disableControlIcons(), this.getPublicInstance().enableControlIcons());
};
U.prototype.destroy = function() {
  var e = this;
  this.beforeZoom = null, this.onZoom = null, this.beforePan = null, this.onPan = null, this.onUpdatedCTM = null, this.options.customEventsHandler != null && this.options.customEventsHandler.destroy({
    svgElement: this.svg,
    eventsListenerElement: this.options.eventsListenerElement,
    instance: this.getPublicInstance()
  });
  for (var t in this.eventListeners)
    (this.options.eventsListenerElement || this.svg).removeEventListener(
      t,
      this.eventListeners[t],
      this.options.preventMouseEventsDefault ? Zi : Di
    );
  this.disableMouseWheelZoom(), this.getPublicInstance().disableControlIcons(), Ie = Ie.filter(function(n) {
    return n.svg !== e.svg;
  }), delete this.options, delete this.viewport, delete this.publicInstance, delete this.pi, this.getPublicInstance = function() {
    return null;
  };
};
U.prototype.getPublicInstance = function() {
  var e = this;
  return this.publicInstance || (this.publicInstance = this.pi = {
    // Pan
    enablePan: function() {
      return e.options.panEnabled = !0, e.pi;
    },
    disablePan: function() {
      return e.options.panEnabled = !1, e.pi;
    },
    isPanEnabled: function() {
      return !!e.options.panEnabled;
    },
    pan: function(t) {
      return e.pan(t), e.pi;
    },
    panBy: function(t) {
      return e.panBy(t), e.pi;
    },
    getPan: function() {
      return e.getPan();
    },
    // Pan event
    setBeforePan: function(t) {
      return e.options.beforePan = t === null ? null : he.proxy(t, e.publicInstance), e.pi;
    },
    setOnPan: function(t) {
      return e.options.onPan = t === null ? null : he.proxy(t, e.publicInstance), e.pi;
    },
    // Zoom and Control Icons
    enableZoom: function() {
      return e.options.zoomEnabled = !0, e.pi;
    },
    disableZoom: function() {
      return e.options.zoomEnabled = !1, e.pi;
    },
    isZoomEnabled: function() {
      return !!e.options.zoomEnabled;
    },
    enableControlIcons: function() {
      return e.options.controlIconsEnabled || (e.options.controlIconsEnabled = !0, wn.enable(e)), e.pi;
    },
    disableControlIcons: function() {
      return e.options.controlIconsEnabled && (e.options.controlIconsEnabled = !1, wn.disable(e)), e.pi;
    },
    isControlIconsEnabled: function() {
      return !!e.options.controlIconsEnabled;
    },
    // Double click zoom
    enableDblClickZoom: function() {
      return e.options.dblClickZoomEnabled = !0, e.pi;
    },
    disableDblClickZoom: function() {
      return e.options.dblClickZoomEnabled = !1, e.pi;
    },
    isDblClickZoomEnabled: function() {
      return !!e.options.dblClickZoomEnabled;
    },
    // Mouse wheel zoom
    enableMouseWheelZoom: function() {
      return e.enableMouseWheelZoom(), e.pi;
    },
    disableMouseWheelZoom: function() {
      return e.disableMouseWheelZoom(), e.pi;
    },
    isMouseWheelZoomEnabled: function() {
      return !!e.options.mouseWheelZoomEnabled;
    },
    // Zoom scale and bounds
    setZoomScaleSensitivity: function(t) {
      return e.options.zoomScaleSensitivity = t, e.pi;
    },
    setMinZoom: function(t) {
      return e.options.minZoom = t, e.pi;
    },
    setMaxZoom: function(t) {
      return e.options.maxZoom = t, e.pi;
    },
    // Zoom event
    setBeforeZoom: function(t) {
      return e.options.beforeZoom = t === null ? null : he.proxy(t, e.publicInstance), e.pi;
    },
    setOnZoom: function(t) {
      return e.options.onZoom = t === null ? null : he.proxy(t, e.publicInstance), e.pi;
    },
    // Zooming
    zoom: function(t) {
      return e.publicZoom(t, !0), e.pi;
    },
    zoomBy: function(t) {
      return e.publicZoom(t, !1), e.pi;
    },
    zoomAtPoint: function(t, n) {
      return e.publicZoomAtPoint(t, n, !0), e.pi;
    },
    zoomAtPointBy: function(t, n) {
      return e.publicZoomAtPoint(t, n, !1), e.pi;
    },
    zoomIn: function() {
      return this.zoomBy(1 + e.options.zoomScaleSensitivity), e.pi;
    },
    zoomOut: function() {
      return this.zoomBy(1 / (1 + e.options.zoomScaleSensitivity)), e.pi;
    },
    getZoom: function() {
      return e.getRelativeZoom();
    },
    // CTM update
    setOnUpdatedCTM: function(t) {
      return e.options.onUpdatedCTM = t === null ? null : he.proxy(t, e.publicInstance), e.pi;
    },
    // Reset
    resetZoom: function() {
      return e.resetZoom(), e.pi;
    },
    resetPan: function() {
      return e.resetPan(), e.pi;
    },
    reset: function() {
      return e.reset(), e.pi;
    },
    // Fit, Contain and Center
    fit: function() {
      return e.fit(), e.pi;
    },
    contain: function() {
      return e.contain(), e.pi;
    },
    center: function() {
      return e.center(), e.pi;
    },
    // Size and Resize
    updateBBox: function() {
      return e.updateBBox(), e.pi;
    },
    resize: function() {
      return e.resize(), e.pi;
    },
    getSizes: function() {
      return {
        width: e.width,
        height: e.height,
        realZoom: e.getZoom(),
        viewBox: e.viewport.getViewBox()
      };
    },
    // Destroy
    destroy: function() {
      return e.destroy(), e.pi;
    }
  }), this.publicInstance;
};
var Ie = [], nd = function(e, t) {
  var n = he.getSvg(e);
  if (n === null)
    return null;
  for (var o = Ie.length - 1; o >= 0; o--)
    if (Ie[o].svg === n)
      return Ie[o].instance.getPublicInstance();
  return Ie.push({
    svg: n,
    instance: new U(n, t)
  }), Ie[Ie.length - 1].instance.getPublicInstance();
}, od = nd;
const id = {
  fitToContents() {
    return this.fit().center().zoomOut().zoomOut(), this;
  },
  getViewArea() {
    const e = this.getSizes(), t = this.getPan(), n = e.realZoom;
    t.x /= n, t.y /= n;
    const o = {
      width: e.width / n,
      height: e.height / n
    };
    return {
      box: {
        top: -t.y,
        bottom: o.height - t.y,
        left: -t.x,
        right: o.width - t.x
      },
      center: {
        x: o.width / 2 - t.x,
        y: o.height / 2 - t.y
      }
    };
  },
  getViewBox() {
    return this.getViewArea().box;
  },
  setViewBox(e) {
    const t = e.right - e.left, n = e.bottom - e.top, { width: o, height: i } = this.getSizes(), r = t / n, s = o / i, a = r < s ? n * s : t, l = r > s ? t / s : n, u = Math.min(
      o / a,
      i / l
    ), c = this.getRealZoom(), f = this.getZoom(), d = c / f;
    this.zoom(u / d);
    const v = {
      x: (e.left + t / 2) * u,
      y: (e.top + n / 2) * u
    };
    this.pan({
      x: -v.x + a / 2 * u,
      y: -v.y + l / 2 * u
    });
  },
  getRealZoom() {
    return this.getSizes().realZoom;
  },
  applyAbsoluteZoomLevel(e, t, n) {
    const o = Math.max(1e-4, t), i = Math.max(o, n), r = Math.max(Math.min(i, e), o), s = this.getRealZoom(), a = this.getZoom(), l = s / a;
    this.setMinZoom(o / l).setMaxZoom(i / l).zoom(r / l);
  },
  isPanEnabled() {
    return this._isPanEnabled;
  },
  enablePan() {
    return this._isPanEnabled = !0, this._internalEnablePan(), this;
  },
  disablePan() {
    return this._isPanEnabled = !1, this._internalDisablePan(), this;
  },
  isZoomEnabled() {
    return this._isZoomEnabled;
  },
  enableZoom() {
    return this._isZoomEnabled = !0, this._internalEnableZoom(), this;
  },
  disableZoom() {
    return this._isZoomEnabled = !1, this._internalDisableZoom(), this;
  },
  setPanEnabled(e) {
    return e ? this.enablePan() : this.disablePan(), this;
  },
  setZoomEnabled(e) {
    return e ? (this.enableZoom(), this.enableDblClickZoom()) : (this.disableZoom(), this.disableDblClickZoom()), this;
  }
};
function rd(e, t) {
  var o, i;
  const n = e;
  return n._isPanEnabled = (o = t.panEnabled) != null ? o : !0, n._isZoomEnabled = (i = t == null ? void 0 : t.zoomEnabled) != null ? i : !0, n._internalIsPanEnabled = n.isPanEnabled, n._internalEnablePan = n.enablePan, n._internalDisablePan = n.disablePan, n._internalIsZoomEnabled = n.isZoomEnabled, n._internalEnableZoom = n.enableZoom, n._internalDisableZoom = n.disableZoom, Object.assign(e, id), n;
}
function sd(e, t) {
  var r, s, a, l, u, c;
  const n = (s = (r = t.customEventsHandler) == null ? void 0 : r.init) != null ? s : (f) => {
  }, o = (l = (a = t.customEventsHandler) == null ? void 0 : a.destroy) != null ? l : (f) => {
  }, i = (c = (u = t.customEventsHandler) == null ? void 0 : u.haltEventListeners) != null ? c : [];
  return t.mouseWheelZoomEnabled === void 0 && (t.mouseWheelZoomEnabled = t.zoomEnabled), t.customEventsHandler = {
    init: (f) => {
      rd(f.instance, t), n(f);
    },
    destroy: (f) => o(f),
    haltEventListeners: i
  }, od(e, t);
}
function ad(e, t) {
  const n = Z();
  let o = 0;
  const i = [], r = [], s = () => {
    o = 1, i.forEach((c) => c()), i.length = 0;
  }, a = () => {
    o = 2, r.forEach((c) => c()), r.length = 0;
  };
  return rt(() => {
    var P, E, p, m, w, b;
    const c = q(e.value, "<svg>"), f = (E = (P = t.customEventsHandler) == null ? void 0 : P.init) != null ? E : (h) => {
    }, d = (m = (p = t.customEventsHandler) == null ? void 0 : p.destroy) != null ? m : (h) => {
    }, v = (b = (w = t.customEventsHandler) == null ? void 0 : w.haltEventListeners) != null ? b : [];
    t.customEventsHandler = {
      init: (h) => {
        n.value = h.instance, f(h), s();
      },
      destroy: (h) => {
        a(), d(h);
      },
      haltEventListeners: v
    };
    const x = () => {
      const h = c.getBoundingClientRect();
      h.width !== 0 && h.height !== 0 ? sd(c, t) : setTimeout(x, 200);
    };
    x();
  }), bt(() => {
    var c;
    (c = n.value) == null || c.destroy(), n.value = void 0;
  }), { svgPanZoom: n, onSvgPanZoomMounted: (c) => {
    o === 0 ? i.push(c) : o === 1 && c();
  }, onSvgPanZoomUnmounted: (c) => {
    o === 0 || o === 1 ? r.push(c) : c();
  } };
}
const ji = Symbol("zoomLevel");
function ld(e, t) {
  const n = O(() => t.scalingObjects ? 1 : 1 / e.value);
  return je(ji, {
    zoomLevel: e,
    scale: n
  }), { scale: n };
}
function be() {
  return q(Be(ji), "zoomLevel");
}
function cd(e) {
  return e instanceof Promise || e && typeof e.then == "function";
}
function ud() {
  let e = null;
  const t = Z({
    enabled: !1,
    duration: 300,
    timingFunction: "linear"
  });
  function n(o, i = 300, r = "linear") {
    e && (clearTimeout(e), e = null), t.value = {
      enabled: !0,
      duration: i,
      timingFunction: r
    }, Ct(() => Re(this, null, function* () {
      const s = o();
      cd(s) && (yield s), e && clearTimeout(e), e = window == null ? void 0 : window.setTimeout(() => {
        t.value.enabled = !1, e = null;
      }, i);
    }));
  }
  return { transitionWhile: n, transitionOption: t };
}
function dd(e) {
  const t = Z({}), n = Z(!1);
  let o = 1;
  const i = /* @__PURE__ */ new Map();
  return me(() => {
    if (e.value instanceof Array) {
      const r = /* @__PURE__ */ new Set([]);
      if (t.value = Object.fromEntries(
        e.value.map((s) => {
          let a = s.id;
          return a || (n.value || (n.value = !0, console.warn(
            "[v-network-graph] Please specify the `id` field for the `Path` object. Currently, this works for compatibility, but in the future, the id field will be required."
          )), a = i.get(s), a || (a = "path-" + o++, i.set(s, a))), r.add(a), [a, s];
        })
      ), n.value)
        for (const [s, a] of Array.from(i.entries()))
          r.has(a) || i.delete(s);
    } else
      t.value = e.value;
  }), { objects: t, isInCompatibilityModeForPath: n };
}
function fd(e, t, n, o) {
  if (o) {
    const r = Z(o(e[t])), s = (a) => {
      We(a, r.value) || (r.value = a), We(a, e[t]) || n(`update:${t}`, a);
    };
    return G(() => o(r.value), s), G(() => e[t], (a) => s(o(a))), r.value !== e[t] && n(`update:${t}`, r.value), r;
  }
  const i = Z(e[t]);
  return G(
    () => e[t],
    (r) => {
      We(r, i.value) || (i.value = r);
    }
  ), G(i, (r) => {
    We(r, e[t]) || n(`update:${t}`, r);
  }), i;
}
function cn(e, t, n, o) {
  const i = Ce(/* @__PURE__ */ new Set());
  return G(
    () => e[t],
    () => {
      const s = e[t].filter((a) => a in n.value);
      We(s, Array.from(i)) || (i.clear(), s.forEach(i.add, i));
    },
    { deep: !0, immediate: !0 }
  ), G(i, () => {
    const r = Array.from(i);
    We(e[t], r) || o(`update:${t}`, r);
  }), Ae(i);
}
const Bi = Symbol("selection");
function hd(e, t, n) {
  je(Bi, {
    selectedNodes: e,
    selectedEdges: t,
    selectedPaths: n
  });
}
function vd() {
  return q(Be(Bi), "Selections");
}
const Ri = Symbol("layouts");
function pd(e) {
  je(Ri, e);
}
function Rn() {
  return q(Be(Ri), "Layouts");
}
function gd(e, t) {
  for (let n = 0; n < e.length - 1; n++)
    t(e[n], e[n + 1]);
}
function ut(e, t) {
  const n = e.indexOf(t);
  n >= 0 && e.splice(n, 1);
}
function md(e, t, n) {
  const o = e.indexOf(t);
  o < 0 || e.splice(o + 1, 0, n);
}
function bd(e, t) {
  const n = [
    "edges",
    "edge-labels",
    "focusring",
    "nodes",
    "node-labels",
    "paths"
  ];
  return O(() => {
    const o = Nu(e.view.builtInLayerOrder).filter((r) => {
      const s = n.includes(r);
      return s || console.warn(`Layer ${r} is not a built-in layer.`), s;
    }).reverse(), i = [...n];
    return gd(o, (r, s) => {
      ut(i, s), md(i, r, s);
    }), "edge-label" in t || "edges-label" in t || ut(i, "edge-labels"), e.node.focusring.visible || ut(i, "focusring"), e.node.label.visible === !1 && ut(i, "node-labels"), e.path.visible || ut(i, "paths"), i;
  });
}
const yd = ["x", "y", "width", "height", "fill", "stroke", "stroke-width", "stroke-dasharray"], wd = /* @__PURE__ */ W({
  __name: "VSelectionBox",
  props: {
    box: null,
    config: null
  },
  setup(e) {
    return (t, n) => (M(), I("rect", {
      class: "v-ng-selection-box",
      x: Math.round(e.box.pos.x),
      y: Math.round(e.box.pos.y),
      width: Math.ceil(e.box.size.width),
      height: Math.ceil(e.box.size.height),
      fill: e.config.color,
      stroke: e.config.strokeColor,
      "stroke-width": e.config.strokeWidth,
      "stroke-dasharray": e.config.strokeDasharray
    }, null, 8, yd));
  }
});
const xd = ["points", "fill"], Ed = /* @__PURE__ */ W({
  __name: "VMarkerHeadArrow",
  props: {
    width: null,
    height: null,
    refX: null,
    color: null,
    isSource: { type: Boolean },
    units: null
  },
  setup(e) {
    const t = e, n = O(() => {
      const o = t.width, i = t.height;
      return t.isSource ? `${o} ${i}, 0 ${i / 2}, ${o} 0` : `0 0, ${o} ${i / 2}, 0 ${i}`;
    });
    return (o, i) => (M(), I("polygon", {
      points: y(n),
      fill: e.color
    }, null, 8, xd));
  }
}), Pd = ["points", "stroke-width", "stroke"], Sd = /* @__PURE__ */ W({
  __name: "VMarkerHeadAngle",
  props: {
    width: null,
    height: null,
    refX: null,
    color: null,
    isSource: { type: Boolean },
    units: null
  },
  setup(e) {
    const t = e, n = O(() => t.units === "strokeWidth" ? 1 : Math.min(t.width, t.height) / 5), o = O(() => {
      const i = n.value / 2, r = t.width, s = t.height;
      return t.isSource ? `${r - i} ${s - i}, ${i} ${s / 2}, ${r - i} ${i}` : `${i} ${i}, ${r - i} ${s / 2}, ${i} ${s - i}`;
    });
    return (i, r) => (M(), I("polyline", {
      points: y(o),
      fill: "none",
      "stroke-width": y(n),
      stroke: e.color,
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }, null, 8, Pd));
  }
}), kd = ["fill", "cx", "cy", "rx", "ry"], Md = /* @__PURE__ */ W({
  __name: "VMarkerHeadCircle",
  props: {
    width: null,
    height: null,
    refX: null,
    color: null,
    isSource: { type: Boolean },
    units: null
  },
  setup(e) {
    return (t, n) => (M(), I("ellipse", {
      fill: e.color,
      cx: e.width / 2,
      cy: e.height / 2,
      rx: e.width / 2,
      ry: e.height / 2
    }, null, 8, kd));
  }
}), Td = ["id", "markerWidth", "markerHeight", "refX", "refY", "markerUnits"], Od = /* @__PURE__ */ W({
  __name: "VMarkerHead",
  props: {
    id: null,
    marker: null,
    scale: null
  },
  setup(e) {
    const t = e, n = {
      arrow: Ed,
      angle: Sd,
      circle: Md
    }, o = O(
      () => t.marker.width * (t.marker.units === "strokeWidth" ? 1 : t.scale)
    ), i = O(
      () => t.marker.height * (t.marker.units === "strokeWidth" ? 1 : t.scale)
    ), r = O(() => {
      const s = t.marker.margin * (t.marker.units === "strokeWidth" ? 1 : t.scale);
      return t.marker.isSource ? o.value + s : -s;
    });
    return (s, a) => e.marker.type !== "none" && e.marker.type !== "custom" ? (M(), I("marker", {
      key: 0,
      id: e.id,
      markerWidth: y(o),
      markerHeight: y(i),
      refX: y(r),
      refY: y(i) / 2,
      orient: "auto",
      markerUnits: e.marker.units,
      class: "v-ng-marker"
    }, [
      (M(), H(mr(n[e.marker.type]), {
        width: y(o),
        height: y(i),
        refX: y(r),
        color: e.marker.color,
        "is-source": e.marker.isSource,
        units: e.marker.units
      }, null, 8, ["width", "height", "refX", "color", "is-source", "units"]))
    ], 8, Td)) : ue("", !0);
  }
}), Cd = {
  class: "v-ng-background-grid",
  "shape-rendering": "crispEdges"
}, $d = ["d"], _d = ["d"], zd = ["d"], Id = ["d"], Ad = /* @__PURE__ */ W({
  __name: "VBackgroundGrid",
  setup(e) {
    const { container: t, svgPanZoom: n } = En(), { zoomLevel: o } = be(), i = Xu(), r = zl(), s = Z({ x: 0, y: 0 }), a = Z({ width: 500, height: 500 });
    rt(() => {
      var x;
      const d = (x = n.value) == null ? void 0 : x.getPan();
      d && (s.value = {
        x: -d.x,
        y: -d.y
      });
      const v = t.value.getBoundingClientRect();
      a.value = {
        width: v.width,
        height: v.height
      };
    }), i.on("view:resize", (d) => {
      a.value = { width: d.width, height: d.height };
    }), i.on("view:pan", (d) => {
      s.value = { x: -d.x, y: -d.y };
    }), i.on("view:zoom", () => {
      var v;
      const d = (v = n.value) == null ? void 0 : v.getPan();
      d && (s.value = { x: -d.x, y: -d.y });
    });
    const l = Z([]), u = Z([]), c = Z([]), f = Z([]);
    return me(() => {
      const d = [], v = [], x = [], P = [], E = 1 / o.value, p = r.grid.interval, m = s.value.x * E, w = s.value.y * E, b = Math.floor(a.value.width / p + 1) * p, h = Math.floor(a.value.height / p + 1) * p, g = (s.value.x + b) * E, k = (s.value.y + h) * E, T = r.grid.thickIncrements, _ = r.grid.line.dasharray, C = r.grid.thick.dasharray;
      let $ = {
        stroke: r.grid.thick.color,
        "stroke-width": r.grid.thick.width,
        "stroke-dasharray": C,
        "stroke-dashoffset": C ? m / E : void 0
      }, A = {
        stroke: r.grid.line.color,
        "stroke-width": r.grid.line.width,
        "stroke-dasharray": _,
        "stroke-dashoffset": _ ? m / E : void 0
      };
      const B = (s.value.x + b) * E;
      for (let j = w; j <= k; j += p) {
        const F = Math.floor(j / p);
        T && F % T === 0 ? d.push([F, F * p, m, B, $]) : x.push([F, F * p, m, B, A]);
      }
      $ = se({}, $), $["stroke-dashoffset"] = C ? w / E : void 0, A = se({}, A), A["stroke-dashoffset"] = _ ? w / E : void 0;
      const Y = (s.value.y + h) * E;
      for (let j = m; j <= g; j += p) {
        const F = Math.floor(j / p);
        T && F % T === 0 ? v.push([F, F * p, w, Y, $]) : P.push([F, F * p, w, Y, A]);
      }
      u.value = d, l.value = v, f.value = x, c.value = P;
    }), (d, v) => (M(), I("g", Cd, [
      (M(!0), I(X, null, ee(f.value, ([x, P, E, p, m]) => (M(), I("path", Se({
        key: `nv${x}`,
        d: `M ${E} ${P} L ${p} ${P}`
      }, m, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, $d))), 128)),
      (M(!0), I(X, null, ee(c.value, ([x, P, E, p, m]) => (M(), I("path", Se({
        key: `nh${x}`,
        d: `M ${P} ${E} L ${P} ${p}`
      }, m, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, _d))), 128)),
      (M(!0), I(X, null, ee(u.value, ([x, P, E, p, m]) => (M(), I("path", Se({
        key: `tv${x}`,
        d: `M ${E} ${P} L ${p} ${P}`
      }, m, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, zd))), 128)),
      (M(!0), I(X, null, ee(l.value, ([x, P, E, p, m]) => (M(), I("path", Se({
        key: `th${x}`,
        d: `M ${P} ${E} L ${P} ${p}`
      }, m, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, Id))), 128))
    ]));
  }
});
const Ld = /* @__PURE__ */ W({
  __name: "VBackgroundViewport",
  setup(e) {
    const { viewport: t } = En(), n = Z(), o = (r, s, a) => {
      r.forEach((l) => {
        var u;
        return s.setAttribute(l, (u = a.getAttribute(l)) != null ? u : "");
      });
    }, i = new MutationObserver((r) => {
      if (!n.value)
        return;
      const s = r.map((a) => {
        var l;
        return (l = a.attributeName) != null ? l : "";
      }).filter(Boolean);
      o(s, n.value, t.value);
    });
    return rt(() => {
      const r = ["transform", "style"];
      i.observe(t.value, {
        attributes: !0,
        attributeFilter: r
      }), n.value && o(r, n.value, t.value);
    }), bt(() => {
      i.disconnect();
    }), (r, s) => (M(), I("g", {
      ref_key: "background",
      ref: n,
      class: "v-ng-background-viewport"
    }, [
      K(r.$slots, "default")
    ], 512));
  }
}), Nd = ["d", "stroke-width"], Dd = /* @__PURE__ */ W({
  __name: "VEdgeBackground",
  props: {
    id: null,
    state: null,
    sourcePos: { default: void 0 },
    targetPos: { default: void 0 }
  },
  setup(e) {
    const t = e, { scale: n } = be(), o = Et(), {
      handleEdgePointerDownEvent: i,
      handleEdgePointerOverEvent: r,
      handleEdgePointerOutEvent: s,
      handleEdgeClickEvent: a,
      handleEdgeDoubleClickEvent: l,
      handleEdgeContextMenu: u
    } = Pt(), c = O(() => {
      const d = t.state.position;
      if (t.state.loop) {
        const { radius: v, isLargeArc: x, isClockwise: P } = t.state.loop, [E, p] = v, m = x ? 1 : 0, w = P ? 1 : 0;
        return `M ${d.p1.x} ${d.p1.y} A ${E} ${p} 0 ${m} ${w} ${d.p2.x} ${d.p2.y}`;
      } else {
        if (o.type === "straight" || !t.state.curve)
          return `M ${d.p1.x} ${d.p1.y} L ${d.p2.x} ${d.p2.y}`;
        {
          const v = [...t.state.curve.control, { x: d.p2.x, y: d.p2.y }], x = [];
          return x.push(`M ${d.p1.x} ${d.p1.y}`), jn(v, 2).forEach(([P, E]) => x.push(`Q ${P.x} ${P.y} ${E.x} ${E.y}`)), x.join(" ");
        }
      }
    }), f = O(() => (t.state.line.stroke.width + 10) * n.value);
    return (d, v) => (M(), I("path", {
      class: pe({ "v-ng-line-background": !0, selectable: e.state.selectable }),
      d: y(c),
      stroke: "transparent",
      "stroke-width": y(f),
      fill: "none",
      onPointerdown: v[0] || (v[0] = Ee((x) => y(i)(e.id, x), ["stop"])),
      onPointerenterPassive: v[1] || (v[1] = (x) => y(r)(e.id, x)),
      onPointerleavePassive: v[2] || (v[2] = (x) => y(s)(e.id, x)),
      onClick: v[3] || (v[3] = Ee((x) => y(a)(e.id, x), ["stop"])),
      onDblclick: v[4] || (v[4] = Ee((x) => y(l)(e.id, x), ["stop"])),
      onContextmenu: v[5] || (v[5] = (x) => y(u)(e.id, x))
    }, null, 42, Nd));
  }
});
const Zd = /* @__PURE__ */ W({
  __name: "VEdgeBackgrounds",
  setup(e) {
    const { edgeStates: t, edgeGroupStates: n, layouts: o } = Me();
    return (i, r) => (M(!0), I(X, null, ee(y(n).edgeGroups, ({ summarize: s, edges: a }) => (M(), I(X, null, [
      s ? ue("", !0) : (M(!0), I(X, { key: 0 }, ee(a, (l, u) => (M(), H(Dd, {
        key: u,
        id: u,
        state: y(t)[u],
        "source-pos": y(o).nodes[l.source],
        "target-pos": y(o).nodes[l.target]
      }, null, 8, ["id", "state", "source-pos", "target-pos"]))), 128))
    ], 64))), 256));
  }
}), jd = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap"], Hi = /* @__PURE__ */ W({
  __name: "VLine",
  props: {
    p1: null,
    p2: null,
    config: null
  },
  setup(e) {
    const t = e, { scale: n } = be(), o = O(() => t.config.width * n.value), i = O(() => xt(t.config.dasharray, n.value)), r = O(() => {
      const s = t.config.animate ? Vt(t.config.dasharray) * t.config.animationSpeed * n.value : !1;
      return s ? `--animation-speed:${s}` : void 0;
    });
    return (s, a) => (M(), I("path", {
      class: pe({ "v-ng-line": !0, animate: e.config.animate }),
      d: `M ${e.p1.x} ${e.p1.y} L ${e.p2.x} ${e.p2.y}`,
      stroke: e.config.color,
      "stroke-width": y(o),
      "stroke-dasharray": y(i),
      "stroke-linecap": e.config.linecap,
      style: yt(y(r))
    }, null, 14, jd));
  }
}), Bd = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap"], Rd = /* @__PURE__ */ W({
  __name: "VArc",
  props: {
    p1: null,
    p2: null,
    radius: null,
    isLargeArc: { type: Boolean },
    isClockwise: { type: Boolean },
    config: null
  },
  setup(e) {
    const t = e, { scale: n } = be(), o = O(() => t.config.width * n.value), i = O(() => xt(t.config.dasharray, n.value)), r = O(() => {
      const a = t.config.animate ? Vt(t.config.dasharray) * t.config.animationSpeed * n.value : !1;
      return a ? `--animation-speed:${a}` : void 0;
    }), s = O(() => {
      const { p1: a, p2: l, radius: u, isLargeArc: c, isClockwise: f } = t, [d, v] = u, x = c ? 1 : 0, P = f ? 1 : 0;
      return `M ${a.x} ${a.y} A ${d} ${v} 0 ${x} ${P} ${l.x} ${l.y}`;
    });
    return (a, l) => (M(), I("path", {
      class: pe({ "v-ng-line": !0, animate: e.config.animate }),
      d: y(s),
      stroke: e.config.color,
      "stroke-width": y(o),
      "stroke-dasharray": y(i),
      "stroke-linecap": e.config.linecap,
      style: yt(y(r)),
      fill: "none"
    }, null, 14, Bd));
  }
}), Hd = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "marker-start", "marker-end"], Vd = /* @__PURE__ */ W({
  __name: "VEdgeCurved",
  props: {
    state: null,
    config: null,
    markerStart: { default: void 0 },
    markerEnd: { default: void 0 }
  },
  setup(e) {
    const t = e, { scale: n } = be(), o = O(() => {
      var c, f;
      const a = t.state.position, l = [...(f = (c = t.state.curve) == null ? void 0 : c.control) != null ? f : [], { x: a.p2.x, y: a.p2.y }], u = [];
      return u.push(`M ${a.p1.x} ${a.p1.y}`), jn(l, 2).forEach(([d, v]) => u.push(`Q ${d.x} ${d.y} ${v.x} ${v.y}`)), u.join(" ");
    }), i = O(() => t.config.width * n.value), r = O(() => xt(t.config.dasharray, n.value)), s = O(() => {
      const a = t.config.animate ? Vt(t.config.dasharray) * t.config.animationSpeed * n.value : !1;
      return a ? `--animation-speed:${a}` : void 0;
    });
    return (a, l) => (M(), I("path", {
      class: pe({ "v-ng-line": !0, animate: e.config.animate }),
      d: y(o),
      fill: "none",
      stroke: e.config.color,
      "stroke-width": y(i),
      "stroke-dasharray": y(r),
      "stroke-linecap": e.config.linecap,
      style: yt(y(s)),
      "marker-start": e.markerStart,
      "marker-end": e.markerEnd
    }, null, 14, Hd));
  }
}), Wd = /* @__PURE__ */ W({
  __name: "VEdge",
  props: {
    id: null,
    state: null,
    sourcePos: { default: void 0 },
    targetPos: { default: void 0 }
  },
  setup(e) {
    const t = Et();
    return (n, o) => e.state.loop ? (M(), H(Rd, Se({ key: 0 }, e.state.position, {
      radius: e.state.loop.radius,
      "is-large-arc": e.state.loop.isLargeArc,
      "is-clockwise": e.state.loop.isClockwise,
      class: [{ selectable: e.state.selectable, hover: e.state.hovered, selected: e.state.selected }, "v-ng-edge"],
      config: e.state.line.stroke,
      "marker-start": e.state.sourceMarkerId ? `url('#${e.state.sourceMarkerId}')` : void 0,
      "marker-end": e.state.targetMarkerId ? `url('#${e.state.targetMarkerId}')` : void 0
    }), null, 16, ["radius", "is-large-arc", "is-clockwise", "class", "config", "marker-start", "marker-end"])) : y(t).type == "straight" || !e.state.curve ? (M(), H(Hi, Se({
      key: 1,
      "data-edge-id": e.id
    }, e.state.position, {
      class: [{ selectable: e.state.selectable, hover: e.state.hovered, selected: e.state.selected }, "v-ng-edge"],
      config: e.state.line.stroke,
      "marker-start": e.state.sourceMarkerId ? `url('#${e.state.sourceMarkerId}')` : void 0,
      "marker-end": e.state.targetMarkerId ? `url('#${e.state.targetMarkerId}')` : void 0
    }), null, 16, ["data-edge-id", "class", "config", "marker-start", "marker-end"])) : (M(), H(Vd, {
      key: 2,
      "data-edge-id": e.id,
      class: pe([{ selectable: e.state.selectable, hover: e.state.hovered, selected: e.state.selected }, "v-ng-edge"]),
      state: e.state,
      config: e.state.line.stroke,
      "marker-start": e.state.sourceMarkerId ? `url('#${e.state.sourceMarkerId}')` : void 0,
      "marker-end": e.state.targetMarkerId ? `url('#${e.state.targetMarkerId}')` : void 0
    }, null, 8, ["data-edge-id", "class", "state", "config", "marker-start", "marker-end"]));
  }
});
const Fd = ["cx", "cy", "r", "fill", "stroke", "stroke-width", "stroke-dasharray"], Ud = ["x", "y", "width", "height", "rx", "ry", "fill", "stroke", "stroke-width", "stroke-dasharray"], Xt = /* @__PURE__ */ W({
  __name: "VShape",
  props: {
    baseX: { default: 0 },
    baseY: { default: 0 },
    config: null
  },
  setup(e) {
    const t = e, { scale: n } = be(), o = Z(t.baseX), i = Z(t.baseY), r = Z(0), s = Z("#000000"), a = Z(void 0), l = Z(0), u = Z(0), c = Z(0), f = Z(0);
    return me(() => {
      var v;
      const d = n.value;
      r.value = t.config.strokeWidth * d, s.value = (v = t.config.strokeColor) != null ? v : "none", a.value = xt(t.config.strokeDasharray, d), t.config.type === "circle" ? (o.value = t.baseX, i.value = t.baseY, l.value = t.config.radius * d) : (u.value = t.config.width * d, c.value = t.config.height * d, f.value = t.config.borderRadius * d, o.value = t.baseX - u.value / 2, i.value = t.baseY - c.value / 2);
    }), (d, v) => e.config.type === "circle" ? (M(), I("circle", {
      key: 0,
      class: "v-ng-shape-circle",
      cx: o.value,
      cy: i.value,
      r: l.value,
      fill: e.config.color,
      stroke: s.value,
      "stroke-width": r.value,
      "stroke-dasharray": a.value
    }, null, 8, Fd)) : (M(), I("rect", {
      key: 1,
      class: "v-ng-shape-rect",
      x: o.value,
      y: i.value,
      width: u.value,
      height: c.value,
      rx: f.value,
      ry: f.value,
      fill: e.config.color,
      stroke: s.value,
      "stroke-width": r.value,
      "stroke-dasharray": a.value
    }, null, 8, Ud));
  }
}), Gd = ["rx", "ry", "fill", "transform"], Xd = ["x", "y", "dominant-baseline", "font-family", "font-size", "fill"], qd = ["x", "dy", "dominant-baseline"], qt = /* @__PURE__ */ W({
  __name: "VLabelText",
  props: {
    text: null,
    x: { default: 0 },
    y: { default: 0 },
    dominantBaseline: { default: "central" },
    config: null
  },
  setup(e) {
    const t = e, n = br(), { scale: o } = be(), i = O(() => {
      var E, p;
      return (p = (E = t.text) == null ? void 0 : E.toString().split(/\r?\n/)) != null ? p : "";
    }), r = O(() => {
      var E;
      return (E = n["font-size"]) != null ? E : t.config.fontSize * o.value;
    }), s = O(() => r.value * t.config.lineHeight), a = O(() => {
      const E = t.dominantBaseline;
      return E === "hanging" ? 0 : E === "central" ? -(s.value * (i.value.length - 1)) / 2 : -s.value * (i.value.length - 1);
    }), l = Z(), u = Z(""), c = Ce({ x: 0, y: 0, width: 0, height: 0 }), f = O(() => {
      var b, h;
      const E = t.config.background;
      if (!E)
        return c;
      let p, m;
      E.padding instanceof Object ? (p = E.padding.vertical, m = E.padding.horizontal) : (p = (b = E.padding) != null ? b : 0, m = (h = E.padding) != null ? h : 0);
      const w = s.value - r.value;
      return {
        x: c.x - m * o.value,
        y: c.y - p * o.value - w / 2,
        width: c.width + m * 2 * o.value,
        height: c.height + p * 2 * o.value + w
      };
    });
    let d;
    const v = () => {
      t.config.background && t.config.background.visible ? !d && l.value && (d = P(l.value, c, u)) : (d == null || d.disconnect(), d = void 0);
    };
    rt(() => v()), G(
      () => t.config.background && t.config.background.visible,
      (E, p) => {
        E != p && v();
      }
    ), bt(() => {
      d == null || d.disconnect(), d = void 0;
    });
    function x(E, p, m) {
      var b;
      const w = E.getBBox();
      p.x = w.x, p.y = w.y, p.width = w.width, p.height = w.height, m.value = (b = E.getAttribute("transform")) != null ? b : void 0;
    }
    function P(E, p, m) {
      const w = new MutationObserver(() => {
        x(E, p, m);
      });
      return w.observe(E, {
        attributes: !0,
        attributeFilter: ["x", "y", "transform", "font-size"]
      }), x(E, p, m), w;
    }
    return (E, p) => {
      var m, w, b, h, g, k;
      return M(), I(X, null, [
        e.config.background && e.config.background.visible ? (M(), I("rect", Se({
          key: 0,
          class: "v-ng-text-background"
        }, y(f), {
          rx: ((w = (m = e.config.background) == null ? void 0 : m.borderRadius) != null ? w : 0) * y(o),
          ry: ((h = (b = e.config.background) == null ? void 0 : b.borderRadius) != null ? h : 0) * y(o),
          fill: (k = (g = e.config.background) == null ? void 0 : g.color) != null ? k : "#ffffff",
          transform: u.value
        }), null, 16, Gd)) : ue("", !0),
        Vo("text", Se({
          ref_key: "element",
          ref: l,
          class: "v-ng-text"
        }, E.$attrs, {
          x: e.x,
          y: e.y,
          "dominant-baseline": e.dominantBaseline,
          "font-family": E.$attrs["font-family"] ? `${E.$attrs["font-family"]}` : e.config.fontFamily,
          "font-size": y(r),
          fill: E.$attrs.fill ? `${E.$attrs.fill}` : e.config.color
        }), [
          y(i).length <= 1 ? (M(), I(X, { key: 0 }, [
            yr(Yn(e.text), 1)
          ], 64)) : (M(!0), I(X, { key: 1 }, ee(y(i), (T, _) => (M(), I("tspan", {
            key: _,
            x: e.x,
            dy: _ == 0 ? y(a) : y(s),
            "dominant-baseline": e.dominantBaseline
          }, Yn(T), 9, qd))), 128))
        ], 16, Xd)
      ], 64);
    };
  }
}), Kd = /* @__PURE__ */ W({
  __name: "VEdgeSummarized",
  props: {
    edges: null,
    layouts: null
  },
  setup(e) {
    const t = e, n = Et(), {
      handleEdgesPointerDownEvent: o,
      handleEdgesPointerOverEvent: i,
      handleEdgesPointerOutEvent: r,
      handleEdgesClickEvent: s,
      handleEdgesDoubleClickEvent: a,
      handleEdgesContextMenu: l
    } = Pt(), { edgeStates: u } = Me(), c = Z({ p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } }), f = Z({ x: 0, y: 0 });
    me(() => {
      const w = Object.keys(t.edges).find((b) => b in u);
      w && (c.value = u[w].position, f.value = {
        x: (c.value.p1.x + c.value.p2.x) / 2,
        y: (c.value.p1.y + c.value.p2.y) / 2
      });
    });
    const d = O(() => Object.keys(t.edges)), v = O(() => z.values(n.summarized.label, t.edges)), x = O(() => z.values(n.summarized.shape, t.edges)), P = O(() => z.values(n.summarized.stroke, t.edges)), E = O(() => d.value.some((w) => u[w].hovered)), p = O(() => d.value.some((w) => u[w].selectable)), m = O(() => d.value.some((w) => u[w].selected));
    return (w, b) => (M(), I("g", {
      class: pe({ "v-ng-line-summarized": !0, hovered: y(E), selectable: y(p), selected: y(m) }),
      onPointerdown: b[0] || (b[0] = Ee((h) => y(o)(y(d), h), ["stop"])),
      onPointerenterPassive: b[1] || (b[1] = (h) => y(i)(y(d), h)),
      onPointerleavePassive: b[2] || (b[2] = (h) => y(r)(y(d), h)),
      onClick: b[3] || (b[3] = Ee((h) => y(s)(y(d), h), ["stop"])),
      onDblclick: b[4] || (b[4] = Ee((h) => y(a)(y(d), h), ["stop"])),
      onContextmenu: b[5] || (b[5] = (h) => y(l)(y(d), h))
    }, [
      Fe(Hi, Se(c.value, {
        config: y(P),
        "data-edge-id": y(d)[0]
      }), null, 16, ["config", "data-edge-id"]),
      Fe(Xt, {
        "base-x": f.value.x,
        "base-y": f.value.y,
        config: y(x)
      }, null, 8, ["base-x", "base-y", "config"]),
      Fe(qt, {
        text: Object.keys(e.edges).length.toString(),
        x: f.value.x,
        y: f.value.y,
        config: y(v),
        "text-anchor": "middle",
        "dominant-baseline": "central"
      }, null, 8, ["text", "x", "y", "config"])
    ], 34));
  }
});
const Yd = { class: "v-ng-edge-overlay" }, Do = /* @__PURE__ */ W({
  __name: "VEdgeOverlay",
  props: {
    edgeId: { default: void 0 },
    edge: { default: void 0 },
    edges: { default: () => ({}) },
    state: null,
    isSummarized: { type: Boolean }
  },
  setup(e) {
    const t = e, { svg: n } = En(), { scale: o } = be(), i = Et();
    function r() {
      return t.isSummarized ? z.values(i.summarized.stroke, t.edges) : t.state.line.stroke;
    }
    function s(c) {
      return { source: c.p1, target: c.p2 };
    }
    function a(c) {
      if (c.curve)
        return c.curve.center;
      {
        const f = c.origin.p1, d = c.origin.p2;
        return {
          x: (f.x + d.x) / 2,
          y: (f.y + d.y) / 2
        };
      }
    }
    function l() {
      var d;
      if (!n.value)
        return 0;
      const c = (d = t.edgeId) != null ? d : Object.keys(t.edges)[0], f = n.value.querySelector(`path[data-edge-id="${c}"]`);
      return f ? f.getTotalLength() : 0;
    }
    function u(c) {
      var x;
      if (!n.value || !isFinite(c))
        return t.state.position.p1;
      t.state;
      const f = (x = t.edgeId) != null ? x : Object.keys(t.edges)[0], d = n.value.querySelector(`path[data-edge-id="${f}"]`);
      if (!d)
        return t.state.position.p1;
      const v = d.getPointAtLength(c);
      return { x: v.x, y: v.y };
    }
    return (c, f) => (M(), I("g", Yd, [
      e.isSummarized ? K(c.$slots, "default", {
        key: 0,
        edges: e.edges,
        isSummarized: e.isSummarized,
        stroke: r(),
        position: s(e.state.origin),
        center: a(e.state),
        hovered: e.state.hovered,
        selected: e.state.selected,
        scale: y(o),
        length: l(),
        pointAtLength: u
      }) : K(c.$slots, "default", {
        key: 1,
        edgeId: e.edgeId,
        edge: e.edge,
        edges: { [e.edgeId]: e.edge },
        isSummarized: e.isSummarized,
        stroke: r(),
        position: s(e.state.origin),
        center: a(e.state),
        hovered: e.state.hovered,
        selected: e.state.selected,
        scale: y(o),
        length: l(),
        pointAtLength: u
      })
    ]));
  }
}), Qd = /* @__PURE__ */ W({
  __name: "VEdgeGroups",
  props: {
    hasEdgeOverlaySlot: { type: Boolean }
  },
  setup(e) {
    const { edgeStates: t, edgeZOrderedList: n, layouts: o } = Me();
    return (i, r) => (M(!0), I(X, null, ee(y(n), (s) => (M(), I(X, null, [
      y(tu)(s) ? (M(), I(X, { key: 0 }, [
        (M(), H(Kd, {
          key: s.key,
          edges: s.group.edges,
          layouts: y(o).nodes
        }, null, 8, ["edges", "layouts"])),
        e.hasEdgeOverlaySlot ? (M(), H(Do, {
          key: s.key,
          edges: s.group.edges,
          state: y(t)[Object.keys(s.group.edges)[0]],
          "is-summarized": !0
        }, {
          default: ne((a) => [
            K(i.$slots, "default", de(fe(a)))
          ]),
          _: 2
        }, 1032, ["edges", "state"])) : ue("", !0)
      ], 64)) : (M(), I(X, { key: 1 }, [
        (M(), H(Wd, {
          id: s.key,
          key: s.key,
          state: y(t)[s.key],
          "source-pos": y(o).nodes[s.edge.source],
          "target-pos": y(o).nodes[s.edge.target]
        }, null, 8, ["id", "state", "source-pos", "target-pos"])),
        e.hasEdgeOverlaySlot ? (M(), H(Do, {
          key: s.key,
          "edge-id": s.key,
          edge: s.edge,
          state: y(t)[s.key],
          "is-summarized": !1
        }, {
          default: ne((a) => [
            K(i.$slots, "default", de(fe(a)))
          ]),
          _: 2
        }, 1032, ["edge-id", "edge", "state"])) : ue("", !0)
      ], 64))
    ], 64))), 256));
  }
}), Jd = { class: "v-ng-layer-edges" }, ef = /* @__PURE__ */ W({
  __name: "VEdgesLayer",
  setup(e) {
    const t = jt(), n = O(() => "edge-overlay" in t);
    return (o, i) => (M(), I("g", Jd, [
      Fe(Zd),
      Fe(Qd, { "has-edge-overlay-slot": y(n) }, Wo({ _: 2 }, [
        y(n) ? {
          name: "default",
          fn: ne((r) => [
            K(o.$slots, "edge-overlay", de(fe(r)))
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["has-edge-overlay-slot"])
    ]));
  }
}), tf = /* @__PURE__ */ W({
  __name: "VEdgeLabelPlace",
  props: {
    edgeId: null,
    edge: null,
    config: null,
    state: null
  },
  setup(e) {
    const t = e, { scale: n } = be(), o = O(() => Ti(
      t.state.labelPosition,
      t.state.line.stroke,
      t.config.margin,
      t.config.padding,
      n.value
    ));
    return (i, r) => e.state.loop ? ue("", !0) : K(i.$slots, "default", {
      key: 0,
      edgeId: e.edgeId,
      edge: e.edge,
      config: e.config,
      area: y(o),
      hovered: e.state.hovered,
      selected: e.state.selected,
      scale: y(n)
    });
  }
}), nf = /* @__PURE__ */ W({
  __name: "VEdgeLabelsPlace",
  props: {
    edges: null,
    config: null,
    state: null,
    summarizeState: null
  },
  setup(e) {
    const t = e, { scale: n } = be(), o = O(() => {
      var i, r;
      return Ti(
        t.state.labelPosition,
        (r = (i = t.summarizeState) == null ? void 0 : i.stroke) != null ? r : t.state.line.stroke,
        t.config.margin,
        t.config.padding,
        n.value
      );
    });
    return (i, r) => e.state.loop ? ue("", !0) : K(i.$slots, "default", {
      key: 0,
      edges: e.edges,
      config: e.config,
      area: y(o),
      hovered: e.state.hovered,
      selected: e.state.selected,
      scale: y(n)
    });
  }
}), of = { class: "v-ng-edge-labels" }, rf = /* @__PURE__ */ W({
  __name: "VEdgeLabels",
  props: {
    enableEdgeLabel: { type: Boolean, default: !1 },
    enableEdgesLabel: { type: Boolean, default: !1 }
  },
  setup(e) {
    const t = Et(), { edgeStates: n, edgeGroupStates: o, summarizedEdgeStates: i } = Me(), r = O(() => {
      const a = {}, l = {};
      return Object.entries(o.edgeGroups).forEach(([u, c]) => {
        Object.keys(c.edges).length > 0 && (c.summarize ? l[u] = c : a[u] = c);
      }), { individual: a, summarized: l };
    });
    function s(a) {
      return Object.keys(a.edges)[0];
    }
    return (a, l) => (M(), I("g", of, [
      e.enableEdgeLabel ? (M(!0), I(X, { key: 0 }, ee(y(r).individual, (u, c) => (M(), I(X, { key: c }, [
        (M(!0), I(X, null, ee(u.edges, (f, d) => (M(), H(tf, {
          key: d,
          "edge-id": d,
          edge: f,
          config: y(t).label,
          state: y(n)[d]
        }, {
          default: ne((v) => [
            K(a.$slots, "edge-label", de(fe(v)))
          ]),
          _: 2
        }, 1032, ["edge-id", "edge", "config", "state"]))), 128))
      ], 64))), 128)) : ue("", !0),
      e.enableEdgesLabel ? (M(!0), I(X, { key: 1 }, ee(y(r).summarized, (u, c) => (M(), H(nf, {
        key: c,
        edges: u.edges,
        config: y(t).label,
        state: y(n)[s(u)],
        "summarize-state": y(i)[s(u)]
      }, {
        default: ne((f) => [
          K(a.$slots, "edges-label", de(fe(f)))
        ]),
        _: 2
      }, 1032, ["edges", "config", "state", "summarize-state"]))), 128)) : ue("", !0)
    ]));
  }
});
const sf = /* @__PURE__ */ W({
  __name: "VEdgeLabelsLayer",
  props: {
    enableEdgeLabel: { type: Boolean, default: !1 },
    enableEdgesLabel: { type: Boolean, default: !1 }
  },
  setup(e) {
    return (t, n) => (M(), H(rf, {
      "enable-edge-label": e.enableEdgeLabel,
      "enable-edges-label": e.enableEdgesLabel,
      class: "v-ng-layer-edge-labels"
    }, Wo({ _: 2 }, [
      e.enableEdgeLabel ? {
        name: "edge-label",
        fn: ne((o) => [
          K(t.$slots, "edge-label", de(fe(o)))
        ]),
        key: "0"
      } : void 0,
      e.enableEdgesLabel ? {
        name: "edges-label",
        fn: ne((o) => [
          K(t.$slots, "edges-label", de(fe(o)))
        ]),
        key: "1"
      } : void 0
    ]), 1032, ["enable-edge-label", "enable-edges-label"]));
  }
}), af = /* @__PURE__ */ W({
  __name: "VNodeFocusRing",
  props: {
    id: null,
    state: null,
    pos: { default: void 0 }
  },
  setup(e) {
    const t = e, n = O(() => {
      var s;
      return ((s = t.pos) == null ? void 0 : s.x) || 0;
    }), o = O(() => {
      var s;
      return ((s = t.pos) == null ? void 0 : s.y) || 0;
    }), i = Ft(), r = Ce({});
    return me(() => {
      var a, l, u;
      const s = t.state.shape;
      if (s.type === "circle") {
        const c = {
          type: "circle",
          radius: s.radius + ((a = s.strokeWidth) != null ? a : 0) / 2 + i.focusring.padding + i.focusring.width / 2,
          color: "none",
          strokeWidth: i.focusring.width,
          strokeColor: i.focusring.color,
          strokeDasharray: i.focusring.dasharray
        };
        Object.assign(r, c);
      } else {
        const c = {
          type: "rect",
          width: s.width + ((l = s.strokeWidth) != null ? l : 0) + i.focusring.padding * 2 + i.focusring.width,
          height: s.height + ((u = s.strokeWidth) != null ? u : 0) + i.focusring.padding * 2 + i.focusring.width,
          borderRadius: s.borderRadius > 0 ? s.borderRadius + i.focusring.padding : 0,
          color: "none",
          strokeWidth: i.focusring.width,
          strokeColor: i.focusring.color,
          strokeDasharray: i.focusring.dasharray
        };
        Object.assign(r, c);
      }
    }), (s, a) => (M(), H(Xt, {
      class: "v-ng-node-focusring",
      "base-x": y(n),
      "base-y": y(o),
      config: r
    }, null, 8, ["base-x", "base-y", "config"]));
  }
});
const lf = { class: "v-ng-layer-nodes-selections" }, cf = /* @__PURE__ */ W({
  __name: "VFocusringLayer",
  setup(e) {
    const { nodeStates: t } = Me(), { selectedNodes: n } = vd(), o = Rn();
    return (i, r) => (M(), I("g", lf, [
      (M(!0), I(X, null, ee(y(n), (s) => (M(), H(af, {
        id: s,
        key: s,
        state: y(t)[s],
        pos: y(o).nodes[s]
      }, null, 8, ["id", "state", "pos"]))), 128))
    ]));
  }
}), uf = ["transform"], Zo = /* @__PURE__ */ W({
  __name: "VNode",
  props: {
    id: null,
    state: null,
    pos: { default: void 0 }
  },
  setup(e) {
    const t = e, n = O(() => {
      var f;
      return ((f = t.pos) == null ? void 0 : f.x) || 0;
    }), o = O(() => {
      var f;
      return ((f = t.pos) == null ? void 0 : f.y) || 0;
    }), { scale: i } = be(), {
      handleNodePointerDownEvent: r,
      handleNodePointerOverEvent: s,
      handleNodePointerOutEvent: a,
      handleNodeClickEvent: l,
      handleNodeDoubleClickEvent: u,
      handleNodeContextMenu: c
    } = Pt();
    return (f, d) => (M(), I("g", {
      class: pe({ "v-ng-node": !0, hover: e.state.hovered, selected: e.state.selected }),
      transform: `translate(${y(n)} ${y(o)})`,
      onPointerdown: d[0] || (d[0] = Ee((v) => y(r)(e.id, v), ["stop"])),
      onPointerenterPassive: d[1] || (d[1] = (v) => y(s)(e.id, v)),
      onPointerleavePassive: d[2] || (d[2] = (v) => y(a)(e.id, v)),
      onClick: d[3] || (d[3] = Ee((v) => y(l)(e.id, v), ["stop"])),
      onDblclick: d[4] || (d[4] = Ee((v) => y(u)(e.id, v), ["stop"])),
      onContextmenu: d[5] || (d[5] = (v) => y(c)(e.id, v))
    }, [
      K(f.$slots, "override-node", {
        nodeId: e.id,
        scale: y(i),
        config: e.state.shape,
        class: pe({ draggable: e.state.draggable, selectable: e.state.selectable })
      }, () => [
        Fe(Xt, {
          config: e.state.shape,
          class: pe({
            "v-ng-node-default": !0,
            draggable: e.state.draggable,
            selectable: e.state.selectable
          })
        }, null, 8, ["config", "class"])
      ])
    ], 42, uf));
  }
});
const df = /* @__PURE__ */ W({
  __name: "VNodesLayer",
  setup(e) {
    const t = jt(), n = O(() => "override-node" in t), { nodeZOrderedList: o } = Me(), i = Ft(), r = Rn();
    return (s, a) => y(n) ? (M(), H(ht, {
      key: 0,
      name: y(i).transition,
      css: !!y(i).transition,
      tag: "g",
      class: "v-ng-layer-nodes"
    }, {
      default: ne(() => [
        (M(!0), I(X, null, ee(y(o), (l) => (M(), H(Zo, {
          id: l.id,
          key: l.id,
          state: l,
          pos: y(r).nodes[l.id]
        }, {
          "override-node": ne((u) => [
            K(s.$slots, "override-node", de(fe(u)))
          ]),
          _: 2
        }, 1032, ["id", "state", "pos"]))), 128))
      ]),
      _: 3
    }, 8, ["name", "css"])) : (M(), H(ht, {
      key: 1,
      name: y(i).transition,
      css: !!y(i).transition,
      tag: "g",
      class: "v-ng-layer-nodes"
    }, {
      default: ne(() => [
        (M(!0), I(X, null, ee(y(o), (l) => (M(), H(Zo, {
          id: l.id,
          key: l.id,
          state: l,
          pos: y(r).nodes[l.id]
        }, null, 8, ["id", "state", "pos"]))), 128))
      ]),
      _: 1
    }, 8, ["name", "css"]));
  }
}), Vi = {
  [N.NORTH]: 0,
  [N.NORTH_EAST]: 1,
  [N.EAST]: 2,
  [N.SOUTH_EAST]: 3,
  [N.SOUTH]: 4,
  [N.SOUTH_WEST]: 5,
  [N.WEST]: 6,
  [N.NORTH_WEST]: 7,
  [N.CENTER]: -1
}, ff = [
  /* N */
  (e, t) => ze(e, 0, t ? 90 : 60),
  /* NE */
  (e, t) => ze(e, 45, t ? 90 : 45),
  /* E */
  (e, t) => ze(e, 90, t ? 60 : 30),
  /* SE */
  (e, t) => ze(e, 135, t ? 90 : 45),
  /* S */
  (e, t) => ze(e, 180, t ? 90 : 60),
  /* SW */
  (e, t) => ze(e, 225, t ? 90 : 45),
  /* W */
  (e, t) => ze(e, 270, t ? 60 : 30),
  /* NW */
  (e, t) => ze(e, 315, t ? 90 : 45)
];
function hf(e, t, n, o, i) {
  if (i === N.CENTER)
    return N.CENTER;
  const r = [];
  Object.entries(n).forEach(([u, c]) => {
    let f = !1;
    if (c.nodeId === e) {
      const v = o(u);
      v && (f = !0, c = st(se({}, c), {
        pos: { x: v.x, y: v.y }
      }));
    }
    const d = (Ln(Cn(c.pos, t)) + 360 + 90) % 360;
    r.push([d, f]);
  });
  const s = vf(i), l = [
    s,
    (s + 4) % 8,
    // priority is given to diagonals
    (s + 2) % 8,
    (s - 2 + 8) % 8,
    (s + 1) % 8,
    (s - 1 + 8) % 8,
    (s + 3) % 8,
    (s - 3 + 8) % 8
  ].find((u) => r.every((c) => !ff[u](...c)));
  return l === void 0 ? i : pf(l, i);
}
function ze(e, t, n) {
  e %= 360;
  const o = (t - n + 360) % 360, i = (t + n) % 360;
  return o <= i ? o < e && e < i : o < e || e < i;
}
function vf(e) {
  var t;
  return (t = Vi[e]) != null ? t : 0;
}
function pf(e, t) {
  var n, o;
  return (o = (n = Object.entries(Vi)[e]) == null ? void 0 : n[0]) != null ? o : t;
}
const gf = ["transform"], jo = /* @__PURE__ */ W({
  __name: "VNodeLabel",
  props: {
    id: null,
    state: null,
    pos: { default: void 0 }
  },
  setup(e) {
    const t = e, n = Ft(), { edgeStates: o } = Me(), { scale: i } = be(), {
      handleNodePointerDownEvent: r,
      handleNodePointerOverEvent: s,
      handleNodePointerOutEvent: a,
      handleNodeClickEvent: l,
      handleNodeDoubleClickEvent: u,
      handleNodeContextMenu: c
    } = Pt(), f = O(() => {
      var C;
      return ((C = t.pos) == null ? void 0 : C.x) || 0;
    }), d = O(() => {
      var C;
      return ((C = t.pos) == null ? void 0 : C.y) || 0;
    }), v = O(() => t.state.label.direction === N.CENTER ? 0 : t.state.label.margin * i.value), x = Z(0), P = Z(0), E = Z(0), p = Z(0), m = O(() => {
      var B;
      const C = t.state.label.direction, $ = t.state.label.directionAutoAdjustment;
      if ($ === !1)
        return C;
      const A = { x: f.value, y: d.value };
      return $ === !0 ? hf(
        t.state.id,
        A,
        t.state.oppositeNodes,
        (Y) => {
          var j, F;
          return (F = (j = o[Y]) == null ? void 0 : j.loop) == null ? void 0 : F.center;
        },
        C
      ) : (B = $({
        nodeId: t.state.id,
        pos: A,
        oppositeNodes: t.state.oppositeNodes
      })) != null ? B : C;
    }), w = O(() => {
      switch (m.value) {
        case N.CENTER:
        case N.NORTH:
        case N.SOUTH:
          return "middle";
        case N.EAST:
        case N.NORTH_EAST:
        case N.SOUTH_EAST:
          return "start";
        case N.WEST:
        case N.NORTH_WEST:
        case N.SOUTH_WEST:
        default:
          return "end";
      }
    }), b = O(() => {
      switch (m.value) {
        case N.NORTH:
        case N.NORTH_EAST:
        case N.NORTH_WEST:
          return "text-top";
        case N.SOUTH:
        case N.SOUTH_EAST:
        case N.SOUTH_WEST:
          return "hanging";
        case N.CENTER:
        case N.EAST:
        case N.WEST:
        default:
          return "central";
      }
    }), h = O(() => {
      switch (m.value) {
        case N.CENTER:
        case N.NORTH:
        case N.SOUTH:
          return 0;
        case N.EAST:
          return P.value;
        case N.WEST:
          return -P.value;
        case N.NORTH_EAST:
        case N.SOUTH_EAST:
          return p.value;
        case N.NORTH_WEST:
        case N.SOUTH_WEST:
        default:
          return -p.value;
      }
    }), g = O(() => {
      switch (m.value) {
        case N.NORTH:
          return -x.value;
        case N.SOUTH:
          return x.value;
        case N.CENTER:
        case N.EAST:
        case N.WEST:
          return 0;
        case N.NORTH_EAST:
        case N.NORTH_WEST:
          return -E.value;
        case N.SOUTH_EAST:
        case N.SOUTH_WEST:
        default:
          return E.value;
      }
    });
    me(() => {
      const C = i.value, $ = t.state.shape;
      if ($.type == "circle") {
        const A = $.radius * C, B = A + v.value, Y = Math.sqrt(ce(B, 2) / 2);
        x.value = A + v.value, P.value = A + v.value, E.value = Y, p.value = Y;
      } else {
        const A = $.borderRadius * C, B = $.width * C, Y = $.height * C, j = A + v.value, F = Math.sqrt(ce(j, 2) / 2);
        x.value = Y / 2 + v.value, P.value = B / 2 + v.value, E.value = Y / 2 - A + F, p.value = B / 2 - A + F;
      }
    });
    const k = O(() => (C) => n.label.handleNodeEvents ? {
      pointerdown: ($) => {
        $.stopPropagation(), r(C, $);
      },
      pointerenter: ($) => s(C, $),
      pointerleave: ($) => a(C, $),
      click: ($) => {
        $.stopPropagation(), l(C, $);
      },
      dblclick: ($) => {
        $.stopPropagation(), u(C, $);
      },
      contextmenu: ($) => {
        c(C, $);
      }
    } : {}), T = O(() => {
      const C = n.label.handleNodeEvents;
      return {
        "v-ng-node-label": !0,
        hover: C && t.state.hovered,
        selected: C && t.state.selected
      };
    }), _ = O(() => {
      const C = n.label.handleNodeEvents;
      return {
        draggable: C && t.state.draggable,
        selectable: C && t.state.selectable
      };
    });
    return (C, $) => (M(), I("g", Se({
      class: y(T),
      transform: `translate(${y(f)} ${y(d)})`
    }, wr(y(k)(e.id), !0)), [
      K(C.$slots, "override-node-label", {
        nodeId: e.id,
        scale: y(i),
        text: e.state.labelText,
        x: y(h),
        y: y(g),
        config: e.state.label,
        shape: e.state.shape,
        textAnchor: y(w),
        dominantBaseline: y(b),
        class: pe(y(_))
      }, () => [
        Fe(qt, {
          text: e.state.labelText,
          x: 0,
          y: 0,
          config: e.state.label,
          "text-anchor": y(w),
          "dominant-baseline": y(b),
          class: pe(y(_)),
          transform: `translate(${y(h)} ${y(g)})`
        }, null, 8, ["text", "config", "text-anchor", "dominant-baseline", "class", "transform"])
      ])
    ], 16, gf));
  }
});
const mf = /* @__PURE__ */ W({
  __name: "VNodeLabelsLayer",
  setup(e) {
    const t = jt(), n = O(() => "override-node-label" in t), { nodeZOrderedList: o } = Me(), i = Ft(), r = Rn(), s = O(() => a(o.value));
    function a(l) {
      return l.filter((u) => {
        var c;
        return u.label.visible && ((c = u.labelText) != null ? c : !1);
      });
    }
    return (l, u) => y(n) ? (M(), H(ht, {
      key: 0,
      name: y(i).transition,
      css: !!y(i).transition,
      tag: "g",
      class: "v-ng-layer-node-labels"
    }, {
      default: ne(() => [
        (M(!0), I(X, null, ee(y(s), (c) => (M(), H(jo, {
          id: c.id,
          key: c.id,
          state: c,
          pos: y(r).nodes[c.id]
        }, {
          "override-node-label": ne((f) => [
            K(l.$slots, "override-node-label", de(fe(f)))
          ]),
          _: 2
        }, 1032, ["id", "state", "pos"]))), 128))
      ]),
      _: 3
    }, 8, ["name", "css"])) : (M(), H(ht, {
      key: 1,
      name: y(i).transition,
      css: !!y(i).transition,
      tag: "g",
      class: "v-ng-layer-node-labels"
    }, {
      default: ne(() => [
        (M(!0), I(X, null, ee(y(s), (c) => (M(), H(jo, {
          id: c.id,
          key: c.id,
          state: c,
          pos: y(r).nodes[c.id]
        }, null, 8, ["id", "state", "pos"]))), 128))
      ]),
      _: 1
    }, 8, ["name", "css"]));
  }
});
function Tt(...e) {
  return e.find((t) => !!t);
}
const bf = Number.EPSILON * 100;
function yf(e, t, n, o, i, r, s, a) {
  var P, E;
  const l = e.edges, u = wf(l), c = l.map((p, m) => Ef(p, u[m], o[p.edgeId])), f = [];
  let d = !1, v = !1;
  {
    const p = c[0];
    let m = tt(t[p.source].shape) * i;
    const w = a + (s === "edgeOfNode" ? m : 0), b = w <= 0 ? p.line.source : Bo(p, w, n, !0);
    f.push(b), m = tt(t[p.target].shape) * i, a > 0 && te.distance(p.line.source, p.line.target) <= w + m && (d = !0);
  }
  const x = l.length;
  for (let p = 1; p < x; p++) {
    const m = c[p - 1], w = c[p], b = w.source, h = R.fromObject((P = n[b]) != null ? P : { x: 0, y: 0 }), g = xf(m, w, h), k = tt(t[b].shape) * i, T = Math.max(k * (2 / 3), k - 4 * i), _ = xn(m), C = xn(w), $ = Ot(m, h, T, _), A = Ot(w, h, T, !C), B = Ot(m, h, k, _), Y = Ot(w, h, k, !C);
    let j;
    if (g) {
      const F = te.distance(g, h);
      if (F < T)
        j = [
          Tt($, B, m.line.target),
          g,
          Tt(A, Y, w.line.source)
        ];
      else if (F <= k) {
        let ye, ie;
        B && $ ? ye = te.distance(g, $) < te.distance(g, B) ? $ : B : ye = B || m.line.target, Y && A ? ie = te.distance(g, A) < te.distance(g, Y) ? A : Y : ie = Y || w.line.source, j = [ye, g, ie];
      } else
        $ && A ? j = [$, h, A] : B && Y ? j = [B, h, Y] : j = [
          Tt($, B, m.line.target),
          h,
          Tt(A, Y, w.line.source)
        ];
    } else
      $ && A ? j = [$, h, A] : B && Y ? j = [B, h, Y] : j = [m.line.target, h, w.line.source];
    if (m.curve) {
      const F = f[f.length - 1];
      if (F) {
        const ye = F instanceof Array ? F[F.length - 1] : F;
        let ie;
        j instanceof Array ? ie = r ? j[0] : j[1] : ie = j;
        const Pe = bn(
          ye,
          m.curve.circle.center,
          ie,
          m.curve.theta
        );
        j instanceof Array && r ? f.push([...Pe, ...j]) : f.push([...Pe, ie]);
      }
    } else if (m.loop) {
      const [F, ye, ie] = Ho(h, m, k);
      f.push(F), f.push(ie), j instanceof Array && r ? f.push([ye, j[1], j[2]]) : f.push(j[2]);
    } else
      r || !(j instanceof Array) ? f.push(j) : w.curve ? f.push(j[1]) : w.loop ? f.push(j[0]) : f.push(j[0], j[2]);
  }
  {
    const p = c[c.length - 1];
    let m = tt(t[p.target].shape) * i;
    const w = a + (s === "edgeOfNode" ? m : 0), b = w <= 0 ? p.line.target : Bo(p, w, n, !1);
    if (m = tt(t[p.source].shape) * i, p.loop) {
      const h = R.fromObject((E = n[p.target]) != null ? E : { x: 0, y: 0 }), [g, k, T] = Ho(h, p, m);
      f.push(g), f.push(T);
    } else if (p.curve) {
      const h = f[f.length - 1], g = h instanceof Array ? h[h.length - 1] : h, k = bn(
        g,
        p.curve.circle.center,
        b,
        p.curve.theta
      );
      f.push([...k, b]);
    } else
      f.push(b);
    a > 0 && te.distance(p.line.source, p.line.target) <= w + m && (v = !0);
  }
  return d && (f.shift(), f[0] instanceof Array && f.unshift(f[0][0])), v && f.pop(), f;
}
function wf(e) {
  const t = e.length;
  if (t <= 1)
    return [!0];
  const n = [];
  let o = null, i = !0;
  for (let r = 0; r < t; r++) {
    const s = e[r].edge.source, a = e[r].edge.target;
    if (r === 0)
      if (t > 2) {
        const l = [s, a].sort(), u = [e[1].edge.source, e[1].edge.target].sort();
        l[0] === u[0] && l[1] === u[1] ? [e[2].edge.source, e[2].edge.target].includes(e[1].edge.target) ? i = a === e[1].edge.source : i = a === e[1].edge.target : i = [e[1].edge.source, e[1].edge.target].includes(a);
      } else
        i = [e[1].edge.source, e[1].edge.target].includes(a);
    else
      s === a || (i = o === s);
    n.push(i), o = i ? a : s;
  }
  return n;
}
function Bo(e, t, n, o) {
  const i = o ? e.source : e.target, r = e.curve;
  if (r) {
    let s = t / r.circle.radius;
    return r.theta > 0 && (s *= -1), o || (s *= -1), R.fromObject(
      Le(
        o ? e.line.source : e.line.target,
        r.circle.center,
        s
      )
    );
  } else {
    let s, a;
    if (o ? (s = e.line.target, a = e.line.source) : (s = e.line.source, a = e.line.target), n[i]) {
      const l = Ut(
        s,
        a,
        R.fromObject(n[i]),
        t
      );
      return l === null ? s : l;
    } else
      return s;
  }
}
function xf(e, t, n) {
  let o = null;
  if (e.loop || t.loop)
    o = null;
  else if (e.curve)
    if (t.curve) {
      if (e.line.target.isEqualTo(t.line.source))
        return e.line.target.clone();
      o = mt(
        e.curve.circle.center,
        e.curve.circle.radius,
        t.curve.circle.center,
        t.curve.circle.radius,
        e.curve.center
      );
    } else
      o = Vc(
        t.line.target,
        t.line.source,
        e.curve.circle.center,
        e.curve.circle.radius,
        n
      );
  else if (t.curve)
    o = Ut(
      e.line.source,
      e.line.target,
      t.curve.circle.center,
      t.curve.circle.radius
    );
  else {
    const i = Ro(e.line), r = Ro(t.line);
    !isFinite(i) && !isFinite(r) || Math.abs(i - r) < bf ? o = null : o = Ve(e.line, t.line);
  }
  return o;
}
function Ot(e, t, n, o) {
  if (e.loop) {
    const i = mt(
      t,
      n,
      e.loop.center,
      e.loop.radius[0]
    );
    return i ? o ? i[0] : i[1] : null;
  } else
    return e.curve ? mt(
      t,
      n,
      e.curve.circle.center,
      e.curve.circle.radius,
      R.fromObject(e.curve.center)
    ) : Ut(
      o ? e.line.source : e.line.target,
      o ? e.line.target : e.line.source,
      t,
      n
    );
}
function Ef(e, t, n) {
  let o = n.origin, i = e.edge.source, r = e.edge.target, s = n.curve;
  const a = n.loop;
  a ? o = n.position : t || (o = Hc(o), i = e.edge.target, r = e.edge.source, s && (s = st(se({}, s), { theta: -s.theta })));
  const l = J.fromLinePosition(o);
  return {
    edgeId: e.edgeId,
    source: i,
    target: r,
    line: l,
    direction: t,
    curve: s,
    loop: a
  };
}
function Ro(e) {
  return (e.target.y - e.source.y) / (e.target.x - e.source.x);
}
function Ho(e, t, n) {
  const { radius: o, center: i } = q(t.loop, "Loop of edge parameter"), [r, s] = o, a = mt(e, n, i, o[0]);
  let [l, u] = a ? a.reverse() : [t.line.source, t.line.target];
  const c = xn(t);
  c || ([l, u] = [u, l]);
  const f = l, d = u, v = R.fromObject(f).subtract(i).angleDegree();
  let E = (R.fromObject(d).subtract(i).angleDegree() + 360 - v) % 360 >= 180;
  return E = c ? E : !E, [f, d, `A ${r} ${s} 0 ${E ? 1 : 0} ${c ? 1 : 0} ${d.x} ${d.y}`];
}
function xn(e) {
  return e.loop ? e.direction ? e.loop.isClockwise : !e.loop.isClockwise : !0;
}
const Pf = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin"], Sf = /* @__PURE__ */ W({
  __name: "VPath",
  props: {
    path: null
  },
  setup(e) {
    const t = e, { nodeStates: n, edgeStates: o, layouts: i } = Me(), { scale: r } = be(), s = gi();
    function a(d) {
      if (d.edges.length === 0)
        return [];
      const v = z.value(s.margin, d.path) * r.value;
      return yf(
        d,
        n,
        i.nodes,
        o,
        r.value,
        s.curveInNode,
        s.end,
        v
      );
    }
    function l(d) {
      const v = a(d);
      let x = !0;
      return v.map((P) => {
        if (P === null)
          x = !0;
        else {
          if (typeof P == "string")
            return P;
          if (P instanceof Array) {
            P = [...P];
            const E = [];
            if (P.length % 2 === 1) {
              const p = P[0];
              P = P.slice(1), E.push(`L ${p.x} ${p.y}`);
            }
            return jn(P, 2).map(([p, m]) => E.push(`Q ${p.x} ${p.y} ${m.x} ${m.y}`)), E.join(" ");
          } else {
            const E = x;
            return x = !1, `${E ? "M " : "L "}${P.x} ${P.y}`;
          }
        }
      }).join(" ");
    }
    const u = O(() => {
      const d = t.path;
      return d.selected ? z.values(s.selected, d.path) : d.hovered && s.hover ? z.values(s.hover, d.path) : z.values(s.normal, d.path);
    }), c = O(() => xt(u.value.dasharray, r.value)), f = O(() => {
      const d = u.value.animate ? Vt(u.value.dasharray) * u.value.animationSpeed * r.value : !1;
      return d ? `--animation-speed:${d}` : void 0;
    });
    return (d, v) => (M(), I("path", {
      class: pe({
        "v-ng-path": !0,
        animate: y(u).animate,
        clickable: e.path.clickable,
        hoverable: e.path.hoverable
      }),
      d: l(e.path),
      fill: "none",
      stroke: y(u).color,
      "stroke-width": y(u).width * y(r),
      "stroke-dasharray": y(c),
      "stroke-linecap": y(u).linecap,
      "stroke-linejoin": y(u).linejoin,
      style: yt(y(f))
    }, null, 14, Pf));
  }
});
const kf = /* @__PURE__ */ W({
  __name: "VPaths",
  setup(e) {
    const { pathZOrderedList: t } = Me(), n = gi(), {
      handlePathPointerDownEvent: o,
      handlePathPointerOverEvent: i,
      handlePathPointerOutEvent: r,
      handlePathClickEvent: s,
      handlePathDoubleClickEvent: a,
      handlePathContextMenu: l
    } = Pt();
    return (u, c) => (M(), H(ht, {
      name: y(n).transition,
      css: !!y(n).transition,
      tag: "g",
      class: "v-ng-paths"
    }, {
      default: ne(() => [
        (M(!0), I(X, null, ee(y(t), (f) => (M(), H(Sf, {
          key: f.id,
          path: f,
          onPointerdown: (d) => y(o)(f.id, d),
          onPointerenterPassive: (d) => y(i)(f.id, d),
          onPointerleavePassive: (d) => y(r)(f.id, d),
          onClick: Ee((d) => y(s)(f.id, d), ["stop"]),
          onDblclick: Ee((d) => y(a)(f.id, d), ["stop"]),
          onContextmenu: (d) => y(l)(f.id, d)
        }, null, 8, ["path", "onPointerdown", "onPointerenterPassive", "onPointerleavePassive", "onClick", "onDblclick", "onContextmenu"]))), 128))
      ]),
      _: 1
    }, 8, ["name", "css"]));
  }
}), Mf = /* @__PURE__ */ W({
  __name: "VPathsLayer",
  setup(e) {
    return (t, n) => (M(), H(kf));
  }
}), Tf = { key: 0 }, Of = /* @__PURE__ */ W({
  __name: "VNetworkGraph",
  props: {
    nodes: { default: () => ({}) },
    edges: { default: () => ({}) },
    paths: { default: () => ({}) },
    layouts: { default: () => ({}) },
    zoomLevel: { default: 1 },
    selectedNodes: { default: () => [] },
    selectedEdges: { default: () => [] },
    selectedPaths: { default: () => [] },
    configs: { default: () => ({}) },
    layers: { default: () => ({}) },
    eventHandlers: { default: () => ({}) }
  },
  emits: ["update:zoomLevel", "update:selectedNodes", "update:selectedEdges", "update:selectedPaths", "update:layouts"],
  setup(e, { expose: t, emit: n }) {
    const o = e, i = [
      "override-node",
      "override-node-label",
      "edge-overlay",
      "edge-label",
      "edges-label"
    ], r = jt(), s = Te(o, "nodes"), a = Te(o, "edges"), { objects: l, isInCompatibilityModeForPath: u } = dd(
      Te(o, "paths")
    ), c = Gu();
    Object.entries(o.eventHandlers).forEach(([S, L]) => {
      c.on(S, L);
    });
    const f = _l(Te(o, "configs")), d = O(() => {
      const S = new Set(Object.keys(r));
      i.forEach((D) => S.delete(D));
      const L = Object.fromEntries(xr.map((D) => [D, []]));
      return Object.assign(
        L,
        Object.entries(o.layers).reduce((D, [V, re]) => (S.delete(V), re in D ? D[re].push(V) : D[re] = [V], D), {})
      ), L.root.push(...S), L;
    }), v = O(() => f.view.grid.visible), x = O(() => {
      const S = d.value;
      return v.value || S.background.length > 0 || S.grid.length > 0;
    }), P = bd(f, r), E = Z(), p = Z(), m = Z(), w = Z(
      0
      /* INITIAL */
    ), b = O(
      () => w.value !== 0
      /* INITIAL */
    ), h = fd(o, "zoomLevel", n, (S) => (S = Math.max(S, f.view.minZoomLevel), S = Math.min(S, f.view.maxZoomLevel), S)), { svgPanZoom: g, onSvgPanZoomMounted: k, onSvgPanZoomUnmounted: T } = ad(p, {
      viewportSelector: ".v-ng-viewport",
      minZoom: f.view.minZoomLevel,
      // temporary
      maxZoom: f.view.maxZoomLevel,
      // temporary
      dblClickZoomEnabled: Gn(f.view),
      mouseWheelZoomEnabled: Qt(f.view),
      fit: !0,
      center: !0,
      zoomEnabled: f.view.zoomEnabled,
      preventMouseEventsDefault: !1,
      onZoom: (S) => {
        var D, V;
        if (w.value === 2)
          return;
        const L = (V = (D = g.value) == null ? void 0 : D.getRealZoom()) != null ? V : 1;
        Math.abs(h.value - L) >= 1e-6 && (h.value = L, c.emit("view:zoom", L));
      },
      panEnabled: f.view.panEnabled,
      onPan: (S) => {
        w.value !== 2 && c.emit("view:pan", S);
      }
    });
    Er({ container: E, svg: p, viewport: m, svgPanZoom: g });
    const _ = { width: 0, height: 0 }, C = globalThis.ResizeObserver ? new ResizeObserver(() => {
      var L, D, V;
      if ((L = g.value) == null || L.resize(), !f.view.autoPanOnResize)
        return;
      const S = (D = E.value) == null ? void 0 : D.getBoundingClientRect();
      if (S) {
        const re = -(_.width - S.width) / 2, St = -(_.height - S.height) / 2;
        (V = g.value) == null || V.panBy({ x: re, y: St });
        const { width: et, height: Jt } = S;
        (_.width !== et || _.height !== Jt) && (Object.assign(_, { width: et, height: Jt }), c.emit("view:resize", { x: S.x, y: S.y, width: et, height: Jt }));
      }
    }) : void 0;
    k(() => {
      var re, St, et;
      const S = q(E.value, "svg-pan-zoom container");
      C == null || C.observe(S), (St = (re = f.view).onSvgPanZoomInitialized) == null || St.call(re, q(g.value, "svg-pan-zoom instance"));
      const L = S.getBoundingClientRect(), { width: D, height: V } = L;
      Object.assign(_, { width: D, height: V }), (et = m.value) == null || et.addEventListener("touchstart", Xn, { passive: !1 });
    }), T(() => {
      var S;
      C == null || C.disconnect(), (S = m.value) == null || S.removeEventListener("touchstart", Xn);
    });
    const $ = (S) => {
      var L;
      (L = g.value) == null || L.applyAbsoluteZoomLevel(
        S,
        f.view.minZoomLevel,
        f.view.maxZoomLevel
      );
    };
    G(
      () => f.view.panEnabled,
      (S) => {
        var L;
        (L = g.value) == null || L.setPanEnabled(S);
      }
    ), G(
      () => [
        f.view.zoomEnabled,
        Gn(f.view),
        Qt(f.view)
      ],
      () => {
        const S = g.value;
        S && ur(
          S,
          f.view.zoomEnabled,
          f.view.doubleClickZoomEnabled,
          f.view.mouseWheelZoomEnabled
        );
      }
    ), G(h, (S) => $(S)), G(
      () => [f.view.minZoomLevel, f.view.maxZoomLevel],
      (S) => {
        $(h.value);
      }
    );
    const { scale: A } = ld(h, f.view);
    k(() => {
      const S = o.zoomLevel;
      $(S);
    });
    const B = (S) => {
      var L;
      Object.keys(o.nodes).length > 0 ? ((L = g.value) == null || L.updateBBox(), Ct(S)) : S();
    }, Y = () => {
      B(() => {
        g.value && (g.value.fitToContents(), c.emit("view:fit", void 0));
      });
    }, j = () => {
      B(() => {
        var S;
        (S = g.value) == null || S.center();
      });
    }, F = () => {
      var S, L;
      return (L = (S = g.value) == null ? void 0 : S.getViewBox()) != null ? L : {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
    }, ye = (S) => {
      var L;
      return (L = g.value) == null ? void 0 : L.setViewBox(S);
    }, ie = cn(o, "selectedNodes", s, n);
    G(ie, (S) => c.emit("node:select", Array.from(S)));
    const Pe = cn(o, "selectedEdges", a, n);
    G(Pe, (S) => c.emit("edge:select", Array.from(S)));
    const le = cn(o, "selectedPaths", l, n);
    G(le, (S) => c.emit("path:select", Array.from(S))), hd(ie, Pe, le);
    const Qe = Ae(/* @__PURE__ */ new Set()), Je = Ae(/* @__PURE__ */ new Set()), Hn = Ae(/* @__PURE__ */ new Set()), _e = Ae({ nodes: {} });
    pd(_e), G(
      () => o.layouts,
      () => Object.assign(_e, o.layouts),
      { deep: !0, immediate: !0 }
    ), G(_e, () => n("update:layouts", _e), { deep: !0 });
    const Kt = qc(), Yt = Z(!1);
    c.on("node:dragstart", (S) => Yt.value = !0), c.on("node:dragend", (S) => Yt.value = !1), c.on("view:mode", (S) => {
      var L, D, V, re;
      f.view.panEnabled && (S === "default" ? (L = g.value) == null || L.enablePan() : (D = g.value) == null || D.disablePan()), f.view.zoomEnabled && (S === "default" ? (V = g.value) == null || V.enableZoom() : (re = g.value) == null || re.disableZoom());
    });
    const Wi = O(() => f.view.panEnabled || f.view.zoomEnabled || f.node.draggable), { nodeStates: Fi, edgeStates: Ui, pathStates: Gi } = eu(
      sn(s, ie, Qe),
      sn(a, Pe, Je),
      sn(l, le, Hn),
      at(f),
      _e,
      Kt,
      A
    ), Xi = O(() => Qt(f.view)), { isBoxSelectionMode: qi, selectionBox: Vn, startBoxSelection: Ki, stopBoxSelection: Yi } = Fu(
      p,
      at(_e),
      at(h),
      Fi,
      Ui,
      Gi,
      ie,
      Pe,
      le,
      Qe,
      Je,
      Hn,
      u,
      Xi,
      f,
      c
    ), Wn = () => ({
      layouts: Ae(_e.nodes),
      // deprecated parameter.
      nodePositions: Te(_e, "nodes"),
      nodes: s,
      edges: a,
      configs: at(f),
      scale: at(A),
      emitter: c,
      svgPanZoom: q(g.value)
    });
    G(
      () => f.view.layoutHandler,
      (S, L) => {
        L.deactivate(), S.activate(Wn());
      }
    );
    const { transitionWhile: Qi, transitionOption: Fn } = ud(), Ji = O(() => {
      const S = Fn.value;
      return S.enabled ? {
        "--transition-duration": S.duration + "ms",
        "--transition-function": S.timingFunction
      } : {};
    });
    k(() => {
      B(() => {
        const S = q(g.value, "svg-pan-zoom");
        f.view.layoutHandler.activate(Wn()), Ct(() => {
          const L = f.view.autoPanAndZoomOnLoad;
          if (f.view.fit || L !== !1) {
            const D = Object.keys(o.nodes).length == 0, V = S.getPan();
            if (D || L === "center-zero") {
              const re = S.getSizes();
              S.pan({
                x: re.width / 2,
                y: re.height / 2
              });
            } else
              L === "fit-content" || f.view.fit ? Y() : L === "center-content" && j();
            Ct(() => {
              const re = S.getPan();
              V.x === re.x && V.y === re.y && c.emit("view:pan", re);
            });
          }
          c.emit("view:load"), w.value = 1;
        });
      });
    }), T(() => {
      w.value = 2, c.emit("view:unload"), f.view.layoutHandler.deactivate();
    });
    function er() {
      var S;
      (S = g.value) == null || S.zoomIn();
    }
    function tr() {
      var S;
      (S = g.value) == null || S.zoomOut();
    }
    function nr(S) {
      var L;
      (L = g.value) == null || L.pan(S);
    }
    function or(S) {
      var L;
      (L = g.value) == null || L.panBy(S);
    }
    function ir() {
      return q(g.value).getPan();
    }
    function rr() {
      const S = q(g.value).getSizes();
      return {
        width: S.width,
        height: S.height,
        viewBox: S.viewBox
      };
    }
    function sr(S) {
      return yn(
        q(p.value, "svg"),
        q(m.value, "viewport"),
        S
      );
    }
    function ar(S) {
      return Zu(
        q(p.value, "svg"),
        q(m.value, "viewport"),
        S
      );
    }
    function lr() {
      return zi(
        q(p.value, "svg"),
        q(m.value, "viewport"),
        A.value
      ).outerHTML;
    }
    function cr() {
      return Re(this, arguments, function* (S = {}) {
        return (yield Un(S)).outerHTML;
      });
    }
    function Un() {
      return Re(this, arguments, function* (S = {}) {
        return Bu(
          q(p.value, "svg"),
          q(m.value, "viewport"),
          A.value,
          S
        );
      });
    }
    t({
      // methods
      fitToContents: Y,
      panToCenter: j,
      getViewBox: F,
      setViewBox: ye,
      transitionWhile: Qi,
      startBoxSelection: Ki,
      stopBoxSelection: Yi,
      zoomIn: er,
      zoomOut: tr,
      panTo: nr,
      panBy: or,
      getPan: ir,
      getSizes: rr,
      translateFromDomToSvgCoordinates: sr,
      translateFromSvgToDomCoordinates: ar,
      getAsSvg: lr,
      exportAsSvgText: cr,
      exportAsSvgElement: Un
    });
    function ur(S, L, D, V) {
      S.setZoomEnabled(L), L && D ? S.enableDblClickZoom() : S.disableDblClickZoom(), L && V ? S.enableMouseWheelZoom() : S.disableMouseWheelZoom();
    }
    function Gn(S) {
      return S.zoomEnabled && S.doubleClickZoomEnabled;
    }
    function Qt(S) {
      return S.zoomEnabled && S.mouseWheelZoomEnabled;
    }
    function Xn(S) {
      S.stopPropagation();
    }
    return (S, L) => (M(), I("div", {
      ref_key: "container",
      ref: E,
      class: "v-network-graph v-ng-container"
    }, [
      (M(), I("svg", {
        ref_key: "svg",
        ref: p,
        class: pe(["v-ng-canvas", { show: y(b), dragging: Yt.value, touches: y(Wi), "box-selection-mode": y(qi) }]),
        width: "100%",
        height: "100%"
      }, [
        (M(!0), I(X, null, ee(y(d).root, (D) => K(S.$slots, D, {
          key: D,
          scale: y(A)
        })), 128)),
        Object.keys(y(Kt).markers).length > 0 ? (M(), I("defs", Tf, [
          (M(!0), I(X, null, ee(y(Kt).markers, (D, V) => (M(), H(Od, {
            id: V,
            key: V,
            marker: D,
            scale: y(A)
          }, null, 8, ["id", "marker", "scale"]))), 128))
        ])) : ue("", !0),
        y(x) ? (M(), H(Ld, { key: 1 }, {
          default: ne(() => [
            (M(!0), I(X, null, ee(y(d).background, (D) => (M(), I("g", {
              key: D,
              class: "v-ng-layer"
            }, [
              K(S.$slots, D, { scale: y(A) })
            ]))), 128)),
            y(v) ? (M(), H(Ad, { key: 0 })) : ue("", !0),
            (M(!0), I(X, null, ee(y(d).grid, (D) => (M(), I("g", {
              key: D,
              class: "v-ng-layer"
            }, [
              K(S.$slots, D, { scale: y(A) })
            ]))), 128))
          ]),
          _: 3
        })) : ue("", !0),
        Vo("g", {
          ref_key: "viewport",
          ref: m,
          class: pe(["v-ng-viewport", { "v-ng-transition": y(Fn).enabled }]),
          style: yt(y(Ji))
        }, [
          (M(!0), I(X, null, ee(y(d).base, (D) => (M(), I("g", {
            key: D,
            class: "v-ng-layer"
          }, [
            K(S.$slots, D, { scale: y(A) })
          ]))), 128)),
          (M(!0), I(X, null, ee(y(P), (D) => (M(), I(X, { key: D }, [
            D === "edges" ? (M(), H(ef, { key: 0 }, {
              "edge-overlay": ne((V) => [
                K(S.$slots, "edge-overlay", de(fe(V)))
              ]),
              _: 3
            })) : D === "edge-labels" ? (M(), H(sf, {
              key: 1,
              "enable-edge-label": "edge-label" in y(r),
              "enable-edges-label": "edges-label" in y(r)
            }, {
              "edge-label": ne((V) => [
                K(S.$slots, "edge-label", de(fe(V)))
              ]),
              "edges-label": ne((V) => [
                K(S.$slots, "edges-label", de(fe(V)))
              ]),
              _: 3
            }, 8, ["enable-edge-label", "enable-edges-label"])) : D === "focusring" ? (M(), H(cf, { key: 2 })) : D === "nodes" ? (M(), H(df, { key: 3 }, {
              "override-node": ne((V) => [
                K(S.$slots, "override-node", de(fe(V)))
              ]),
              _: 3
            })) : D === "node-labels" ? (M(), H(mf, { key: 4 }, {
              "override-node-label": ne((V) => [
                K(S.$slots, "override-node-label", de(fe(V)))
              ]),
              _: 3
            })) : D === "paths" ? (M(), H(Mf, { key: 5 })) : ue("", !0),
            (M(!0), I(X, null, ee(y(d)[D], (V) => (M(), I("g", {
              key: V,
              class: "v-ng-layer"
            }, [
              K(S.$slots, V, { scale: y(A) })
            ]))), 128))
          ], 64))), 128))
        ], 6),
        y(Vn) ? (M(), H(wd, {
          key: 2,
          box: y(Vn),
          config: y(f).view.selection.box
        }, null, 8, ["box", "config"])) : ue("", !0)
      ], 2))
    ], 512));
  }
});
const Cf = /* @__PURE__ */ W({
  __name: "VEdgeLabel",
  props: {
    area: null,
    config: null,
    text: { default: "" },
    align: { default: "center" },
    verticalAlign: { default: "center" },
    edge: { default: void 0 },
    hovered: { type: Boolean, default: void 0 },
    selected: { type: Boolean, default: void 0 },
    scale: { default: void 0 }
  },
  setup(e) {
    const t = e, n = Z(0), o = Z(0), i = Z("middle"), r = Z("central"), s = Z(0);
    me(() => {
      const l = t.area.source, u = t.area.target;
      t.align === "source" ? (l.above.x == u.above.x ? i.value = l.above.y > u.above.y ? "start" : "end" : i.value = l.above.x < u.above.x ? "start" : "end", t.verticalAlign === "above" ? (n.value = l.above.x, o.value = l.above.y, r.value = "text-top") : t.verticalAlign === "below" ? (n.value = l.below.x, o.value = l.below.y, r.value = "hanging") : (n.value = (l.above.x + l.below.x) / 2, o.value = (l.above.y + l.below.y) / 2, r.value = "central")) : t.align === "target" ? (l.above.x == u.above.x ? i.value = l.above.y < u.above.y ? "start" : "end" : i.value = l.above.x > u.above.x ? "start" : "end", t.verticalAlign === "above" ? (n.value = u.above.x, o.value = u.above.y, r.value = "text-top") : t.verticalAlign === "below" ? (n.value = u.below.x, o.value = u.below.y, r.value = "hanging") : (n.value = (u.above.x + u.below.x) / 2, o.value = (u.above.y + u.below.y) / 2, r.value = "central")) : (i.value = "middle", t.verticalAlign === "above" ? (n.value = (l.above.x + u.above.x) / 2, o.value = (l.above.y + u.above.y) / 2, r.value = "text-top") : t.verticalAlign === "below" ? (n.value = (l.below.x + u.below.x) / 2, o.value = (l.below.y + u.below.y) / 2, r.value = "hanging") : (n.value = (l.above.x + u.below.x) / 2, o.value = (l.above.y + u.below.y) / 2, r.value = "central"));
      let c = J.fromPositions(l.above, u.above).v.angleDegree();
      (c < -90 || c >= 90) && (c = c + 180, c > 180 && (c -= 360)), s.value = c;
    });
    const a = O(() => r.value === "central" && !t.config.background ? st(se({}, t.config), {
      background: {
        visible: !0,
        color: "#ffffff",
        padding: {
          vertical: 1,
          horizontal: 4
        },
        borderRadius: 2
      }
    }) : t.config);
    return (l, u) => (M(), H(qt, {
      class: "v-ng-edge-label",
      text: e.text,
      x: n.value,
      y: o.value,
      config: y(a),
      "text-anchor": i.value,
      "dominant-baseline": r.value,
      transform: `rotate(${s.value} ${n.value} ${o.value})`
    }, null, 8, ["text", "x", "y", "config", "text-anchor", "dominant-baseline", "transform"]));
  }
}), $f = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VEdgeLabel: Cf,
  VLabelText: qt,
  VNetworkGraph: Of,
  VShape: Xt
}, Symbol.toStringTag, { value: "Module" })), _f = 10;
class Df extends hi {
  constructor(t = {}) {
    super(), this.options = t;
  }
  setNodePosition(t, n) {
    const o = this.options.grid || _f;
    t.value.x = Math.floor(n.x / o) * o, t.value.y = Math.floor(n.y / o) * o;
  }
}
const Zf = function(e) {
  Object.entries($f).forEach(([t, n]) => {
    e.component(t, n);
  });
};
export {
  z as Config,
  Df as GridLayout,
  xr as LayerPositions,
  N as NodeLabelDirection,
  hi as SimpleLayout,
  Cf as VEdgeLabel,
  qt as VLabelText,
  Of as VNetworkGraph,
  Xt as VShape,
  R as Vector2D,
  Af as configsWithType,
  Zf as default,
  Lf as defineConfigs,
  Nf as getFullConfigs,
  Me as useStates,
  nn as withSelf
};
//# sourceMappingURL=index.mjs.map
